<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>数据与可计算结构</title><link rel="icon" href="/assets/favicon.ico" /><style>:root body {
  color-scheme: light dark;
  --content-gap: 15px;
  --radius: 5px;
  --article-max-width: 90ex;
  --toc-max-width: 90ex;

  --text-color: black;
  --toc-link-color: #555;
  --background-color: white;

  --background-color-pre: rgba(0, 100, 100, 0.04);
  --background-color-code: rgba(0, 100, 100, 0.04);

  --hover-color-block: rgba(0, 100, 255, 0.04);
  --hover-color-link: rgba(0, 100, 255, 0.1);
  --target-color: rgb(67, 92, 255);

  --link-color: black;
  --slug-color: gray;
  --logo-color: #666;
  --logo-hover-color: #aaa;
  --span-taxon-color: #444;
  --article-taxon-color: #888;
  --mark-color: rgb(255, 255, 151);
  --em-color: var(--text-color);
}

@media (prefers-color-scheme: dark) {
  :root body {
    --text-color: white;
    --toc-link-color: white;
    --background-color: #2f2f2f;

    --background-color-pre: rgba(100, 100, 100, 0.2);
    --background-color-code: rgba(150, 150, 150, 0.2);

    --hover-color-block: rgba(100, 162, 255, 0.06);
    --hover-color-link: rgba(100, 162, 255, 0.2);
    --target-color: rgb(255, 255, 151);

    --link-color: white;
    --slug-color: #aeaeae;
    --logo-color: #999;
    --logo-hover-color: #eee;
    --span-taxon-color: #bbb;
  }
}

body {
  color: var(--text-color);
  font-optical-sizing: auto;
  hyphens: auto;
  background-color: var(--background-color);
}

pre,
code {
  font-optical-sizing: auto;
}

p,
pre {
  line-height: 1.55;
}

pre {
  border-radius: var(--radius);
  background-color: var(--background-color-pre);
  padding: 0.5em;
  font-size: 11pt;
  margin-top: 0em;
  overflow-x: auto;
  white-space: pre-wrap;
  white-space: -moz-pre-wrap;
  white-space: -pre-wrap;
  white-space: -o-pre-wrap;
  word-wrap: break-word;
}

code {
  border-radius: var(--radius);
  background-color: var(--background-color-code);
  padding: 0.2em;
  font-size: 1em;
}

em {
  color: var(--em-color);
}

table {
  border-collapse: collapse;
}

/* !forest */
th {
  font-weight: normal;
  text-align: left;
}

th,
td {
  padding: 0 15px;
  vertical-align: top;
}

/* !forest */
pre>code {
  border-radius: 0;
  background-color: transparent;
  padding: 0;
}

/* !forest */
.footnote-definition:last-child {
  margin-bottom: 1em;
}

/* !forest */
.footnote-definition>p {
  display: inline;
}

/* !forest */
.footnote-definition-label {
  margin-right: 4px;
}

/* !forest */
.footnote-reference:target {
  border: 1px solid var(--target-color);
}

.footnote-definition:target>.footnote-definition-label {
  border: 1px solid var(--target-color);
}

.footnote-reference::before,
.footnote-definition-label::before {
  content: "[";
}

.footnote-reference::after,
.footnote-definition-label::after {
  content: "]";
}

.katex {
  /* Adjust `.katex font-size` to match "Noto Sans SC" & "Inria Sans". */
  font: normal 1.15em KaTeX_Main, Times New Roman, serif;
  line-height: 1.1em;
  text-indent: 0;
  text-rendering: auto;
}

.katex .mfrac .frac-line {
  font-size: 1.25em;
}

p:has(span.katex-html:empty) {
  display: none;
}

.katex-display {
  overflow-x: auto;
  overflow-y: hidden;
}

.katex-display .katex {
  /* Inconsistent bounding box at different font sizes. */
  /* Also see: https://github.com/KaTeX/KaTeX/issues/3965 */
  padding-top: 1px;
}

.display-none {
  display: none;
}

blockquote {
  font-style: italic;
}

blockquote {
  display: block;
  margin-block-start: 1em;
  margin-block-end: 1em;
  margin-inline-start: 40px;
  margin-inline-end: 40px;
  unicode-bidi: isolate;
}

h1,
h2,
h3,
h4 {
  margin-top: 0.5em;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-weight: normal;
  font-weight: 500;
  margin-bottom: 0;
}

h5,
h6,
p {
  margin-top: 0;
}

details>summary {
  list-style-type: none;
  outline: none;
}

details>summary>header {
  display: inline;
}

/* no effect */
details>summary::marker,
details>summary::-webkit-details-marker {
  display: none;
}

details h1 {
  font-size: 1.2em;
  display: inline;
}

details>summary {
  list-style-type: none;
}

span.taxon {
  color: var(--span-taxon-color);
  font-weight: 500;
}

section .block[data-taxon] details>summary>header>h1 {
  font-size: 13pt;
}

article>section>details>summary>header>h1 {
  font-size: 1.5em;
}

article>section>details>summary>header {
  display: block;
  margin-bottom: 0.5em;
}

article>section>details>summary>header>h1>.taxon {
  display: block;
  font-size: 0.9em;
  color: var(--article-taxon-color);
  padding-bottom: 5pt;
}

article>section>details>summary>header>h1>.taxon:empty {
  display: none;
}

section.block>details {
  margin-bottom: 0.4em;
}

section.block>details[open] {
  margin-bottom: 1em;
}

.link-list>section.block>details {
  margin-bottom: 0.25em;
}

/* class */
.inline-typst {
  display: inline-block;
  margin: 0 0;
  line-height: 1em;
  vertical-align: middle;
}

.block {
  padding-left: 5px;
  padding-right: 10px;
  padding-bottom: 2px;
  border-radius: 5px;
}

.block {
  /* width: fit-content; */
  border-radius: var(--radius);
}

.block:hover {
  background-color: var(--hover-color-block);
}

.block.hide-metadata>details>summary>header>.metadata {
  display: none;
}

img {
  object-fit: cover;
  max-width: 100%;
}

figure {
  text-align: center;
}

figcaption {
  font-style: italic;
  padding: 3px;
}

mark {
  background-color: var(--mark-color);
}

hr {
  margin-top: 10px;
  margin-bottom: 20px;
  background-color: gray;
  border: 0 none;
  width: 100%;
  height: 1pt;
}

ul,
ol {
  margin-top: 1em;
  margin-bottom: 1em;
}

.logo>span {
  color: var(--logo-color);
  text-decoration: none;
}

.logo>span:hover {
  color: var(--logo-hover-color);
}

.logo {
  font-weight: 600;
  font-size: 24px;
}

section section[data-taxon="Reference"]>details>summary>header>h1>.taxon,
section section[data-taxon="Person"]>details>summary>header>h1>.taxon {
  display: none;
}

section .block[data-taxon]>header>h1,
section .block[data-taxon] details>summary>header>h1 {
  font-size: 13pt;
}

footer>section {
  margin-bottom: 1em;
}

footer h2 {
  font-size: 14pt;
}

.metadata ul {
  padding-left: 0;
  display: inline;
}

.metadata li::after {
  content: " · ";
}

.metadata li:last-child::after {
  content: "";
}

.metadata * {
  display: inline;
}

.link {
  cursor: pointer;
}

a {
  color: var(--link-color);
  text-decoration: inherit;
}

a.slug:hover,
a.bullet:hover,
.edit-button:hover,
.link:hover {
  background-color: var(--hover-color-link);
}

.link.external {
  text-decoration: underline;
}

.link.asset {
  text-decoration: underline;
}

.link.asset::before {
  content: "[F] ";
}

a.link.local,
.link.local a,
a.slug {
  box-shadow: none;
  text-decoration-line: underline;
  text-decoration-style: dotted;
}

.slug,
.doi,
.orcid {
  color: var(--slug-color);
  font-weight: 200;
}

body>header {
  margin-bottom: 0.5em;
}

#grid-wrapper>article {
  max-width: var(--article-max-width);
  margin-right: auto;
  grid-area: article;
}

@media only screen and (max-width: 1000px) {
  body {
    margin-top: 1em;
    margin-left: 0.5em;
    margin-right: 0.5em;
    transition: ease all 0.2s;
  }

  #grid-wrapper>nav {
    transition: ease all 0.2s;
  }

  .mobile-sticky-nav {
    position: sticky;
    top: 0px;
    max-height: calc(100vh - 0px);
    overflow-y: auto;
    scrollbar-width: thin;

    background-color: var(--background-color);
    z-index: 7;
    border-bottom: solid var(--text-color);
  }
}

@media only screen and (min-width: 1000px) {
  body {
    margin-top: 2em;
    margin-left: 2em;
    transition: ease all 0.2s;
  }

  #grid-wrapper {
    display: grid;
    grid-auto-flow: column;
  }

  .sticky-nav {
    position: sticky;
    top: 0px;
    max-height: calc(100vh - 0px);
    overflow-y: auto;
    scrollbar-width: thin;
  }
}

nav#toc li.item-summary li {
  display: none;
}

nav#toc ul {
  list-style-type: none;
}

nav#toc li>ul {
  margin: 0;
  padding-left: 1em;
}

nav#toc,
nav#toc a {
  color: var(--toc-link-color);
}

nav#toc {
  grid-area: toc;
}

nav {
  font-optical-sizing: auto;
}

nav#toc a.bullet {
  opacity: 0.7;
  margin-left: 0.4em;
  margin-right: 0.3em;
  padding-left: 0.2em;
  padding-right: 0.2em;
  text-decoration: none;
}

.typst-text use[fill="#000000"] {
  fill: var(--text-color);
}

.typst-group use[fill="#000000"] {
  fill: var(--text-color);
}

path.typst-shape[fill="#000000"] {
  fill: var(--text-color);
}

path.typst-shape[stroke="#000000"] {
  stroke: var(--text-color);
}</style><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style><style>
  footer section[data-taxon]:has(a[href="/index"]) {
    display: none;
  }
</style><link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  href="https://fonts.googleapis.com/css2?family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap"
  rel="stylesheet" />

<style>
  body {
    font-family: "Inria Sans", sans-serif;
    line-height: 1.55;
  }

  .cjk_fallback {
    font-family: "Inria Sans", sans-serif;
  }

  pre,
  code {
    font-family: monospace;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-family: "Inria Sans", sans-serif;
  }

  nav {
    font-family: "Inria Sans", sans-serif;
  }

  thead {
    font-family: "Inria Sans", sans-serif;
  }
</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css"
  integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous" />
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js"
  integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js"
  integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js"
  integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  function storeSelectedTheme(name) {
    localStorage.setItem(window.themeKey, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(window.themeKey) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }

      applyDynamicColorInvert();
    }
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    const baseUrl = document.getElementById("grid-wrapper").dataset.baseUrl;
    window.themeKey = `${baseUrl}-kodama-theme`;

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');
  
  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const dynamicStyleId = 'dynamic-color-invert-style';

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const result = solveColor(rgb);
      const filter = result.filter;

      const existingStyle = document.getElementById(dynamicStyleId);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = dynamicStyleId;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script></head><body><header class="header"><nav class="nav"><div class="logo"><span onclick="window.location.href='/index'" title="回声">« 回声</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="/"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"><!-- Copyright (c) 2025 Kodama Project. All rights reserved. -->
<!-- Released under the Apache-2.0 license as described in the file LICENSE. -->
<!-- Authors: Kokic (@kokic) -->

<style>
  body:has(input[value="printer"]:checked) {
    --hover-primary-color: 235, 235, 235;
    --link-primary-color: 115, 80, 87;

    --text-color: rgb(20, 22, 27);
    --toc-link-color: #555;
    --background-color: #ffffff;

    --background-color-pre: rgba(0, 100, 100, 0.04);
    --background-color-code: rgba(0, 100, 100, 0.04);

    --hover-color-block: rgba(var(--hover-primary-color));
    --hover-color-link: rgba(201, 201, 201, 0.8);
    --target-color: rgb(255, 255, 151);

    --link-color: rgb(var(--link-primary-color));
    --slug-color: rgb(99, 99, 99);
    --logo-color: #999;
    --logo-hover-color: #666;
    --span-taxon-color: rgb(var(--link-primary-color));
    --em-color: rgb(53, 53, 53);

    .block:has(.block:hover) {
      background-color: var(--background-color);
    }
  }
</style>

<theme-option name="printer" style="display: none;">printer</theme-option>
</div><div class="block"><details open=""><summary><h1>Table of Contents</h1></summary><ul class="block"><li class="item-summary"><a class="bullet" href="/data-structure/seven-trees-in-one" title="七树合一定理 [data-structure/seven-trees-in-one]">■</a><span class="link local" onclick="window.location.href='#data-structure-seven-trees-in-one'"><span class="taxon"></span>七树合一定理</span><ul class="block"><li class=""><a class="bullet" href="/data-structure/binary-tree" title="二叉树类型 [data-structure/binary-tree]">■</a><span class="link local" onclick="window.location.href='#data-structure-binary-tree'"><span class="taxon">Definition 1. </span>二叉树类型</span></li><li class=""><a class="bullet" href="/data-structure/blass-lawvere" title="Blass–Lawvere 定理 [data-structure/blass-lawvere]">■</a><span class="link local" onclick="window.location.href='#data-structure-blass-lawvere'"><span class="taxon">Theorem 2. </span>Blass–Lawvere 定理</span></li></ul></li><li class="item-summary"><a class="bullet" href="/data-structure/stack-permutation/isomorphism" title="栈置换–二叉树同构 [data-structure/stack-permutation/isomorphism]">■</a><span class="link local" onclick="window.location.href='#data-structure-stack-permutation-isomorphism'"><span class="taxon"></span>栈置换–二叉树同构</span><ul class="block"><li class=""><a class="bullet" href="/data-structure/stack-permutation/stack-permutation" title="栈置换 [data-structure/stack-permutation/stack-permutation]">■</a><span class="link local" onclick="window.location.href='#data-structure-stack-permutation-stack-permutation'"><span class="taxon">Definition 1. </span>栈置换</span></li><li class=""><a class="bullet" href="/data-structure/stack-permutation/hille-encode" title="Hille 编码 [data-structure/stack-permutation/hille-encode]">■</a><span class="link local" onclick="window.location.href='#data-structure-stack-permutation-hille-encode'"><span class="taxon">Definition 2. </span>Hille 编码</span></li><li class=""><a class="bullet" href="/data-structure/stack-permutation/three-nodes" title="三节点二叉树 [data-structure/stack-permutation/three-nodes]">■</a><span class="link local" onclick="window.location.href='#data-structure-stack-permutation-three-nodes'"><span class="taxon">Example 3. </span>$n=3$</span></li><li class=""><a class="bullet" href="/data-structure/stack-permutation/equivalence" title="栈编码与 Hille 编码的等价性 [data-structure/stack-permutation/equivalence]">■</a><span class="link local" onclick="window.location.href='#data-structure-stack-permutation-equivalence'"><span class="taxon">Proposition 4. </span>栈编码与 Hille 编码的等价性</span></li><li class=""><a class="bullet" href="/data-structure/stack-permutation/intersection" title="相交数 [data-structure/stack-permutation/intersection]">■</a><span class="link local" onclick="window.location.href='#data-structure-stack-permutation-intersection'"><span class="taxon">Proposition 5. </span>相交数</span></li><li class=""><a class="bullet" href="/data-structure/stack-permutation/ratio" title="相交率 [data-structure/stack-permutation/ratio]">■</a><span class="link local" onclick="window.location.href='#data-structure-stack-permutation-ratio'"><span class="taxon">Corollary 6. </span>相交率</span></li><li class=""><a class="bullet" href="/data-structure/stack-permutation/bounds" title="有效长度的上下界 [data-structure/stack-permutation/bounds]">■</a><span class="link local" onclick="window.location.href='#data-structure-stack-permutation-bounds'"><span class="taxon">Exegesis 7. </span>有效长度的上下界</span></li></ul></li><li class="item-summary"><a class="bullet" href="/data-structure/synthetic-differential/index" title="综合微分法 [data-structure/synthetic-differential/index]">■</a><span class="link local" onclick="window.location.href='#data-structure-synthetic-differential-index'"><span class="taxon"></span>综合微分法</span><ul class="block"><li class=""><a class="bullet" href="/data-structure/synthetic-differential/numerical" title="数值微分的误差 [data-structure/synthetic-differential/numerical]">■</a><span class="link local" onclick="window.location.href='#data-structure-synthetic-differential-numerical'"><span class="taxon">Exegesis 1. </span>数值微分的误差</span></li><li class=""><a class="bullet" href="/data-structure/synthetic-differential/complex-step" title="Complex step 微分法 [data-structure/synthetic-differential/complex-step]">■</a><span class="link local" onclick="window.location.href='#data-structure-synthetic-differential-complex-step'"><span class="taxon">Exegesis 2. </span>复步微分法</span></li><li class=""><a class="bullet" href="/data-structure/synthetic-differential/moler-correction" title="复步微分法 对数值微分误差的修正 [data-structure/synthetic-differential/moler-correction]">■</a><span class="link local" onclick="window.location.href='#data-structure-synthetic-differential-moler-correction'"><span class="taxon">Exegesis 3. </span>误差修正</span></li><li class=""><a class="bullet" href="/data-structure/synthetic-differential/dual-number" title="对偶数 [data-structure/synthetic-differential/dual-number]">■</a><span class="link local" onclick="window.location.href='#data-structure-synthetic-differential-dual-number'"><span class="taxon">Definition 4. </span>对偶数</span><ul class="block"><li class=""><a class="bullet" href="/data-structure/synthetic-differential/kock-lawvere" title="Kock–Lawvere [data-structure/synthetic-differential/kock-lawvere]">■</a><span class="link local" onclick="window.location.href='#data-structure-synthetic-differential-kock-lawvere'"><span class="taxon">Axiom 4.1. </span>Kock–Lawvere</span></li><li class=""><a class="bullet" href="/data-structure/synthetic-differential/matrix-represent" title="矩阵表示 [data-structure/synthetic-differential/matrix-represent]">■</a><span class="link local" onclick="window.location.href='#data-structure-synthetic-differential-matrix-represent'"><span class="taxon">Exegesis 4.2. </span>矩阵表示</span></li><li class=""><a class="bullet" href="/data-structure/synthetic-differential/derived-differential" title="矩阵表示导出微分运算 [data-structure/synthetic-differential/derived-differential]">■</a><span class="link local" onclick="window.location.href='#data-structure-synthetic-differential-derived-differential'"><span class="taxon">Example 4.3. </span>导出微分运算</span></li><li class=""><a class="bullet" href="/data-structure/synthetic-differential/chain-rule" title="链式法则 [data-structure/synthetic-differential/chain-rule]">■</a><span class="link local" onclick="window.location.href='#data-structure-synthetic-differential-chain-rule'"><span class="taxon">Exegesis 4.4. </span>链式法则</span></li></ul></li></ul></li></ul></details></div></nav>

<article><section class="block" data-taxon=""><details open><summary id="data-structure-index"><header><h1><span class="taxon"></span>数据与可计算结构 <a class="slug" href="/data-structure/index">[data-structure]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p><section class="block" data-taxon=""><details ><summary id="data-structure-seven-trees-in-one"><header><h1><span class="taxon"></span>七树合一定理 <a class="slug" href="/data-structure/seven-trees-in-one">[seven-trees-in-one]</a></h1><div class="metadata"><ul><li class="meta-item">September 24, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link external"><a href="https://ncatlab.org/nlab/show/seven+trees+in+one" title="$n$Lab [https://ncatlab.org/nlab/show/seven+trees+in+one]">$n$Lab</a></span></li></ul></div></header></summary>
<p><section class="block hide-metadata" data-taxon="Definition"><details open><summary id="data-structure-binary-tree"><header><h1><span class="taxon">Definition 1. </span>二叉树类型 <a class="slug" href="/data-structure/binary-tree">[binary-tree]</a></h1><div class="metadata"><ul><li class="meta-item">September 24, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>二叉树意味树的每个结点最多两个子树. 其类型由两个构造器归纳给出</p>
<p><details><summary><figure><img src="/data-structure/tree-def.svg" class="color-invert"/></figure></summary><pre>inductive Tree α
  | leaf : Tree α
  | node : α → Tree α → Tree α → Tree α</pre></details></p>
<p>叶结点构造器 <code>leaf</code> 用于构造出一棵空树, 空树作为某个结点的所有子结点时, 该结点正是叶结点. 相应的, 二叉树的值存储在非叶结点中. 每个 (非空, 无标记) 二叉树类型的值要么是一个单结点 $\{\text{pt}\} = 1$, 要么等价于二叉树的有序配对 $B \times B = B^2$. 即 $B \xrightarrow{\sim} \{\text{pt}\} \sqcup B^2$.</p>
<p><figure><img src="/data-structure/binary-tree.svg" class="color-invert"/></figure></p>
<p>换言之, 二叉树可定义为某种满足 $B=1+B^2$ 的 (代数) 结构. 回顾 $6$ 次分圆多项式 $$ \Phi_6(x) \spaces= x^2-x+1 $$ 其复根 $\zeta_6$, $\zeta^{-1}_6$ 是所谓的 $6$ 次本原单位根.</p>
</details></section>
<section class="block hide-metadata" data-taxon="Theorem"><details open><summary id="data-structure-blass-lawvere"><header><h1><span class="taxon">Theorem 2. </span>Blass–Lawvere 定理 <a class="slug" href="/data-structure/blass-lawvere">[blass-lawvere]</a></h1><div class="metadata"><ul><li class="meta-item">September 24, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\N{\mathbf{N}}$
$\gdef\Z{\mathbf{Z}}$</p>
<p>记 $B$ 是二叉树类型, 则存在一个 <span class="link local"><a href="/bib/blass1995seven" title="Seven trees in one [bib/blass1995seven]">“极精确的双射”</a></span> $B \xrightarrow{\sim} B^7$.</p>
<p>显然并非所有 $\zeta_6$ 满足的等式都能提升到 $B$ 之间的同构, 如 $B^6 \ncong 1$. 自然的问题是, 哪些等式能提升到同构? 这个问题由下面的 <span class="link local"><a href="/data-structure/fiore-leinster" title="Fiore–Leinster [data-structure/fiore-leinster]">Fiore–Leinster 定理</a></span> 回答.</p>
<p><section class="block hide-metadata" data-taxon="Theorem"><details open><summary id="data-structure-fiore-leinster"><header><h1><span class="taxon">Theorem. </span>Fiore–Leinster <a class="slug" href="/data-structure/fiore-leinster">[fiore-leinster]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item">September 24, 2024</li><li class="meta-item"><span class="link external"><a href="https://arxiv.org/pdf/math/9405205" title="https://arxiv.org/pdf/math/9405205">https://arxiv.org/pdf/math/9405205</a></span></li></ul></div></header></summary>
<p>$\gdef\N{\mathbf{N}}$
$\gdef\Z{\mathbf{Z}}$</p>
<p>设 $f,g_1,g_2 \in \N[x]$, 其中 $f$ 有非零常数项且 $\deg f \ge 2$. 若 $f(x) - x$ 整除非常值的 $g_1-g_2$ (在 $\Z[x]$ 中), 则在 $\N[x]/(x=f(x))$ 中, $g_1(x)=g_2(x)$.</p>
</details></section></p>
<p>特别的, 取 $f(x)=1+x^2$, <span class="link local"><a href="/data-structure/fiore-leinster" title="Fiore–Leinster [data-structure/fiore-leinster]">Fiore–Leinster 定理</a></span> 表明, 若在 $\N[x]/(x=1+x^2)$ 中成立  $f(x) = g(x)$, 则存在 “极精确的双射” $f(B) \cong g(B)$. 在 $\N[x]/(x=1+x^2)$ 中可以演绎得到 $x=x^7$ 但无法给出 $1=x^6$. 对于前者 $x^7-x = (x^2-x+1)(x^5+x^4-x^2-x) = 0$. 再看 $x^4 + x^2 + 1 = (x^2 + x + 1)(x^2 - x + 1)$, 这给出 $B^4+B^2+1 \ncong 0$, $B^4+B^2+B+1=B$.</p>
<p>这套想法亦可应用于其他树结构, 如有根平面树, 其每个结点有 $0$, $1$ 或 $2$ 个子结点, 即 $T \cong 1+T+T^2$. 由 <span class="link local"><a href="/data-structure/fiore-leinster" title="Fiore–Leinster [data-structure/fiore-leinster]">Fiore–Leinster 定理</a></span>, 存在 “极精确的双射” $T \cong T^5$.</p>
</details></section></p>
</details></section>
<section class="block" data-taxon=""><details ><summary id="data-structure-stack-permutation-isomorphism"><header><h1><span class="taxon"></span>栈置换–二叉树同构 <a class="slug" href="/data-structure/stack-permutation/isomorphism">[isomorphism]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024 — November 08, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link external"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" title="CC BY-NC-SA 4.0 [https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en]">CC BY-NC-SA 4.0</a></span></li><li class="meta-item"><span class="link external"><a href="https://kokic.github.io/assets/publications/A%20Correspondence%20between%20Stack%20Permutations%20and%20Binary%20Trees%20via%20Hille%20Encoding.pdf" title="PDF [https://kokic.github.io/assets/publications/A%20Correspondence%20between%20Stack%20Permutations%20and%20Binary%20Trees%20via%20Hille%20Encoding.pdf]">PDF</a></span></li></ul></div></header></summary>
<p></p>
<p><section class="block hide-metadata" data-taxon="Definition"><details open><summary id="data-structure-stack-permutation-stack-permutation"><header><h1><span class="taxon">Definition 1. </span>栈置换 <a class="slug" href="/data-structure/stack-permutation/stack-permutation">[stack-permutation]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>栈置换 (<em>stack permutation</em>) 也称作栈混洗 (<em>stack shuffle</em>). 给定一个非空栈 $A$ 和空栈 $B$ 与 $S$, 每次只允许 $(i)$ 弹出 $A$ 并压入 $S$. $(ii)$ 弹出 $S$ 并压入 $B$. 可以想见, 最终 $A$ 的元素一定会全部进入 $B$. 这样的 $B$ 就称为 $A$ 的一个栈置换.</p>
</details></section></p>
<p>不难发现, $A$ 的所有栈置换其实就是 $A$ 的所有出栈可能. 熟知 $n$ 元素栈共有 $\frac1{n+1}{2n \choose n}$ 种出栈情况. 另一方面, $n$ 个节点能构成 $\frac1{n+1}{2n \choose n}$ 种二叉树, 两者的计算都可以在 Catalan 数的相关条目中找到. 这表明两者作为集合同构, 一个可以考虑的问题是, 如何实现该同构? 即, 具体地写出这个双射. 这方面的 <span class="link local"><a href="/bib/hille1982stack" title="Stack permutations and an order relation for binary trees [bib/hille1982stack]">开创性工作</a></span> 来自 R. F. Hille.</p>
<p><section class="block hide-metadata" data-taxon="Definition"><details open><summary id="data-structure-stack-permutation-hille-encode"><header><h1><span class="taxon">Definition 2. </span>Hille 编码 <a class="slug" href="/data-structure/stack-permutation/hille-encode">[hille-encode]</a></h1><div class="metadata"><ul><li class="meta-item">1982</li><li class="meta-item">Reinhold Friedrich Hille</li><li class="meta-item"><span class="link local"><a href="/bib/hille1982stack" title="Stack permutations and an order relation for binary trees [bib/hille1982stack]">Stack permutations and an order relation for binary trees</a></span></li></ul></div></header></summary>
<p>以下三条规则给出 Hille 编码到二叉树的转换过程. 同时不难验证, 任给一个二叉树, 可以通过这三条规则得到其 Hille 编码.</p>
<ul>
<li><code>1</code> 表示添加当前树节点的左子树. 例如 <code>111</code> 表示的树为 <code>(⋅ (⋅ (⋅)))</code>.</li>
<li><code>01</code> 表示添加当前树节点的右子树. 例如 <code>10101</code> 表示的树为 <code>(⋅ _ (⋅ _ (⋅)))</code>.</li>
<li>而对于 <code>01</code> 前的 $k$ 个 <code>0</code>, 这些 <code>0</code> 用于表示将当前树节点回溯到前 $k$ 层. 例如 <code>11001</code> 表示的树为 <code>(⋅ (⋅) (⋅))</code>.</li>
</ul>
<p>注意到每个树节点的双亲 (<em>parent</em>) 节点是唯一的, 因此回溯操作良定, 一次回溯就是将当前节点改为其双亲.</p>
</details></section></p>
<p>相应的, 可以据此定义 Hille 编码的解析规则, 用于将这样一段有效的二进制序列转换为构造一颗二叉树的若干操作. 我们使用一种类 BNF 文法来定义这个解析器, 仅供读者理解.</p>
<p><figure><img src="/data-structure/stack-permutation/hille-parser.svg" class="color-invert"/></figure></p>
<p>由于我们的讨论不涉及具体元素, 不失一般性, 可以固定栈置换的入栈顺序为 $123\cdots n$. 同时这些数字也是二叉树节点的标签. 影响出栈序列的只有压入和弹出两个操作, 而构建二叉树允许的操作粗看起来要多一些. 因此首先需要通过一些技巧将二叉树构建操作的表示简化. 我们将栈的压入和弹出分别编码为 <code>1</code> 和 <code>0</code>, 并将栈置换对应的二进制序列称为栈编码. 对应的, 以 <span class="link local"><a href="/data-structure/stack-permutation/hille-encode" title="Hille 编码 [data-structure/stack-permutation/hille-encode]">Hille 编码</a></span> 刻画二叉树的构建.</p>
<p><section class="block hide-metadata" data-taxon="Example"><details open><summary id="data-structure-stack-permutation-three-nodes"><header><h1><span class="taxon">Example 3. </span>$n=3$ <a class="slug" href="/data-structure/stack-permutation/three-nodes">[three-nodes]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>以下写出三节点二叉树的所有 $5$ 种情况, 以展示这些树的二进制序列如何对应到栈置换.
此处二进制序列按栈弹空为标准, 补充了末尾的零.</p>
<p><figure><img src="/data-structure/stack-permutation/three-nodes.svg" class="color-invert"/></figure></p>
</details></section></p>
<p>这个过程的反向实际上并不平凡, 如果只考虑 $n=3$ 也就是上图的情况, 敏锐的读者可以发现, 这些栈置换其实就是二叉树按节点添加顺序 <sup class="footnote-reference" id="data-structure_stack-permutation_isomorphism_hille-order-back"><a href="#data-structure_stack-permutation_isomorphism_hille-order">1</a></sup> 编号后的中序遍历序列 <sup class="footnote-reference" id="data-structure_stack-permutation_isomorphism_inorder-sequence-back"><a href="#data-structure_stack-permutation_isomorphism_inorder-sequence">2</a></sup>. 我们接下来将解释其中的不平凡之处, 以及这一巧合发生的 <span class="link local"><a href="/data-structure/stack-permutation/equivalence" title="栈编码与 Hille 编码的等价性 [data-structure/stack-permutation/equivalence]">具体条件</a></span>. 首先是对原始文献的一个观察, <span class="link local"><a href="/bib/hille1982stack" title="Stack permutations and an order relation for binary trees [bib/hille1982stack]">Hille 原始文献</a></span> 当中提出的算法实际上存在错误, 将之改写成 Lean4 语言, 即</p>
<p><details><summary><figure><img src="/data-structure/stack-permutation/encode.svg" class="color-invert"/></figure></summary><pre>def encode : Tree → String
  | .node l r => "1" ++ encode l ++ encode r
  | _ => "0"</pre></details></p>
<p>只要考虑下面这个例子即可发现, 将一棵二叉树转化为它的 Hille 编码并非是简单的中序遍历.</p>
<p><figure><img src="/data-structure/stack-permutation/counterexample.svg" class="color-invert"/></figure></p>
<p>可以验证, 从 <code>110100100</code> 这个编码出发, 无法直接恢复原本的 
<span class="inline-typst"><svg class="typst-doc" viewBox="0 0 18.044079999999997 22.672179999999997" width="18.044079999999997pt" height="22.672179999999997pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:h5="http://www.w3.org/1999/xhtml">
    <path class="typst-shape" fill="#00000000" fill-rule="nonzero" d="M 0 0v 22.67218 h 18.04408 v -22.67218 Z "/>
    <g>
        <g class="typst-group">
            <g>
                <g class="typst-group" transform="matrix(0.4 0 0 0.4 1 1)">
                    <g>
                        <g class="typst-group">
                            <g>
                                <g class="typst-group">
                                    <g>
                                        <path class="typst-shape" fill="none" stroke="#000000" stroke-width="0.7404959999999999" stroke-linecap="round" stroke-linejoin="miter" stroke-miterlimit="4" transform="matrix(1 0 0 1 10.533055765200158 10.533055765199913)" d="M 0 0m 5.1597886 0 l -5.1597886 5.1597886 "/>
                                        <path class="typst-shape" fill="none" stroke="#000000" stroke-width="0.7404959999999999" stroke-linecap="round" stroke-linejoin="miter" stroke-miterlimit="4" transform="matrix(1 0 0 1 10.533055648846556 24.417355900815053)" d="M 0 0l 5.1597886 5.1597886 "/>
                                        <path class="typst-shape" fill="none" stroke="#000000" stroke-width="0.7404959999999999" stroke-linecap="round" stroke-linejoin="miter" stroke-miterlimit="4" transform="matrix(1 0 0 1 24.41735564884644 10.533055900814961)" d="M 0 0l 5.1597886 5.1597886 "/>
                                        <path class="typst-shape" fill="none" stroke="#000000" stroke-width="0.8" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" transform="matrix(1 0 0 1 13.884300000000003 0)" d="M 0 0m 6.1708 0 c -3.404949 0 -6.1708 2.7658513 -6.1708 6.1708 c 0 3.4049482 2.7658513 6.1708 6.1708 6.1708 c 3.4049482 0 6.1708 -2.765852 6.1708 -6.1708 c 0 -3.404949 -2.765852 -6.1708 -6.1708 -6.1708 Z "/>
                                        <path class="typst-shape" fill="none" stroke="#000000" stroke-width="0.8" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" transform="matrix(1 0 0 1 0 13.88429999999999)" d="M 0 0m 6.1708 0 c -3.404949 0 -6.1708 2.7658513 -6.1708 6.1708 c 0 3.4049482 2.7658513 6.1708 6.1708 6.1708 c 3.4049482 0 6.1708 -2.765852 6.1708 -6.1708 c 0 -3.404949 -2.765852 -6.1708 -6.1708 -6.1708 Z "/>
                                        <path class="typst-shape" fill="none" stroke="#000000" stroke-width="0.8" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" transform="matrix(1 0 0 1 13.884300000000003 27.768599999999996)" d="M 0 0m 6.1708 0 c -3.404949 0 -6.1708 2.7658513 -6.1708 6.1708 c 0 3.4049482 2.7658513 6.1708 6.1708 6.1708 c 3.4049482 0 6.1708 -2.765852 6.1708 -6.1708 c 0 -3.404949 -2.765852 -6.1708 -6.1708 -6.1708 Z "/>
                                        <path class="typst-shape" fill="none" stroke="#000000" stroke-width="0.8" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" transform="matrix(1 0 0 1 27.7686 13.88429999999999)" d="M 0 0m 6.1708 0 c -3.404949 0 -6.1708 2.7658513 -6.1708 6.1708 c 0 3.4049482 2.7658513 6.1708 6.1708 6.1708 c 3.4049482 0 6.1708 -2.765852 6.1708 -6.1708 c 0 -3.404949 -2.765852 -6.1708 -6.1708 -6.1708 Z "/>
                                    </g>
                                </g>
                            </g>
                        </g>
                    </g>
                </g>
            </g>
        </g>
    </g>
</svg>
</span>
, 其正确的 Hille 编码应该为 <code>1101000100</code>. 但是另一方面, 如果将序列 <code>110100100</code> 解释为栈的压入弹出操作, 即栈编码, 则可以得到正确的栈置换 <code>2314</code>. 这就意味着, 当二叉树的节点个数 $n &gt; 3$ 时, 存在二叉树使得其栈编码与 Hille 编码不同. 回忆二叉树和栈置换之间的双射关系, 这表明必然存在一套手续允许我们在两者之间互相转换, 下面我们将构造性地给出这个结果. 见 <span class="link local"><a href="/data-structure/stack-permutation/equivalence" title="栈编码与 Hille 编码的等价性 [data-structure/stack-permutation/equivalence]">栈编码与 Hille 编码的等价性</a></span>. 随后通过 <span class="link local"><a href="/data-structure/stack-permutation/ratio" title="相交率 [data-structure/stack-permutation/ratio]">相交率</a></span> 解释, 为何中序遍历在 $n$ 不大情况下能够频繁得到正确的 Hille 编码.</p>
<p><section class="block hide-metadata" data-taxon="Proposition"><details open><summary id="data-structure-stack-permutation-equivalence"><header><h1><span class="taxon">Proposition 4. </span>栈编码与 Hille 编码的等价性 <a class="slug" href="/data-structure/stack-permutation/equivalence">[equivalence]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>首先容易验证的是, 中序遍历总是能够给出二叉树 $b \in B$ 到栈置换 $s \in S$ 的映射, 而对于每一个栈置换 $s \in S$, 都能够写出唯一的二进制序列, 即栈编码 $c \in C$. 不考虑末尾连续的 <code>0</code>, 当栈编码 $c$ 与二叉树 $b$ 的 Hille 编码 $h \in H$ 相同时, 对 $B$ 直接进行中序遍历便能得出正确的 Hille 编码.</p>
<p>$$
\begin{CD}
B @&gt;&gt;&gt; S \\
  @VVV @VVV \\
H @&gt;&gt;&gt; C
\end{CD}
$$</p>
<p><section class="block hide-metadata" data-taxon="Proof"><details open><summary id="data-structure-stack-permutation-equivalence-pf"><header><h1><span class="taxon">Proof. </span> <a class="slug" href="/data-structure/stack-permutation/equivalence-pf">[equivalence-pf]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>记 $B \to H$ 为 $f$, 根据 <span class="link local"><a href="/data-structure/stack-permutation/hille-encode" title="Hille 编码 [data-structure/stack-permutation/hille-encode]">Hille 编码</a></span> 的定义, $f$ 是一个双射. 根据二叉树的性质, $g: B \to S$ 是中序遍历, 前文已经固定栈置换的入栈顺序为 $123\cdots n$, 这样一来就固定了 $B$ 的层序遍历, 因此 $g$ 也是双射. 现在来看 $h: S \to C$, 这显然也是一个双射. 最后, 我们能够从 $h \in H$ 当中恢复出 $c \in C$ 的信息, 只要将 $h$ 序列视为栈编码, 并且忽略空栈的弹出, 这就意味着 $H \to C$ 是满射, 随后利用 $C \to S \to B \to H$, 这样就得到了 $H \cong C$.</p>
</details></section></p>
<p>现在, Hille 原文所使用的 <code>encode</code> 算法就是 $h \circ g: B \to C$, 而预期的正确实现则是 $f$, 因此两者在结果上相差一个同构.</p>
</details></section></p>
<p><section class="block hide-metadata" data-taxon="Proposition"><details open><summary id="data-structure-stack-permutation-intersection"><header><h1><span class="taxon">Proposition 5. </span>相交数 <a class="slug" href="/data-structure/stack-permutation/intersection">[intersection]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\eqdef{\overset{\scriptscriptstyle\text{def}}{=}}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>所有 $n$ 节点二叉树的 Hille 编码构成的集合记为 $H_n$, 所有 $n$ 节点二叉树的栈编码构成的集合记为 $C_n$. 对于 $H_n \cap C_n$ 的大小 $a_n \eqdef |H_n \cap C_n|$, 我们有如下刻画.</p>
<p>$$
a_n \spaces= \sum_{k = 0}^{n-1} \sum_{j = 0}^{n-k} \frac{1}{j+1}\binom{n-k-j}j \binom kj \binom{k+j+2}j
$$</p>
<p>记 $N = n+1$. 等式的证明可以通过分析一个半长为 $N$ 且不包含 <code>UUDD</code> 子序列的 Dyck 路径得到. 同时这也是从 $(0,0)$ 到 $(N,N)$ 不越过对角线且允许步长 $(1,k), (k,1), k \geqslant 1$ 的格路径的个数. 或者更简单地说, 是长度为 $N$ 的斜 Motzkin 路径的个数.</p>
</details></section></p>
<p><section class="block hide-metadata" data-taxon="Corollary"><details open><summary id="data-structure-stack-permutation-ratio"><header><h1><span class="taxon">Corollary 6. </span>相交率 <a class="slug" href="/data-structure/stack-permutation/ratio">[ratio]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>记 Catalan 数为 $c_n$, 也即 $H_n$ 或 $C_n$ 的个数. 自然要问 $|H \cap C_n|$ 在全体 $n$ 节点二叉树个数中所占的比例与 $n$ 的关系. 根据 <span class="link local"><a href="/data-structure/stack-permutation/intersection" title="相交数 [data-structure/stack-permutation/intersection]">相交数</a></span> 与 Catalan 数的渐进估计 $a_{n} \sim \frac{\sqrt{2 + r}}{2\sqrt{\pi}n^{3/2}r^{n}}$, $c_n \sim \frac{4^n}{\sqrt\pi n^{3/2}}$ 可以知道 $\lim\limits_{n\to\infty} \frac{a_n}{c_n} = 0$. 并且事实上只要二叉树的节点个数 $n$ 大于 $8$, $H_n$ 与 $C_n$ 相同的部分就会少于整体的一半.</p>
</details></section></p>
<p><section class="block hide-metadata" data-taxon="Exegesis"><details open><summary id="data-structure-stack-permutation-bounds"><header><h1><span class="taxon">Exegesis 7. </span>有效长度的上下界 <a class="slug" href="/data-structure/stack-permutation/bounds">[bounds]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>一个可供探究的问题是, 给定 $n$ 节点二叉树, 询问其 Hille 编码 $H_n$ 有效长度 $\ell(H_n)$ 的范围. 这里的有效不外乎是指去除末尾连续的 <code>0</code>. 我们将对此问题给出确切的回答.</p>
<p>任意 $n$ 节点二叉树的 Hille 编码的有效长度满足下面的不等式</p>
<p>$$n \spaces\leqslant \ell_{n} \spaces\leqslant \max(0,2n - 1,3n - 4)$$</p>
<p>下界 $n$ 的验证是容易的, 构造一棵 $n$ 节点二叉树最少也需要 $n$ 个 <code>1</code>.
由于 <span class="link local"><a href="/data-structure/stack-permutation/three-nodes" title="三节点二叉树 [data-structure/stack-permutation/three-nodes]">此处</a></span> 的讨论, 我们只需要验证 $n \geqslant 3$ 时 Hille 编码的有效长度至多是 $3n - 4$.</p>
<p><section class="block hide-metadata" data-taxon="Proof"><details open><summary id="data-structure-stack-permutation-bounds-pf"><header><h1><span class="taxon">Proof. </span> <a class="slug" href="/data-structure/stack-permutation/bounds-pf">[bounds-pf]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>注意到为使有效长度最大, 相应的二叉树中的右节点个数和回溯次数要尽可能多.
同时满足这两个要求意味着 $(i)$ 除根节点外至少有一个左结点 <sup class="footnote-reference" id="data-structure_stack-permutation_bounds-pf_1-back"><a href="#data-structure_stack-permutation_bounds-pf_1">1</a></sup>. $(ii)$
该二叉树必有一个位于根节点右侧的节点 <sup class="footnote-reference" id="data-structure_stack-permutation_bounds-pf_2-back"><a href="#data-structure_stack-permutation_bounds-pf_2">2</a></sup>. 如下图所示</p>
<p><figure><img src="/data-structure/stack-permutation/tree-three.svg" class="color-invert"/></figure></p>
<p>由此出发, 我们将剩余的所有 $n-3$ 个节点全部添加到树中唯一的左节点的右侧. 即</p>
<p><figure><img src="/data-structure/stack-permutation/tree-max.svg" class="color-invert"/></figure></p>
<p>下面我们只需算出 $\ell(M)$, 便可得到 $\ell_n$ 的最大值. 不妨直接写出 $h(M)$</p>
<p><figure><img src="/data-structure/stack-permutation/hm-evaluate.svg" class="color-invert"/></figure></p>
<p>立刻看出 $\ell(M) = 2 + 2(n-3) + (n-2) + 2 = 3n-4$.</p>
<div class="footnote-definition" id="data-structure_stack-permutation_bounds-pf_1">
  <sup class="footnote-definition-label"><a href="#data-structure_stack-permutation_bounds-pf_1-back">1</a></sup>
<p>如若不然, 这颗二叉树只会形如 <code>1010101</code>$\cdots$, 其长度为 $2n - 1$.</p>
</div>
<div class="footnote-definition" id="data-structure_stack-permutation_bounds-pf_2">
  <sup class="footnote-definition-label"><a href="#data-structure_stack-permutation_bounds-pf_2-back">2</a></sup>
<p>否则回溯贡献的长度便不是最大值 $n-2$.</p>
</div>
</details></section></p>
<p>反过来, 从树 $M$ 出发, 也可以验证任何使得节点总数不变的操作都不会增加其 Hille 编码的有效长度. 更进一步, 我们可以断言任何使得节点总数不变的操作都将严格减小其 Hille 编码的有效长度. 换言之, 使得 $\ell(B) = 3n-4$ 的二叉树 $B$ 的结构是唯一的, 即 $M$.</p>
</details></section></p>
<div class="footnote-definition" id="data-structure_stack-permutation_isomorphism_hille-order">
  <sup class="footnote-definition-label"><a href="#data-structure_stack-permutation_isomorphism_hille-order-back">1</a></sup>
<p>即按照 Hille 编码逐步添加节点的顺序.</p>
</div>
<div class="footnote-definition" id="data-structure_stack-permutation_isomorphism_inorder-sequence">
  <sup class="footnote-definition-label"><a href="#data-structure_stack-permutation_isomorphism_inorder-sequence-back">2</a></sup>
<p>如二叉树 <code>1101000100</code> 按添加顺序对节点编号, 然后做中序遍历得到的是 <code>2314</code>.</p>
</div>
</details></section>
<section class="block" data-taxon=""><details ><summary id="data-structure-synthetic-differential-index"><header><h1><span class="taxon"></span>综合微分法 <a class="slug" href="/data-structure/synthetic-differential/index">[synthetic-differential]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024 — May 14, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p><section class="block hide-metadata" data-taxon="Exegesis"><details open><summary id="data-structure-synthetic-differential-numerical"><header><h1><span class="taxon">Exegesis 1. </span>数值微分的误差 <a class="slug" href="/data-structure/synthetic-differential/numerical">[numerical]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\quads#1{\quad #1 \quad}$
$\gdef\eqq{\quads=}$</p>
<p>我们首先观察朴素的数值微分的计算过程. 待微分函数为 $(x+3)^2$, 此处不妨取 $x=-2$, $h=10^{-5}$, 这一位置的导数 $A$ 近似为</p>
<p>$$ 
A \quads\approx \frac{f(x+h)-f(x)}h \eqq \frac{(1 + 10^{-5})^2 - 1^2}{10^{-5}} \eqq 2.00001 
$$</p>
<p>并且如果试图得到与预期的 $A=2$ 更接近的结果, 则须将无穷小近似 $h$ 选取为更靠近 $0$ 的数值, 这对于浮点精度有限的计算机来说极为不利.</p>
<p>而常规符号微分程序视表达式为树结构, 通过遍历树并对符合模式的节点应用求导规则 $(uv)' = u'v+uv'$. 即</p>
<p>$$
\begin{aligned}
(x+3)^2 
&amp; \spaces\to (x+3)'(x+3) + (x+3)(x+3)' \\
&amp; \spaces\to 1 \cdot (x+3) + (x+3) \cdot 1 \\
&amp; \spaces\to 2x+6 
\end{aligned}
$$</p>
<p>此时再应用 $x=-2$ 得到 $A=2$. 这个做法在结果上可行, 但处理复杂的表达式时, 复合求导的中间过程本身会产生大量新的结点, 使递归遍历的实际时间达到指数级 $\mathcal{O}(2^N)$.</p>
<p>有没有方法可以既避免递归又减少中间结点呢? 我们先看一个涉及复数域的观察.</p>
</details></section>
<section class="block hide-metadata" data-taxon="Exegesis"><details open><summary id="data-structure-synthetic-differential-complex-step"><header><h1><span class="taxon">Exegesis 2. </span>复步微分法 <a class="slug" href="/data-structure/synthetic-differential/complex-step">[complex-step]</a></h1><div class="metadata"><ul><li class="meta-item">May 13, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>Mathworks 的创始人 Cleve Moler 约 60 年 <sup class="footnote-reference" id="data-structure_synthetic-differential_complex-step_publish-time-back"><a href="#data-structure_synthetic-differential_complex-step_publish-time">1</a></sup> 前提出了借用虚数单位 $i$ 的数值微分, 相关文献称为 <span class="link external"><a href="https://blogs.mathworks.com/cleve/2013/10/14/complex-step-differentiation/" title="complex step 微分法 [https://blogs.mathworks.com/cleve/2013/10/14/complex-step-differentiation/]">complex step 微分法</a></span> <sup class="footnote-reference" id="data-structure_synthetic-differential_complex-step_complex-step-back"><a href="#data-structure_synthetic-differential_complex-step_complex-step">2</a></sup>. 考虑光滑函数 $f(x)$, 其在 $x=a$ 处可表为关于 $X$ 的 Taylor 级数 <sup class="footnote-reference" id="data-structure_synthetic-differential_complex-step_distinguish-back"><a href="#data-structure_synthetic-differential_complex-step_distinguish">3</a></sup> $f(a) + f'(a)(X-a) + \text{etc.}$, 注意</p>
<p>$$
f(a+i h) \spaces= f(a) + i h f'(a) - \frac{h^2}{2!}f''(a) - \frac{ih^3}{3!}f'''(a) + \cdots
$$</p>
<p>这个其实就是将 Taylor 级数的每一项完全展开, 在 <span class="link local"><a href="/data-structure/synthetic-differential/kock-lawvere" title="Kock–Lawvere [data-structure/synthetic-differential/kock-lawvere]">后续</a></span> 的计算中也会继续用到. 如此便有
$$ 
\frac{\partial f}{\partial x} \spaces= \frac{\Im f(x+ih)}{h} + \mathcal{O}(h^2) \quads\implies 
\frac{\partial f}{\partial x} \quads\approx \frac{\Im f(x+ih)}{h} 
$$</p>
<p>这个方法最初被设计用于处理数值微分问题, 但稍加思考就能发现, 该过程也适用于符号微分. 与前一个问题所改进的结果的精度不同, 用于 <span class="link local"><a href="/data-structure/synthetic-differential/dual-number" title="对偶数 [data-structure/synthetic-differential/dual-number]">符号微分</a></span> 时, 所取得的优势是更精简的中间表达式和非递归的计算过程.</p>
<div class="footnote-definition" id="data-structure_synthetic-differential_complex-step_publish-time">
  <sup class="footnote-definition-label"><a href="#data-structure_synthetic-differential_complex-step_publish-time-back">1</a></sup>
<p>即 1967 年. 不过这个名字要等到 1998 年, William Squire 和 George Trapp 才正式提出.</p>
</div>
<div class="footnote-definition" id="data-structure_synthetic-differential_complex-step_complex-step">
  <sup class="footnote-definition-label"><a href="#data-structure_synthetic-differential_complex-step_complex-step-back">2</a></sup>
<p>按方法的流程看, <span class="link local"><a href="/data-structure/synthetic-differential/complex-step" title="Complex step 微分法 [data-structure/synthetic-differential/complex-step]">complex step 微分</a></span> 可以翻译为 “复步微分”.</p>
</div>
<div class="footnote-definition" id="data-structure_synthetic-differential_complex-step_distinguish">
  <sup class="footnote-definition-label"><a href="#data-structure_synthetic-differential_complex-step_distinguish-back">3</a></sup>
<p>习惯上会混淆 $x$ 与 $X$.</p>
</div>
</details></section>
<section class="block hide-metadata" data-taxon="Exegesis"><details open><summary id="data-structure-synthetic-differential-moler-correction"><header><h1><span class="taxon">Exegesis 3. </span>误差修正 <a class="slug" href="/data-structure/synthetic-differential/moler-correction">[moler-correction]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\C{\mathbf{C}}$
$\gdef\quads#1{\quad #1 \quad}$
$\gdef\eqq{\quads=}$</p>
<p>选取同样的 $h=10^{-5}$, 以下计算表明 <span class="link local"><a href="/data-structure/synthetic-differential/complex-step" title="Complex step 微分法 [data-structure/synthetic-differential/complex-step]">Moler 的方法</a></span> 相比 <span class="link local"><a href="/data-structure/synthetic-differential/numerical" title="数值微分的误差 [data-structure/synthetic-differential/numerical]">此处</a></span> 基于有限差分的数值微分方法能够很好的避免精度损失.</p>
<p>$$
\frac{\Im(1 + 10^{-5}i)^{2}}{10^{-5}} \eqq \frac{\Im(\square + 2 \times 10^{- 5}i)}{10^{- 5}} \eqq 2
$$</p>
<p>实际上此处 $h$ 的选取, 只要其非零, 从而带有 $i$ 的项不消失, 就不会影响到最终的结果. 换言之, 这个方法从根本上来说, 是无关于 $h \in \R\smallsetminus\{0\}$ 和 $i$ 的, 只是在数值计算时借由复数算术和复函数值可以免去一些幂零结构的讨论. 一旦意识到这一点, 我们便可以将 <span class="link local"><a href="/data-structure/synthetic-differential/complex-step" title="Complex step 微分法 [data-structure/synthetic-differential/complex-step]">复步微分法</a></span> 的</p>
<p>$$ \frac{\partial f}{\partial x} \quads\approx \frac{\Im f(x+ih)}{h} $$</p>
<p>中的近似 “$\approx$” <span class="link local"><a href="/data-structure/synthetic-differential/matrix-represent" title="矩阵表示 [data-structure/synthetic-differential/matrix-represent]">修正</a></span> 为严格等于 “$=$”, 这只需要将 $\{z \in \C : z^2 = -1\}$ 替换为 $D = \{x \in R : x^2 = 0\}$, 问题就来到了如何构造这样的 $R$ 使得 $D$ 中有非零的元素, 这样的结构实际上会 <span class="link local"><a href="/data-structure/synthetic-differential/dual-number" title="对偶数 [data-structure/synthetic-differential/dual-number]">动摇</a></span> 经典逻辑中对于排中律的看法.</p>
</details></section>
<section class="block hide-metadata" data-taxon="Definition"><details open><summary id="data-structure-synthetic-differential-dual-number"><header><h1><span class="taxon">Definition 4. </span>对偶数 <a class="slug" href="/data-structure/synthetic-differential/dual-number">[dual-number]</a></h1><div class="metadata"><ul><li class="meta-item">May 14, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\R{\mathbf{R}}$
$\gdef\C{\mathbf{C}}$</p>
<p>一种通俗的讲法是, 认为对偶数 $R[x]/(x^2)$ 可以作为复数 $\R[x]/(x^2+1)$ 的类比. 如果有读者能轻率地暂时忽略 $R[x]/(x^2)$ 这种结构的存在性, 或者说接受了下面的 $d$ 的定义</p>
<p>$$ \exists ~ d \in R\smallsetminus\{0\}, ~ d^2 = 0 $$</p>
<p>不能接受也很正常, 因为这轻易就会导致某个经典逻辑中的 <span class="link local"><a href="/data-structure/synthetic-differential/schanuel-lavendhomme" title="Schanuel–Lavendhomme 构造 [data-structure/synthetic-differential/schanuel-lavendhomme]">矛盾</a></span>. 相比之下满足 $x^2 = -1$ 的 $x$ 对于大众而言要更容易接受的多, 甚至对于三次方程是 <span class="link local"><a href="/linear-algebra/casus-irreducibilis" title="Casus irreducibilis [linear-algebra/casus-irreducibilis]">必须品</a></span>. 为此我们需要下面的准备工作.</p>
<p><section class="block hide-metadata" data-taxon="Axiom"><details open><summary id="data-structure-synthetic-differential-kock-lawvere"><header><h1><span class="taxon">Axiom 4.1. </span>Kock–Lawvere <a class="slug" href="/data-structure/synthetic-differential/kock-lawvere">[kock-lawvere]</a></h1><div class="metadata"><ul><li class="meta-item">May 13, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\R{\mathbf{R}}$</p>
<p>首先需要强调的是, 这个公理所涉及到的结构的有效性全都依赖于 <span class="link local"><a href="/bib/jin2024topos" title="意象理论讲义 [bib/jin2024topos]">意象理论</a></span>, 而相关基础的严格性保证基本上在 1970 年之前就已经由 <span class="link local"><a href="/person/william-lawvere" title="Francis William Lawvere [person/william-lawvere]">William Lawvere</a></span> 完工. 记 $\mathcal{E}$ 是光滑空间之间的光滑映射构成的范畴, 同时假定 $\mathcal{E}$ 还是笛卡尔闭范畴, 也就是 $\mathcal{E}$ 中的箭头对笛卡尔积封闭.</p>
<p>我们可以从 $\mathcal{E}$ 中选出一条几何直线 $R$, 通过指定 $R$ 上两点 $0$ 和 $1$ 之间的距离作为单位长度来确定其他线段的长度. 发挥一些古希腊精神, 线段的移动可以给出 $R$ 上的加法, 尺规作图所构造的 <span class="link local"><a href="/bib/methods-of-algebra-1" title="代数学方法 卷一：基础架构 [bib/methods-of-algebra-1]">相似三角形</a></span> 能给出 $R$ 上的乘法 $\gamma = \alpha\beta$.</p>
<p><figure><img src="/data-structure/synthetic-differential/similar-triangle.svg" class="color-invert"/><figcaption>Methods in Algebra - Volume 1, p. 369</figcaption></figure></p>
<p>因此 $R$ 带有交换环结构, 并且允许经典数学中的对象实数环 $\R$ 成为 $R$ 的模型, 注意这里我们只能考虑 $\R$ 作为环的部分, 因为 $R$ 中存在着幂零元.</p>
<p>Kock–Lawvere 公理说的是, 对任意映射 $f: D \to R$, 存在唯一的 $a,b \in R$, 使得</p>
<p>$$ 
f(\epsilon) \spaces= a + b \epsilon, \quad \forall \epsilon \in D 
$$</p>
<p>将这里的 $a$ 换成 $f(0)$, 并完全使用量词叙述, 则是</p>
<p>$$ 
\forall ~ f \in R^D, ~ \exists! ~ b ~ \text{s.t.} ~ \forall ~ d \in D \quad (f(d) = f(0) + b d) 
$$</p>
<p>如果说这个公理的形式还不足以暗示它的目的, 那么下面这个推论就完全能做到了.</p>
<p><section class="block hide-metadata" data-taxon="Corollary"><details open><summary id="data-structure-synthetic-differential-smooths"><header><h1><span class="taxon">Corollary. </span>所有函数都光滑 <a class="slug" href="/data-structure/synthetic-differential/smooths">[smooths]</a></h1><div class="metadata"><ul><li class="meta-item">May 13, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>对任意函数 $f:R \rightarrow R$, 存在唯一的函数 $f':R \rightarrow R$ 满足</p>
<p>$$
f(x + \varepsilon) \spaces= f(x) + f'(x)\varepsilon,\quad \forall ~ x \in R, ~ \forall ~ \varepsilon \in D
$$</p>
<p>这个通常作为 <span class="link local"><a href="/data-structure/synthetic-differential/kock-lawvere" title="Kock–Lawvere [data-structure/synthetic-differential/kock-lawvere]">Kock–Lawvere 公理</a></span> 的推论出现, 不过从 $\mathcal{E}$ 的定义来看, 这才是整套框架真正的目的之一. 即, 为全体函数恢复牛顿时期 “幂零无穷小量” 计算上的直观, 而不导致矛盾.</p>
<p><figure><img src="/data-structure/synthetic-differential/maclaurin.svg" class="color-invert"/></figure></p>
</details></section></p>
<blockquote>
<p>Axiom is incompatible with the law of excluded middle.
Either the one or the other has to leave the scene.
In Part I of this book, the law of excluded middle has to leave,
being incompatible with the natural synthetic reasoning
on smooth geometry to be presented here.
In the terms which the logicians use, this means that
the logic employed is ‘constructive’ or ‘intuitionistic’.
We prefer to think of it just as ‘that reasoning
which can be carried out in all sufficiently good
cartesian closed categories’. <p style="text-align: right;">— Anders Kock, <span class="link local"><a href="/bib/kock2006synthetic" title="Synthetic differential geometry [bib/kock2006synthetic]">Synthetic Differential Geometry</a></span></p></p>
</blockquote>
</details></section></p>
<p>无论是单纯接受这个 <span class="link local"><a href="/data-structure/synthetic-differential/kock-lawvere" title="Kock–Lawvere [data-structure/synthetic-differential/kock-lawvere]">公理</a></span> 还是认可该公理存在的舞台 $\mathcal{E}$, 其实都会导致完全相同的结果, 那就是 $\mathcal{E}$ 当中一般函数的性质发生了变化, 让所有的函数都变得光滑. 与之相对的, 这样的好性质所要求的代价是, $\mathcal{E}$ 当中不能使用经典逻辑中的选择公理、排中律、反证法等命题.</p>
<p><section class="block hide-metadata" data-taxon="Exegesis"><details open><summary id="data-structure-synthetic-differential-matrix-represent"><header><h1><span class="taxon">Exegesis 4.2. </span>矩阵表示 <a class="slug" href="/data-structure/synthetic-differential/matrix-represent">[matrix-represent]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\str#1{{\footnotesize #1}}$
$\gdef\C{\mathbf{C}}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>这样一来, 我们所说的 <span class="link local"><a href="/data-structure/synthetic-differential/moler-correction" title="复步微分法 对数值微分误差的修正 [data-structure/synthetic-differential/moler-correction]">“将近似修正为严格等于”</a></span> 就可以精确表示为</p>
<p>$$ \frac{\partial f}{\partial x} \quads= f(x+\varepsilon) ~ \str{中} ~ \varepsilon ~ \str{项的系数} $$</p>
<p><span class="link local"><a href="/data-structure/synthetic-differential/complex-step" title="Complex step 微分法 [data-structure/synthetic-differential/complex-step]">复步微分法</a></span> 的来源是完全解析的, 但其得到的微分方法却能代数地刻画. 正如我们可以考虑复数的 $z = a+b\sqrt{-1} \in \C$ 矩阵表示</p>
<p>$$
A \spaces= \begin{pmatrix}
a &amp; -b \\
b &amp; ~~~a \\
\end{pmatrix}
,\quad
\det A \spaces= (a+b\sqrt{-1})(a-b\sqrt{-1}) 
$$</p>
<p>我们也可以构造 <span class="link local"><a href="/data-structure/synthetic-differential/dual-number" title="对偶数 [data-structure/synthetic-differential/dual-number]">对偶数</a></span> $a + b \varepsilon \in R$ 的矩阵表示, 并自动得到微分运算的加法和乘法规则, 这可以被简单地视为 Moler 方法的矩阵版本.</p>
<p>$$
A \spaces= \begin{pmatrix}
a &amp; a' \\
0 &amp; a \\
\end{pmatrix}
,\quad
\det A \spaces= (a+b\varepsilon)(a-b\varepsilon)
$$</p>
</details></section>
<section class="block hide-metadata" data-taxon="Example"><details open><summary id="data-structure-synthetic-differential-derived-differential"><header><h1><span class="taxon">Example 4.3. </span>导出微分运算 <a class="slug" href="/data-structure/synthetic-differential/derived-differential">[derived-differential]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\Mat{\operatorname{Mat}}$
$\gdef\d{\operatorname{d}}$
$\gdef\Z{\mathbf{Z}}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>设 $u, v \in R^R$, $n \in \Z$. 记 $A(u, u') = (\begin{smallmatrix} u &amp; u' \\ 0 &amp; u \end{smallmatrix})$. 从矩阵运算中立刻得到</p>
<ol>
<li>$A(u, u') + A(v, v') \spaces= A(u+v, u'+v')$</li>
<li>$A(u, u') - A(v, v') \spaces= A(u-v, u'-v')$</li>
<li>$A(u, u') \cdot A(v, v') \spaces= A(uv, u'v + uv')$</li>
<li>$A(u, u') \cdot (A(v, v'))^{-1} \spaces= A(uv^{-1}, (u'v - uv')v^{-2})$</li>
<li>$(A(u, u'))^n = A(u^n, nu^{n-1}u')$</li>
</ol>
<p>对于 $e^{A(u,u')}$, 注意 $A(u, u') = A(u, 0) + A(0, u')$, 这里 $(A(0, u))^2 = 0$. 同样可以计算得到 $e^{A(u,u')} = A(e^u, 0) \cdot A(1, u') = A(e^u, e^u u')$. 而对于 $\log A(u,u')$ 我们直接展开为 $\sum_{k \ge 1}\frac{(-1)^{k+1}}{k} \cdot (A-1)^k$ 即可验证:</p>
<p>$$
\begin{pmatrix} \sum_{k \ge 1}\frac{(-1)^{k+1}}{k} \cdot (u-1)^k &amp; \sum_{k \ge 0} (-1)^k (u-1)^k \cdot u'  \\ 0 &amp; \sum_{k \ge 1}\frac{(-1)^{k+1}}{k} \cdot (u-1)^k \end{pmatrix}
\spaces= 
\begin{pmatrix} \log u &amp; u'u^{-1} \\ 0 &amp; \log u \end{pmatrix}
$$</p>
</details></section>
<section class="block hide-metadata" data-taxon="Exegesis"><details open><summary id="data-structure-synthetic-differential-chain-rule"><header><h1><span class="taxon">Exegesis 4.4. </span>链式法则 <a class="slug" href="/data-structure/synthetic-differential/chain-rule">[chain-rule]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\Mat{\operatorname{Mat}}$
$\gdef\spaces#1{~ #1 ~}$
$\gdef\d{\operatorname{d}}$
$\gdef\eqdef{\overset{\scriptscriptstyle\text{def}}{=}}$</p>
<p>与 $\Mat_{2 \times 2}(R^R)$ 上的 <span class="link local"><a href="/data-structure/synthetic-differential/derived-differential" title="矩阵表示导出微分运算 [data-structure/synthetic-differential/derived-differential]">运算</a></span> 不同, 复合运算是只位于 $R^R$ 上的, 或者说 $\Mat_{2 \times 2}(R^R)$ 上并没有周知的复合运算. 为了自然地给出 $A: J^1(R, R) \to \Mat_{2 \times 2}(R^R)$ 上的复合, 这里 $J^1$ 是一阶 <span class="link external"><a href="https://ncatlab.org/nlab/show/jet+bundle" title="射流丛 [https://ncatlab.org/nlab/show/jet+bundle]">射流丛</a></span>. 记 $\square(x)$ 为 $\square_x $, $A(u)$ 为 $A(u,u')$, 考虑显式应用的 $A(u)$, 即</p>
<p>$$
A(u)_x \spaces\eqdef \begin{pmatrix} u_x &amp; u'_x \\ 0 &amp; u_x \end{pmatrix} \spaces\in \Mat_{2 \times 2}(R), \quad x \in R
$$</p>
<p>对于 $u: Y \to Z$, $v: X \to Y$. $A$ 上的复合 $A(u) \circ A(v)$ 可定义为 $A(u)_{v_x}$, $(v_x, v'_x) \in A(v)_x$. 我们来验证 $A(u) \circ A(v) = A(u \circ v)$.</p>
<p>$$
\begin{aligned}
A(u)_{v_x} 
&amp;\spaces= \Big(u \cdot \frac{\partial A}{\partial u} + \frac{\d u}{\d x} \cdot \frac{\partial A}{\partial u'}\Big)\Big|_{v_x} \\
&amp;\spaces= u(v_x) \cdot \frac{\partial A}{\partial u} + \frac{\d u(v_x)}{\d v_x} \frac{\d v_x}{\d x} \cdot \frac{\partial A}{\partial u'} \\
&amp;\spaces= A(u(v(x)), u'(v(x))v'(x)) \\
\end{aligned}
$$</p>
</details></section></p>
</details></section></p>
</details></section></p>
</details></section><footer></footer></article></div></body></html>