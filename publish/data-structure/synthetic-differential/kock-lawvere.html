<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>Kock–Lawvere</title><link rel="icon" href="/assets/favicon.ico" /><style>:root body {
  color-scheme: light dark;
  --content-gap: 15px;
  --radius: 5px;
  --article-max-width: 90ex;
  --toc-max-width: 90ex;

  --text-color: black;
  --toc-link-color: #555;
  --background-color: white;

  --background-color-pre: rgba(0, 100, 100, 0.04);
  --background-color-code: rgba(0, 100, 100, 0.04);

  --hover-color-block: rgba(0, 100, 255, 0.04);
  --hover-color-link: rgba(0, 100, 255, 0.1);
  --target-color: rgb(67, 92, 255);

  --link-color: black;
  --slug-color: gray;
  --logo-color: #666;
  --logo-hover-color: #aaa;
  --span-taxon-color: #444;
  --article-taxon-color: #888;
  --mark-color: rgb(255, 255, 151);
  --em-color: var(--text-color);
}

@media (prefers-color-scheme: dark) {
  :root body {
    --text-color: white;
    --toc-link-color: white;
    --background-color: #2f2f2f;

    --background-color-pre: rgba(100, 100, 100, 0.2);
    --background-color-code: rgba(150, 150, 150, 0.2);

    --hover-color-block: rgba(100, 162, 255, 0.06);
    --hover-color-link: rgba(100, 162, 255, 0.2);
    --target-color: rgb(255, 255, 151);

    --link-color: white;
    --slug-color: #aeaeae;
    --logo-color: #999;
    --logo-hover-color: #eee;
    --span-taxon-color: #bbb;
  }
}

body {
  color: var(--text-color);
  font-optical-sizing: auto;
  hyphens: auto;
  background-color: var(--background-color);
}

pre,
code {
  font-optical-sizing: auto;
}

p,
pre {
  line-height: 1.55;
}

pre {
  border-radius: var(--radius);
  background-color: var(--background-color-pre);
  padding: 0.5em;
  font-size: 11pt;
  margin-top: 0em;
  overflow-x: auto;
  white-space: pre-wrap;
  white-space: -moz-pre-wrap;
  white-space: -pre-wrap;
  white-space: -o-pre-wrap;
  word-wrap: break-word;
}

code {
  border-radius: var(--radius);
  background-color: var(--background-color-code);
  padding: 0.2em;
  font-size: 1em;
}

em {
  color: var(--em-color);
}

table {
  border-collapse: collapse;
  margin-bottom: 1em;
}

/* !forest */
th {
  font-weight: normal;
  text-align: left;
}

th,
td {
  padding: 0 15px;
  vertical-align: top;
}

/* !forest */
pre>code {
  border-radius: 0;
  background-color: transparent;
  padding: 0;
}

/* !forest */
.footnote-definition:last-child {
  margin-bottom: 1em;
}

/* !forest */
.footnote-definition>p {
  display: inline;
}

/* !forest */
.footnote-definition-label {
  margin-right: 4px;
}

/* !forest */
.footnote-reference:target {
  border: 1px solid var(--target-color);
}

.footnote-definition:target>.footnote-definition-label {
  border: 1px solid var(--target-color);
}

.footnote-reference::before,
.footnote-definition-label::before {
  content: "[";
}

.footnote-reference::after,
.footnote-definition-label::after {
  content: "]";
}

.katex {
  /* Adjust `.katex font-size` to match "Noto Sans SC" & "Inria Sans". */
  font: normal 1.15em KaTeX_Main, Times New Roman, serif;
  line-height: 1.1em;
  text-indent: 0;
  text-rendering: auto;
}

.katex .mfrac .frac-line {
  font-size: 1.25em;
}

p:has(span.katex-html:empty) {
  display: none;
}

.katex-display {
  overflow-x: auto;
  overflow-y: hidden;
}

.katex-display .katex {
  /* Inconsistent bounding box at different font sizes. */
  /* Also see: https://github.com/KaTeX/KaTeX/issues/3965 */
  padding-top: 1px;
}

.display-none {
  display: none;
}

blockquote {
  font-style: italic;
}

blockquote {
  display: block;
  margin-block-start: 1em;
  margin-block-end: 1em;
  margin-inline-start: 40px;
  margin-inline-end: 40px;
  unicode-bidi: isolate;
}

h1,
h2,
h3,
h4 {
  margin-top: 0.5em;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-weight: normal;
  font-weight: 500;
  margin-bottom: 0;
}

h5,
h6,
p {
  margin-top: 0;
}

details>summary {
  list-style-type: none;
  outline: none;
}

details>summary>header {
  display: inline;
}

/* no effect */
details>summary::marker,
details>summary::-webkit-details-marker {
  display: none;
}

details h1 {
  font-size: 1.2em;
  display: inline;
}

details>summary {
  list-style-type: none;
}

span.taxon {
  color: var(--span-taxon-color);
  font-weight: 500;
}

section .block[data-taxon] details>summary>header>h1 {
  font-size: 13pt;
}

article>section>details>summary>header>h1 {
  font-size: 1.5em;
}

article>section>details>summary>header {
  display: block;
  margin-bottom: 0.5em;
}

article>section>details>summary>header>h1>.taxon {
  display: block;
  font-size: 0.9em;
  color: var(--article-taxon-color);
  padding-bottom: 5pt;
}

article>section>details>summary>header>h1>.taxon:empty {
  display: none;
}

section.block>details {
  margin-bottom: 0.4em;
}

section.block>details[open] {
  margin-bottom: 1em;
}

.link-list>section.block>details {
  margin-bottom: 0.25em;
}

/* class */
.inline-typst {
  display: inline-block;
  margin: 0 0;
  line-height: 1em;
  vertical-align: middle;
}

.block {
  padding-left: 5px;
  padding-right: 10px;
  padding-bottom: 2px;
  border-radius: 5px;
}

.block {
  /* width: fit-content; */
  border-radius: var(--radius);
}

.block:hover {
  background-color: var(--hover-color-block);
}

.block.hide-metadata>details>summary>header>.metadata {
  display: none;
}

img {
  object-fit: cover;
  max-width: 100%;
}

figure {
  text-align: center;
}

figcaption {
  font-style: italic;
  padding: 3px;
}

mark {
  background-color: var(--mark-color);
}

hr {
  margin-top: 10px;
  margin-bottom: 20px;
  background-color: gray;
  border: 0 none;
  width: 100%;
  height: 1pt;
}

ul,
ol {
  margin-top: 1em;
  margin-bottom: 1em;
}

.logo>span {
  color: var(--logo-color);
  text-decoration: none;
}

.logo>span:hover {
  color: var(--logo-hover-color);
}

.logo {
  font-weight: 600;
  font-size: 24px;
}

section section[data-taxon="Reference"]>details>summary>header>h1>.taxon,
section section[data-taxon="Person"]>details>summary>header>h1>.taxon {
  display: none;
}

section .block[data-taxon]>header>h1,
section .block[data-taxon] details>summary>header>h1 {
  font-size: 13pt;
}

footer>section {
  margin-bottom: 1em;
}

footer h2 {
  font-size: 14pt;
}

.metadata ul {
  padding-left: 0;
  display: inline;
}

.metadata li::after {
  content: " · ";
}

.metadata li:last-child::after {
  content: "";
}

.metadata * {
  display: inline;
}

.link {
  cursor: pointer;
}

a {
  color: var(--link-color);
  text-decoration: inherit;
}

a.slug:hover,
a.bullet:hover,
.edit-button:hover,
.link:hover {
  background-color: var(--hover-color-link);
}

.link.external {
  text-decoration: underline;
}

.link.asset {
  text-decoration: underline;
}

.link.asset::before {
  content: "[F] ";
}

a.link.local,
.link.local a,
a.slug {
  box-shadow: none;
  text-decoration-line: underline;
  text-decoration-style: dotted;
}

.slug,
.doi,
.orcid {
  color: var(--slug-color);
  font-weight: 200;
}

body>header {
  margin-bottom: 0.5em;
}

#grid-wrapper>article {
  max-width: var(--article-max-width);
  margin-right: auto;
  grid-area: article;
}

@media only screen and (max-width: 1000px) {
  body {
    margin-top: 1em;
    margin-left: 0.5em;
    margin-right: 0.5em;
    transition: ease all 0.2s;
  }

  #grid-wrapper>nav {
    transition: ease all 0.2s;
  }

  .mobile-sticky-nav {
    position: sticky;
    top: 0px;
    max-height: calc(100vh - 0px);
    overflow-y: auto;
    scrollbar-width: thin;

    background-color: var(--background-color);
    z-index: 7;
    border-bottom: solid var(--text-color);
  }
}

@media only screen and (min-width: 1000px) {
  body {
    margin-top: 2em;
    margin-left: 2em;
    transition: ease all 0.2s;
  }

  #grid-wrapper {
    display: grid;
    grid-auto-flow: column;
  }

  .sticky-nav {
    position: sticky;
    top: 0px;
    max-height: calc(100vh - 0px);
    overflow-y: auto;
    scrollbar-width: thin;
  }
}

nav#toc li.item-summary li {
  display: none;
}

nav#toc ul {
  list-style-type: none;
}

nav#toc li>ul {
  margin: 0;
  padding-left: 1em;
}

nav#toc,
nav#toc a {
  color: var(--toc-link-color);
}

nav#toc {
  grid-area: toc;
}

nav {
  font-optical-sizing: auto;
}

nav#toc a.bullet {
  opacity: 0.7;
  margin-left: 0.4em;
  margin-right: 0.3em;
  padding-left: 0.2em;
  padding-right: 0.2em;
  text-decoration: none;
}

.typst-text use[fill="#000000"] {
  fill: var(--text-color);
}

.typst-group use[fill="#000000"] {
  fill: var(--text-color);
}

path.typst-shape[fill="#000000"] {
  fill: var(--text-color);
}

path.typst-shape[stroke="#000000"] {
  stroke: var(--text-color);
}</style><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style><style>
  footer section[data-taxon]:has(a[href="/index"]) {
    display: none;
  }
</style><link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  href="https://fonts.googleapis.com/css2?family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap"
  rel="stylesheet" />

<style>
  body {
    font-family: "Inria Sans", sans-serif;
    line-height: 1.55;
  }

  .cjk_fallback {
    font-family: "Inria Sans", sans-serif;
  }

  pre,
  code {
    font-family: monospace;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-family: "Inria Sans", sans-serif;
  }

  nav {
    font-family: "Inria Sans", sans-serif;
  }

  thead {
    font-family: "Inria Sans", sans-serif;
  }
</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css"
  integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous" />
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js"
  integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js"
  integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js"
  integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  function storeSelectedTheme(name) {
    localStorage.setItem(window.themeKey, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(window.themeKey) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }

      applyDynamicColorInvert();
    }
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    const baseUrl = document.getElementById("grid-wrapper").dataset.baseUrl;
    window.themeKey = `${baseUrl}-kodama-theme`;

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');
  
  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const dynamicStyleId = 'dynamic-color-invert-style';

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const result = solveColor(rgb);
      const filter = result.filter;

      const existingStyle = document.getElementById(dynamicStyleId);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = dynamicStyleId;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script><template id="inline-section">
  <section class="block" data-taxon="">
    <details open="">
      <summary>
        <header>
          <h1>
            <span class="taxon"></span>
            <div id="title"></div>
          </h1>
        </header>
      </summary>
      <div id="content"></div>
    </details>
  </section>
</template>

<script>
  function inlineSection(template, section, taxon, title) {
    taxon = taxon || section.getAttribute("taxon") || "";
    title = title || section.getAttribute("title") || "";

    const clone = template.content.cloneNode(true);
    clone.querySelector("section").dataset.taxon = taxon;
    clone.querySelector(".taxon").textContent = `${taxon}. `;
    clone.querySelector("#title").replaceWith(title);
    clone.querySelector("#content").replaceWith(...section.childNodes);

    if (section.hasAttribute("close")) {
      clone.querySelector("details").removeAttribute("open");
    }
    
    section.replaceWith(clone);
  }

  const tagTaxonTable = {
    "exegesis": "Exegesis",
    "definition": "Definition",
    "proposition": "Proposition",
    "remark": "Remark",
    "conjecture": "Conjecture",
    "postulate": "Postulate",
    "claim": "Claim",
    "observation": "Observation",
    "fact": "Fact",
    "hypothesis": "Hypothesis",
    "axiom": "Axiom",
    "lemma": "Lemma",
    "theorem": "Theorem",
    "corollary": "Corollary",
    "example": "Example", 
    "proof": "Proof",
  };

  document.addEventListener("DOMContentLoaded", () => {
    const template = document.getElementById("inline-section");

    [...document.getElementsByTagName("block")].forEach(section => inlineSection(template, section));

    Object.entries(tagTaxonTable).forEach(([tag, taxon]) => {
      [...document.getElementsByTagName(tag)].forEach(section => inlineSection(template, section, taxon));
    });
  });
</script></head><body><header class="header"><nav class="nav"><div class="logo"><span onclick="window.location.href='/data-structure/synthetic-differential/dual-number'" title="对偶数">« 对偶数</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="/"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"><!-- Copyright (c) 2025 Kodama Project. All rights reserved. -->
<!-- Released under the Apache-2.0 license as described in the file LICENSE. -->
<!-- Authors: Kokic (@kokic) -->

<style>
  body:has(input[value="printer"]:checked) {
    --hover-primary-color: 235, 235, 235;
    --link-primary-color: 115, 80, 87;

    --text-color: rgb(20, 22, 27);
    --toc-link-color: #555;
    --background-color: #ffffff;

    --background-color-pre: rgba(0, 100, 100, 0.04);
    --background-color-code: rgba(0, 100, 100, 0.04);

    --hover-color-block: rgba(var(--hover-primary-color));
    --hover-color-link: rgba(201, 201, 201, 0.8);
    --target-color: rgb(255, 255, 151);

    --link-color: rgb(var(--link-primary-color));
    --slug-color: rgb(99, 99, 99);
    --logo-color: #999;
    --logo-hover-color: #666;
    --span-taxon-color: rgb(var(--link-primary-color));
    --em-color: rgb(53, 53, 53);

    .block:has(.block:hover) {
      background-color: var(--background-color);
    }
  }
</style>

<theme-option name="printer" style="display: none;">printer</theme-option>
</div></nav>

<article><section class="block" data-taxon="Axiom"><details open><summary id="data-structure-synthetic-differential-kock-lawvere"><header><h1><span class="taxon">Axiom. </span>Kock–Lawvere <a class="slug" href="/data-structure/synthetic-differential/kock-lawvere">[kock-lawvere]</a></h1><div class="metadata"><ul><li class="meta-item">May 13, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\R{\mathbf{R}}$</p>
<p>首先需要强调的是, 这个公理所涉及到的结构的有效性全都依赖于 <span class="link local"><a href="/bib/jin2024topos" title="意象理论讲义 [bib/jin2024topos]">意象理论</a></span>, 而相关基础的严格性保证基本上在 1970 年之前就已经由 <span class="link local"><a href="/person/william-lawvere" title="Francis William Lawvere [person/william-lawvere]">William Lawvere</a></span> 完工. 记 $\mathcal{E}$ 是光滑空间之间的光滑映射构成的范畴, 同时假定 $\mathcal{E}$ 还是笛卡尔闭范畴, 也就是 $\mathcal{E}$ 中的箭头对笛卡尔积封闭.</p>
<p>我们可以从 $\mathcal{E}$ 中选出一条几何直线 $R$, 通过指定 $R$ 上两点 $0$ 和 $1$ 之间的距离作为单位长度来确定其他线段的长度. 发挥一些古希腊精神, 线段的移动可以给出 $R$ 上的加法, 尺规作图所构造的 <span class="link local"><a href="/bib/methods-of-algebra-1" title="代数学方法 卷一：基础架构 [bib/methods-of-algebra-1]">相似三角形</a></span> 能给出 $R$ 上的乘法 $\gamma = \alpha\beta$.</p>
<p><figure><img src="/data-structure/synthetic-differential/similar-triangle.svg" class="color-invert"/><figcaption>Methods in Algebra - Volume 1, p. 369</figcaption></figure></p>
<p>因此 $R$ 带有交换环结构, 并且允许经典数学中的对象实数环 $\R$ 成为 $R$ 的模型, 注意这里我们只能考虑 $\R$ 作为环的部分, 因为 $R$ 中存在着幂零元.</p>
<p>Kock–Lawvere 公理说的是, 对任意映射 $f: D \to R$, 存在唯一的 $a,b \in R$, 使得</p>
<p>$$ 
f(\epsilon) \spaces= a + b \epsilon, \quad \forall \epsilon \in D 
$$</p>
<p>将这里的 $a$ 换成 $f(0)$, 并完全使用量词叙述, 则是</p>
<p>$$ 
\forall ~ f \in R^D, ~ \exists! ~ b ~ \text{s.t.} ~ \forall ~ d \in D \quad (f(d) = f(0) + b d) 
$$</p>
<p>如果说这个公理的形式还不足以暗示它的目的, 那么下面这个推论就完全能做到了.</p>
<p><section class="block hide-metadata" data-taxon="Corollary"><details open><summary id="data-structure-synthetic-differential-smooths"><header><h1><span class="taxon">Corollary. </span>所有函数都光滑 <a class="slug" href="/data-structure/synthetic-differential/smooths">[smooths]</a></h1><div class="metadata"><ul><li class="meta-item">May 13, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>对任意函数 $f:R \rightarrow R$, 存在唯一的函数 $f':R \rightarrow R$ 满足</p>
<p>$$
f(x + \varepsilon) \spaces= f(x) + f'(x)\varepsilon,\quad \forall ~ x \in R, ~ \forall ~ \varepsilon \in D
$$</p>
<p>这个通常作为 <span class="link local"><a href="/data-structure/synthetic-differential/kock-lawvere" title="Kock–Lawvere [data-structure/synthetic-differential/kock-lawvere]">Kock–Lawvere 公理</a></span> 的推论出现, 不过从 $\mathcal{E}$ 的定义来看, 这才是整套框架真正的目的之一. 即, 为全体函数恢复牛顿时期 “幂零无穷小量” 计算上的直观, 而不导致矛盾.</p>
<p><figure><img src="/data-structure/synthetic-differential/maclaurin.svg" class="color-invert"/></figure></p>
</details></section></p>
<blockquote>
<p>Axiom is incompatible with the law of excluded middle.
Either the one or the other has to leave the scene.
In Part I of this book, the law of excluded middle has to leave,
being incompatible with the natural synthetic reasoning
on smooth geometry to be presented here.
In the terms which the logicians use, this means that
the logic employed is ‘constructive’ or ‘intuitionistic’.
We prefer to think of it just as ‘that reasoning
which can be carried out in all sufficiently good
cartesian closed categories’. <p style="text-align: right;">— Anders Kock, <span class="link local"><a href="/bib/kock2006synthetic" title="Synthetic differential geometry [bib/kock2006synthetic]">Synthetic Differential Geometry</a></span></p></p>
</blockquote>
</details></section><footer><section class="block"><details open><summary><header><h1>References</h1></header></summary><section class="block" data-taxon="Reference"><details ><summary id="bib-jin2024topos"><header><h1><span class="taxon">Reference. </span>意象理论讲义 <a class="slug" href="/bib/jin2024topos">[jin2024topos]</a></h1><div class="metadata"><ul><li class="meta-item">November 20, 2024</li><li class="meta-item">王进一</li><li class="meta-item"><span class="link external"><a href="https://github.com/SimplicialCat/topos/blob/main/topos.pdf" title="电子版 [https://github.com/SimplicialCat/topos/blob/main/topos.pdf]">电子版</a></span></li></ul></div></header></summary>
<p>本书对数学没有原创性的贡献, 其中几乎所有结果在 20 世纪已经为该领域的专家所熟知. 但是大部分内容找不到成体系的中文资料 (除了李文威老师的 <span class="link local"><a href="/bib/methods-of-algebra-1" title="代数学方法 卷一：基础架构 [bib/methods-of-algebra-1]">代数学方法</a></span>), 这是我编写本书的动机之一.</p>
<p>内容的编排原则大致是使初学者最易接受, 并且提供启发性的观点, 从而使人能更快入门去看更多的资料. 本书收录的论证都是十分简单而直观的; 阅读本书虽不能让人成为本领域的专家, 但能让人发现一些事情并非想象的那样困难, 在将玄妙的概念祛魅的过程中产生信心和乐趣.</p>
<p>书中许多内容的含入仅仅是由于个人的品味, 例子的选取受到了本人的微分几何与代数拓扑背景的影响. 一些证明出自本人的思考, 因此错漏是难免的. 限于水平, 书中许多细节无法深究, 包括有关集合论的 “小” 性的问题, 以及其它涉及到数学基础的问题. 许多术语没有通行的中文版本, 姑且使用了本人的翻译, 书后附有一个简短的术语表.</p>
<pre><code>@book{jin2024topos, 
  title={意象理论讲义}, 
  author={王进一}, 
  year={2024}
}
</code></pre>
</details></section><section class="block" data-taxon="Reference"><details ><summary id="bib-kock2006synthetic"><header><h1><span class="taxon">Reference. </span>Synthetic differential geometry <a class="slug" href="/bib/kock2006synthetic">[kock2006synthetic]</a></h1><div class="metadata"><ul><li class="meta-item">2006</li><li class="meta-item">Anders Kock</li><li class="meta-item">Cambridge University Press, Volume 333</li></ul></div></header></summary>
<p>The aim of the present book is to describe a foundation for
synthetic reasoning in differential geometry.
We hope that such a foundational treatise will put the reader in a position
where he, in his study of differential geometry, can utilize
the synthetic method freely and rigorously, and that it will give him notions
and language by which such study can be communicated.</p>
<pre><code>@book{kock2006synthetic,
  title={Synthetic differential geometry},
  author={Kock, Anders},
  volume={333},
  year={2006},
  publisher={Cambridge University Press}
}
</code></pre>
</details></section><section class="block" data-taxon="Reference"><details ><summary id="bib-methods-of-algebra-1"><header><h1><span class="taxon">Reference. </span>代数学方法 卷一：基础架构 <a class="slug" href="/bib/methods-of-algebra-1">[methods-of-algebra-1]</a></h1><div class="metadata"><ul><li class="meta-item">November 16, 2018</li><li class="meta-item">李文威</li><li class="meta-item"><span class="link external"><a href="https://wwli.asia/downloads/books/Al-jabr-1.pdf" title="电子版 [https://wwli.asia/downloads/books/Al-jabr-1.pdf]">电子版</a></span></li><li class="meta-item">高等教育出版社</li><li class="meta-item">现代数学基础系列</li></ul></div></header></summary>
<p>本书主题有时也称为 “近世代数” 或 “抽象代数”. 所谓近世, 总是相对于当时当世而论,
早在 1955 年 van der Waerden 发表《代数学》第四版时便已舍弃此词, 于今更无必要.
至于说抽象, 充其量是初学者的错觉, 作为课名或书名完全不得要领, 而且似乎有恫吓读者之嫌.
本书题为 “代数学方法”, 一则是因为当代代数学范围过广, 本书仅择有趣有用者而述, 不求体系大而全.
第二也是最关键的一点, 则是因为数学的本质存在于交融互摄, 只为授课与学科分画方便才打包于一词.
所以本书绝不视代数为疆界分明的学科; 与分析, 拓扑学等脱钩的纯代数即便存在, 也仅是千万种研究方向之一.
《庄子·应帝王》中有混沌凿七窍的故事, 强凿疆界同样令数学趋于停滞消亡.</p>
<pre><code>@article{wwli2019method,
  title={代数学方法 卷一：基础架构},
  author={李文威},
  series={现代数学基础},
  year={2019},
  isbn={978-7-04-050725-6},
  publisher={高等教育出版社}
}
</code></pre>
</details></section></details></section><section class="block"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Exegesis"><details ><summary id="data-structure-synthetic-differential-complex-step"><header><h1><span class="taxon">Exegesis. </span>Complex step 微分法 <a class="slug" href="/data-structure/synthetic-differential/complex-step">[complex-step]</a></h1><div class="metadata"><ul><li class="meta-item">May 13, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>Mathworks 的创始人 Cleve Moler 约 60 年 <sup class="footnote-reference" id="data-structure_synthetic-differential_complex-step_publish-time-back"><a href="#data-structure_synthetic-differential_complex-step_publish-time">1</a></sup> 前提出了借用虚数单位 $i$ 的数值微分, 相关文献称为 <span class="link external"><a href="https://blogs.mathworks.com/cleve/2013/10/14/complex-step-differentiation/" title="complex step 微分法 [https://blogs.mathworks.com/cleve/2013/10/14/complex-step-differentiation/]">complex step 微分法</a></span> <sup class="footnote-reference" id="data-structure_synthetic-differential_complex-step_complex-step-back"><a href="#data-structure_synthetic-differential_complex-step_complex-step">2</a></sup>. 考虑光滑函数 $f(x)$, 其在 $x=a$ 处可表为关于 $X$ 的 Taylor 级数 <sup class="footnote-reference" id="data-structure_synthetic-differential_complex-step_distinguish-back"><a href="#data-structure_synthetic-differential_complex-step_distinguish">3</a></sup> $f(a) + f'(a)(X-a) + \text{etc.}$, 注意</p>
<p>$$
f(a+i h) \spaces= f(a) + i h f'(a) - \frac{h^2}{2!}f''(a) - \frac{ih^3}{3!}f'''(a) + \cdots
$$</p>
<p>这个其实就是将 Taylor 级数的每一项完全展开, 在 <span class="link local"><a href="/data-structure/synthetic-differential/kock-lawvere" title="Kock–Lawvere [data-structure/synthetic-differential/kock-lawvere]">后续</a></span> 的计算中也会继续用到. 如此便有
$$ 
\frac{\partial f}{\partial x} \spaces= \frac{\Im f(x+ih)}{h} + \mathcal{O}(h^2) \quads\implies 
\frac{\partial f}{\partial x} \quads\approx \frac{\Im f(x+ih)}{h} 
$$</p>
<p>这个方法最初被设计用于处理数值微分问题, 但稍加思考就能发现, 该过程也适用于符号微分. 与前一个问题所改进的结果的精度不同, 用于 <span class="link local"><a href="/data-structure/synthetic-differential/dual-number" title="对偶数 [data-structure/synthetic-differential/dual-number]">符号微分</a></span> 时, 所取得的优势是更精简的中间表达式和非递归的计算过程.</p>
<div class="footnote-definition" id="data-structure_synthetic-differential_complex-step_publish-time">
  <sup class="footnote-definition-label"><a href="#data-structure_synthetic-differential_complex-step_publish-time-back">1</a></sup>
<p>即 1967 年. 不过这个名字要等到 1998 年, William Squire 和 George Trapp 才正式提出.</p>
</div>
<div class="footnote-definition" id="data-structure_synthetic-differential_complex-step_complex-step">
  <sup class="footnote-definition-label"><a href="#data-structure_synthetic-differential_complex-step_complex-step-back">2</a></sup>
<p>按方法的流程看, <span class="link local"><a href="/data-structure/synthetic-differential/complex-step" title="Complex step 微分法 [data-structure/synthetic-differential/complex-step]">complex step 微分</a></span> 可以翻译为 “复步微分”.</p>
</div>
<div class="footnote-definition" id="data-structure_synthetic-differential_complex-step_distinguish">
  <sup class="footnote-definition-label"><a href="#data-structure_synthetic-differential_complex-step_distinguish-back">3</a></sup>
<p>习惯上会混淆 $x$ 与 $X$.</p>
</div>
</details></section><section class="block" data-taxon="Definition"><details ><summary id="data-structure-synthetic-differential-dual-number"><header><h1><span class="taxon">Definition. </span>对偶数 <a class="slug" href="/data-structure/synthetic-differential/dual-number">[dual-number]</a></h1><div class="metadata"><ul><li class="meta-item">May 14, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\R{\mathbf{R}}$
$\gdef\C{\mathbf{C}}$</p>
<p>一种通俗的讲法是, 认为对偶数 $R[x]/(x^2)$ 可以作为复数 $\R[x]/(x^2+1)$ 的类比. 如果有读者能轻率地暂时忽略 $R[x]/(x^2)$ 这种结构的存在性, 或者说接受了下面的 $d$ 的定义</p>
<p>$$ \exists ~ d \in R\smallsetminus\{0\}, ~ d^2 = 0 $$</p>
<p>不能接受也很正常, 因为这轻易就会导致某个经典逻辑中的 <span class="link local"><a href="/data-structure/synthetic-differential/schanuel-lavendhomme" title="Schanuel–Lavendhomme 构造 [data-structure/synthetic-differential/schanuel-lavendhomme]">矛盾</a></span>. 相比之下满足 $x^2 = -1$ 的 $x$ 对于大众而言要更容易接受的多, 甚至对于三次方程是 <span class="link local"><a href="/linear-algebra/casus-irreducibilis" title="Casus irreducibilis [linear-algebra/casus-irreducibilis]">必须品</a></span>. 为此我们需要下面的准备工作.</p>
<p><section class="block" data-taxon="Axiom"><details ><summary id="data-structure-synthetic-differential-kock-lawvere"><header><h1><span class="taxon">Axiom. </span>Kock–Lawvere <a class="slug" href="/data-structure/synthetic-differential/kock-lawvere">[kock-lawvere]</a></h1><div class="metadata"><ul><li class="meta-item">May 13, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\R{\mathbf{R}}$</p>
<p>首先需要强调的是, 这个公理所涉及到的结构的有效性全都依赖于 <span class="link local"><a href="/bib/jin2024topos" title="意象理论讲义 [bib/jin2024topos]">意象理论</a></span>, 而相关基础的严格性保证基本上在 1970 年之前就已经由 <span class="link local"><a href="/person/william-lawvere" title="Francis William Lawvere [person/william-lawvere]">William Lawvere</a></span> 完工. 记 $\mathcal{E}$ 是光滑空间之间的光滑映射构成的范畴, 同时假定 $\mathcal{E}$ 还是笛卡尔闭范畴, 也就是 $\mathcal{E}$ 中的箭头对笛卡尔积封闭.</p>
<p>我们可以从 $\mathcal{E}$ 中选出一条几何直线 $R$, 通过指定 $R$ 上两点 $0$ 和 $1$ 之间的距离作为单位长度来确定其他线段的长度. 发挥一些古希腊精神, 线段的移动可以给出 $R$ 上的加法, 尺规作图所构造的 <span class="link local"><a href="/bib/methods-of-algebra-1" title="代数学方法 卷一：基础架构 [bib/methods-of-algebra-1]">相似三角形</a></span> 能给出 $R$ 上的乘法 $\gamma = \alpha\beta$.</p>
<p><figure><img src="/data-structure/synthetic-differential/similar-triangle.svg" class="color-invert"/><figcaption>Methods in Algebra - Volume 1, p. 369</figcaption></figure></p>
<p>因此 $R$ 带有交换环结构, 并且允许经典数学中的对象实数环 $\R$ 成为 $R$ 的模型, 注意这里我们只能考虑 $\R$ 作为环的部分, 因为 $R$ 中存在着幂零元.</p>
<p>Kock–Lawvere 公理说的是, 对任意映射 $f: D \to R$, 存在唯一的 $a,b \in R$, 使得</p>
<p>$$ 
f(\epsilon) \spaces= a + b \epsilon, \quad \forall \epsilon \in D 
$$</p>
<p>将这里的 $a$ 换成 $f(0)$, 并完全使用量词叙述, 则是</p>
<p>$$ 
\forall ~ f \in R^D, ~ \exists! ~ b ~ \text{s.t.} ~ \forall ~ d \in D \quad (f(d) = f(0) + b d) 
$$</p>
<p>如果说这个公理的形式还不足以暗示它的目的, 那么下面这个推论就完全能做到了.</p>
<p><section class="block" data-taxon="Corollary"><details ><summary id="data-structure-synthetic-differential-smooths"><header><h1><span class="taxon">Corollary. </span>所有函数都光滑 <a class="slug" href="/data-structure/synthetic-differential/smooths">[smooths]</a></h1><div class="metadata"><ul><li class="meta-item">May 13, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>对任意函数 $f:R \rightarrow R$, 存在唯一的函数 $f':R \rightarrow R$ 满足</p>
<p>$$
f(x + \varepsilon) \spaces= f(x) + f'(x)\varepsilon,\quad \forall ~ x \in R, ~ \forall ~ \varepsilon \in D
$$</p>
<p>这个通常作为 <span class="link local"><a href="/data-structure/synthetic-differential/kock-lawvere" title="Kock–Lawvere [data-structure/synthetic-differential/kock-lawvere]">Kock–Lawvere 公理</a></span> 的推论出现, 不过从 $\mathcal{E}$ 的定义来看, 这才是整套框架真正的目的之一. 即, 为全体函数恢复牛顿时期 “幂零无穷小量” 计算上的直观, 而不导致矛盾.</p>
<p><figure><img src="/data-structure/synthetic-differential/maclaurin.svg" class="color-invert"/></figure></p>
</details></section></p>
<blockquote>
<p>Axiom is incompatible with the law of excluded middle.
Either the one or the other has to leave the scene.
In Part I of this book, the law of excluded middle has to leave,
being incompatible with the natural synthetic reasoning
on smooth geometry to be presented here.
In the terms which the logicians use, this means that
the logic employed is ‘constructive’ or ‘intuitionistic’.
We prefer to think of it just as ‘that reasoning
which can be carried out in all sufficiently good
cartesian closed categories’. <p style="text-align: right;">— Anders Kock, <span class="link local"><a href="/bib/kock2006synthetic" title="Synthetic differential geometry [bib/kock2006synthetic]">Synthetic Differential Geometry</a></span></p></p>
</blockquote>
</details></section></p>
<p>无论是单纯接受这个 <span class="link local"><a href="/data-structure/synthetic-differential/kock-lawvere" title="Kock–Lawvere [data-structure/synthetic-differential/kock-lawvere]">公理</a></span> 还是认可该公理存在的舞台 $\mathcal{E}$, 其实都会导致完全相同的结果, 那就是 $\mathcal{E}$ 当中一般函数的性质发生了变化, 让所有的函数都变得光滑. 与之相对的, 这样的好性质所要求的代价是, $\mathcal{E}$ 当中不能使用经典逻辑中的选择公理、排中律、反证法等命题.</p>
<p><section class="block" data-taxon="Exegesis"><details ><summary id="data-structure-synthetic-differential-matrix-represent"><header><h1><span class="taxon">Exegesis. </span>矩阵表示 <a class="slug" href="/data-structure/synthetic-differential/matrix-represent">[matrix-represent]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\str#1{{\footnotesize #1}}$
$\gdef\C{\mathbf{C}}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>这样一来, 我们所说的 <span class="link local"><a href="/data-structure/synthetic-differential/moler-correction" title="复步微分法 对数值微分误差的修正 [data-structure/synthetic-differential/moler-correction]">“将近似修正为严格等于”</a></span> 就可以精确表示为</p>
<p>$$ \frac{\partial f}{\partial x} \quads= f(x+\varepsilon) ~ \str{中} ~ \varepsilon ~ \str{项的系数} $$</p>
<p><span class="link local"><a href="/data-structure/synthetic-differential/complex-step" title="Complex step 微分法 [data-structure/synthetic-differential/complex-step]">复步微分法</a></span> 的来源是完全解析的, 但其得到的微分方法却能代数地刻画. 正如我们可以考虑复数的 $z = a+b\sqrt{-1} \in \C$ 矩阵表示</p>
<p>$$
A \spaces= \begin{pmatrix}
a &amp; -b \\
b &amp; ~~~a \\
\end{pmatrix}
,\quad
\det A \spaces= (a+b\sqrt{-1})(a-b\sqrt{-1}) 
$$</p>
<p>我们也可以构造 <span class="link local"><a href="/data-structure/synthetic-differential/dual-number" title="对偶数 [data-structure/synthetic-differential/dual-number]">对偶数</a></span> $a + b \varepsilon \in R$ 的矩阵表示, 并自动得到微分运算的加法和乘法规则, 这可以被简单地视为 Moler 方法的矩阵版本.</p>
<p>$$
A \spaces= \begin{pmatrix}
a &amp; a' \\
0 &amp; a \\
\end{pmatrix}
,\quad
\det A \spaces= (a+b\varepsilon)(a-b\varepsilon)
$$</p>
</details></section>
<section class="block" data-taxon="Example"><details ><summary id="data-structure-synthetic-differential-derived-differential"><header><h1><span class="taxon">Example. </span>导出微分运算 <a class="slug" href="/data-structure/synthetic-differential/derived-differential">[derived-differential]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\Mat{\operatorname{Mat}}$
$\gdef\d{\operatorname{d}}$
$\gdef\Z{\mathbf{Z}}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>设 $u, v \in R^R$, $n \in \Z$. 记 $A(u, u') = (\begin{smallmatrix} u &amp; u' \\ 0 &amp; u \end{smallmatrix})$. 从矩阵运算中立刻得到</p>
<ol>
<li>$A(u, u') + A(v, v') \spaces= A(u+v, u'+v')$</li>
<li>$A(u, u') - A(v, v') \spaces= A(u-v, u'-v')$</li>
<li>$A(u, u') \cdot A(v, v') \spaces= A(uv, u'v + uv')$</li>
<li>$A(u, u') \cdot (A(v, v'))^{-1} \spaces= A(uv^{-1}, (u'v - uv')v^{-2})$</li>
<li>$(A(u, u'))^n = A(u^n, nu^{n-1}u')$</li>
</ol>
<p>对于 $e^{A(u,u')}$, 注意 $A(u, u') = A(u, 0) + A(0, u')$, 这里 $(A(0, u))^2 = 0$. 同样可以计算得到 $e^{A(u,u')} = A(e^u, 0) \cdot A(1, u') = A(e^u, e^u u')$. 而对于 $\log A(u,u')$ 我们直接展开为 $\sum_{k \ge 1}\frac{(-1)^{k+1}}{k} \cdot (A-1)^k$ 即可验证:</p>
<p>$$
\begin{pmatrix} \sum_{k \ge 1}\frac{(-1)^{k+1}}{k} \cdot (u-1)^k &amp; \sum_{k \ge 0} (-1)^k (u-1)^k \cdot u'  \\ 0 &amp; \sum_{k \ge 1}\frac{(-1)^{k+1}}{k} \cdot (u-1)^k \end{pmatrix}
\spaces= 
\begin{pmatrix} \log u &amp; u'u^{-1} \\ 0 &amp; \log u \end{pmatrix}
$$</p>
</details></section>
<section class="block" data-taxon="Exegesis"><details ><summary id="data-structure-synthetic-differential-chain-rule"><header><h1><span class="taxon">Exegesis. </span>链式法则 <a class="slug" href="/data-structure/synthetic-differential/chain-rule">[chain-rule]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\Mat{\operatorname{Mat}}$
$\gdef\spaces#1{~ #1 ~}$
$\gdef\d{\operatorname{d}}$
$\gdef\eqdef{\overset{\scriptscriptstyle\text{def}}{=}}$</p>
<p>与 $\Mat_{2 \times 2}(R^R)$ 上的 <span class="link local"><a href="/data-structure/synthetic-differential/derived-differential" title="矩阵表示导出微分运算 [data-structure/synthetic-differential/derived-differential]">运算</a></span> 不同, 复合运算是只位于 $R^R$ 上的, 或者说 $\Mat_{2 \times 2}(R^R)$ 上并没有周知的复合运算. 为了自然地给出 $A: J^1(R, R) \to \Mat_{2 \times 2}(R^R)$ 上的复合, 这里 $J^1$ 是一阶 <span class="link external"><a href="https://ncatlab.org/nlab/show/jet+bundle" title="射流丛 [https://ncatlab.org/nlab/show/jet+bundle]">射流丛</a></span>. 记 $\square(x)$ 为 $\square_x $, $A(u)$ 为 $A(u,u')$, 考虑显式应用的 $A(u)$, 即</p>
<p>$$
A(u)_x \spaces\eqdef \begin{pmatrix} u_x &amp; u'_x \\ 0 &amp; u_x \end{pmatrix} \spaces\in \Mat_{2 \times 2}(R), \quad x \in R
$$</p>
<p>对于 $u: Y \to Z$, $v: X \to Y$. $A$ 上的复合 $A(u) \circ A(v)$ 可定义为 $A(u)_{v_x}$, $(v_x, v'_x) \in A(v)_x$. 我们来验证 $A(u) \circ A(v) = A(u \circ v)$.</p>
<p>$$
\begin{aligned}
A(u)_{v_x} 
&amp;\spaces= \Big(u \cdot \frac{\partial A}{\partial u} + \frac{\d u}{\d x} \cdot \frac{\partial A}{\partial u'}\Big)\Big|_{v_x} \\
&amp;\spaces= u(v_x) \cdot \frac{\partial A}{\partial u} + \frac{\d u(v_x)}{\d v_x} \frac{\d v_x}{\d x} \cdot \frac{\partial A}{\partial u'} \\
&amp;\spaces= A(u(v(x)), u'(v(x))v'(x)) \\
\end{aligned}
$$</p>
</details></section></p>
</details></section><section class="block" data-taxon="Corollary"><details ><summary id="data-structure-synthetic-differential-smooths"><header><h1><span class="taxon">Corollary. </span>所有函数都光滑 <a class="slug" href="/data-structure/synthetic-differential/smooths">[smooths]</a></h1><div class="metadata"><ul><li class="meta-item">May 13, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>对任意函数 $f:R \rightarrow R$, 存在唯一的函数 $f':R \rightarrow R$ 满足</p>
<p>$$
f(x + \varepsilon) \spaces= f(x) + f'(x)\varepsilon,\quad \forall ~ x \in R, ~ \forall ~ \varepsilon \in D
$$</p>
<p>这个通常作为 <span class="link local"><a href="/data-structure/synthetic-differential/kock-lawvere" title="Kock–Lawvere [data-structure/synthetic-differential/kock-lawvere]">Kock–Lawvere 公理</a></span> 的推论出现, 不过从 $\mathcal{E}$ 的定义来看, 这才是整套框架真正的目的之一. 即, 为全体函数恢复牛顿时期 “幂零无穷小量” 计算上的直观, 而不导致矛盾.</p>
<p><figure><img src="/data-structure/synthetic-differential/maclaurin.svg" class="color-invert"/></figure></p>
</details></section></details></section></footer></article></div></body></html>