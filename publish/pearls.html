<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>Pearls</title><link rel="icon" href="/assets/favicon.ico" /><style>:root body {
  color-scheme: light dark;
  --content-gap: 15px;
  --radius: 5px;
  --article-max-width: 90ex;
  --toc-max-width: 90ex;

  --text-color: black;
  --toc-link-color: #555;
  --background-color: white;

  --background-color-pre: rgba(0, 100, 100, 0.04);
  --background-color-code: rgba(0, 100, 100, 0.04);

  --hover-color-block: rgba(0, 100, 255, 0.04);
  --hover-color-link: rgba(0, 100, 255, 0.1);
  --target-color: rgb(67, 92, 255);

  --link-color: black;
  --slug-color: gray;
  --logo-color: #666;
  --logo-hover-color: #aaa;
  --span-taxon-color: #444;
  --article-taxon-color: #888;
  --mark-color: rgb(255, 255, 151);
  --em-color: var(--text-color);
}

@media (prefers-color-scheme: dark) {
  :root body {
    --text-color: white;
    --toc-link-color: white;
    --background-color: #2f2f2f;

    --background-color-pre: rgba(100, 100, 100, 0.2);
    --background-color-code: rgba(150, 150, 150, 0.2);

    --hover-color-block: rgba(100, 162, 255, 0.06);
    --hover-color-link: rgba(100, 162, 255, 0.2);
    --target-color: rgb(255, 255, 151);

    --link-color: white;
    --slug-color: #aeaeae;
    --logo-color: #999;
    --logo-hover-color: #eee;
    --span-taxon-color: #bbb;
  }
}

body {
  color: var(--text-color);
  font-optical-sizing: auto;
  hyphens: auto;
  background-color: var(--background-color);
}

pre,
code {
  font-optical-sizing: auto;
}

p,
pre {
  line-height: 1.55;
}

pre {
  border-radius: var(--radius);
  background-color: var(--background-color-pre);
  padding: 0.5em;
  font-size: 11pt;
  margin-top: 0em;
  overflow-x: auto;
  white-space: pre-wrap;
  white-space: -moz-pre-wrap;
  white-space: -pre-wrap;
  white-space: -o-pre-wrap;
  word-wrap: break-word;
}

code {
  border-radius: var(--radius);
  background-color: var(--background-color-code);
  padding: 0.2em;
  font-size: 1em;
}

em {
  color: var(--em-color);
}

table {
  border-collapse: collapse;
}

/* !forest */
th {
  font-weight: normal;
  text-align: left;
}

th,
td {
  padding: 0 15px;
  vertical-align: top;
}

/* !forest */
pre>code {
  border-radius: 0;
  background-color: transparent;
  padding: 0;
}

/* !forest */
.footnote-definition:last-child {
  margin-bottom: 1em;
}

/* !forest */
.footnote-definition>p {
  display: inline;
}

/* !forest */
.footnote-definition-label {
  margin-right: 4px;
}

/* !forest */
.footnote-reference:target {
  border: 1px solid var(--target-color);
}

.footnote-definition:target>.footnote-definition-label {
  border: 1px solid var(--target-color);
}

.footnote-reference::before,
.footnote-definition-label::before {
  content: "[";
}

.footnote-reference::after,
.footnote-definition-label::after {
  content: "]";
}

.katex {
  /* Adjust `.katex font-size` to match "Noto Sans SC" & "Inria Sans". */
  font: normal 1.15em KaTeX_Main, Times New Roman, serif;
  line-height: 1.1em;
  text-indent: 0;
  text-rendering: auto;
}

.katex .mfrac .frac-line {
  font-size: 1.25em;
}

p:has(span.katex-html:empty) {
  display: none;
}

.katex-display {
  overflow-x: auto;
  overflow-y: hidden;
}

.katex-display .katex {
  /* Inconsistent bounding box at different font sizes. */
  /* Also see: https://github.com/KaTeX/KaTeX/issues/3965 */
  padding-top: 1px;
}

.display-none {
  display: none;
}

blockquote {
  font-style: italic;
}

blockquote {
  display: block;
  margin-block-start: 1em;
  margin-block-end: 1em;
  margin-inline-start: 40px;
  margin-inline-end: 40px;
  unicode-bidi: isolate;
}

h1,
h2,
h3,
h4 {
  margin-top: 0.5em;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-weight: normal;
  font-weight: 500;
  margin-bottom: 0;
}

h5,
h6,
p {
  margin-top: 0;
}

details>summary {
  list-style-type: none;
  outline: none;
}

details>summary>header {
  display: inline;
}

/* no effect */
details>summary::marker,
details>summary::-webkit-details-marker {
  display: none;
}

details h1 {
  font-size: 1.2em;
  display: inline;
}

details>summary {
  list-style-type: none;
}

span.taxon {
  color: var(--span-taxon-color);
  font-weight: 500;
}

section .block[data-taxon] details>summary>header>h1 {
  font-size: 13pt;
}

article>section>details>summary>header>h1 {
  font-size: 1.5em;
}

article>section>details>summary>header {
  display: block;
  margin-bottom: 0.5em;
}

article>section>details>summary>header>h1>.taxon {
  display: block;
  font-size: 0.9em;
  color: var(--article-taxon-color);
  padding-bottom: 5pt;
}

article>section>details>summary>header>h1>.taxon:empty {
  display: none;
}

section.block>details {
  margin-bottom: 0.4em;
}

section.block>details[open] {
  margin-bottom: 1em;
}

.link-list>section.block>details {
  margin-bottom: 0.25em;
}

/* class */
.inline-typst {
  display: inline-block;
  margin: 0 0;
  line-height: 1em;
  vertical-align: middle;
}

.block {
  padding-left: 5px;
  padding-right: 10px;
  padding-bottom: 2px;
  border-radius: 5px;
}

.block {
  /* width: fit-content; */
  border-radius: var(--radius);
}

.block:hover {
  background-color: var(--hover-color-block);
}

.block.hide-metadata>details>summary>header>.metadata {
  display: none;
}

img {
  object-fit: cover;
  max-width: 100%;
}

figure {
  text-align: center;
}

figcaption {
  font-style: italic;
  padding: 3px;
}

mark {
  background-color: var(--mark-color);
}

hr {
  margin-top: 10px;
  margin-bottom: 20px;
  background-color: gray;
  border: 0 none;
  width: 100%;
  height: 1pt;
}

ul,
ol {
  margin-top: 1em;
  margin-bottom: 1em;
}

.logo>span {
  color: var(--logo-color);
  text-decoration: none;
}

.logo>span:hover {
  color: var(--logo-hover-color);
}

.logo {
  font-weight: 600;
  font-size: 24px;
}

section section[data-taxon="Reference"]>details>summary>header>h1>.taxon,
section section[data-taxon="Person"]>details>summary>header>h1>.taxon {
  display: none;
}

section .block[data-taxon]>header>h1,
section .block[data-taxon] details>summary>header>h1 {
  font-size: 13pt;
}

footer>section {
  margin-bottom: 1em;
}

footer h2 {
  font-size: 14pt;
}

.metadata ul {
  padding-left: 0;
  display: inline;
}

.metadata li::after {
  content: " · ";
}

.metadata li:last-child::after {
  content: "";
}

.metadata * {
  display: inline;
}

.link {
  cursor: pointer;
}

a {
  color: var(--link-color);
  text-decoration: inherit;
}

a.slug:hover,
a.bullet:hover,
.edit-button:hover,
.link:hover {
  background-color: var(--hover-color-link);
}

.link.external {
  text-decoration: underline;
}

.link.asset {
  text-decoration: underline;
}

.link.asset::before {
  content: "[F] ";
}

a.link.local,
.link.local a,
a.slug {
  box-shadow: none;
  text-decoration-line: underline;
  text-decoration-style: dotted;
}

.slug,
.doi,
.orcid {
  color: var(--slug-color);
  font-weight: 200;
}

body>header {
  margin-bottom: 0.5em;
}

#grid-wrapper>article {
  max-width: var(--article-max-width);
  margin-right: auto;
  grid-area: article;
}

@media only screen and (max-width: 1000px) {
  body {
    margin-top: 1em;
    margin-left: 0.5em;
    margin-right: 0.5em;
    transition: ease all 0.2s;
  }

  #grid-wrapper>nav {
    transition: ease all 0.2s;
  }

  .mobile-sticky-nav {
    position: sticky;
    top: 0px;
    max-height: calc(100vh - 0px);
    overflow-y: auto;
    scrollbar-width: thin;

    background-color: var(--background-color);
    z-index: 7;
    border-bottom: solid var(--text-color);
  }
}

@media only screen and (min-width: 1000px) {
  body {
    margin-top: 2em;
    margin-left: 2em;
    transition: ease all 0.2s;
  }

  #grid-wrapper {
    display: grid;
    grid-auto-flow: column;
  }

  .sticky-nav {
    position: sticky;
    top: 0px;
    max-height: calc(100vh - 0px);
    overflow-y: auto;
    scrollbar-width: thin;
  }
}

nav#toc li.item-summary li {
  display: none;
}

nav#toc ul {
  list-style-type: none;
}

nav#toc li>ul {
  margin: 0;
  padding-left: 1em;
}

nav#toc,
nav#toc a {
  color: var(--toc-link-color);
}

nav#toc {
  grid-area: toc;
}

nav {
  font-optical-sizing: auto;
}

nav#toc a.bullet {
  opacity: 0.7;
  margin-left: 0.4em;
  margin-right: 0.3em;
  padding-left: 0.2em;
  padding-right: 0.2em;
  text-decoration: none;
}

.typst-text use[fill="#000000"] {
  fill: var(--text-color);
}

.typst-group use[fill="#000000"] {
  fill: var(--text-color);
}

path.typst-shape[fill="#000000"] {
  fill: var(--text-color);
}

path.typst-shape[stroke="#000000"] {
  stroke: var(--text-color);
}</style><style>
@media only screen and (min-width: 1000px) {
  #grid-wrapper { grid-template-columns: var(--article-max-width) var(--toc-max-width); }
  nav#toc { max-width: max-content; }
}
</style><style>
  footer section[data-taxon]:has(a[href="/index"]) {
    display: none;
  }
</style><link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  href="https://fonts.googleapis.com/css2?family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap"
  rel="stylesheet" />

<style>
  body {
    font-family: "Inria Sans", sans-serif;
    line-height: 1.55;
  }

  .cjk_fallback {
    font-family: "Inria Sans", sans-serif;
  }

  pre,
  code {
    font-family: monospace;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-family: "Inria Sans", sans-serif;
  }

  nav {
    font-family: "Inria Sans", sans-serif;
  }

  thead {
    font-family: "Inria Sans", sans-serif;
  }
</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css"
  integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous" />
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js"
  integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js"
  integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js"
  integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true },
      ],
      trust: true,
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script><script>
  function toggleDetailsOpen() {
    const details = document.querySelector("#toc>div>details");
    if (!details) return;

    if (window.matchMedia("(max-width: 1000px)").matches) {
      details.removeAttribute("open");
    } else {
      details.setAttribute("open", "");
    }
  }

  document.addEventListener("DOMContentLoaded", toggleDetailsOpen);
  window.addEventListener("resize", toggleDetailsOpen);
</script><style>
  theme-option {
    display: inline-block;
  }

  theme-option>input {
    display: none;
  }

  theme-option>label {
    color: var(--slug-color);
  }

  theme-option>label:hover {
    background-color: var(--hover-color-link);
  }

  theme-option:has(input:checked)>label {
    color: var(--link-color);
  }

  theme-option>label::before {
    content: "[";
    color: rgba(0, 0, 0, 0);
  }

  theme-option>label::after {
    content: "]";
    color: rgba(0, 0, 0, 0);
  }

  theme-option:has(input:checked)>label::before {
    color: var(--link-color);
  }

  theme-option:has(input:checked)>label::after {
    color: var(--link-color);
  }
</style>

<template id="theme-option-template">
  <input type="radio" name="theme" />
  <label></label>
</template>

<script>
  function storeSelectedTheme(name) {
    localStorage.setItem(window.themeKey, name);
  }

  function getCurrentTheme() {
    return localStorage.getItem(window.themeKey) || window.primaryTheme;
  }

  function selectTheme(themeName) {
    storeSelectedTheme(themeName);
    requestAnimationFrame(applyDynamicColorInvert);
  }

  function applyFavorTheme() {
    const favoredTheme = getCurrentTheme();
    if (favoredTheme) {
      const selector = `input[type='radio'][id='${favoredTheme}']`;
      const favoredOption = window.themeOptions.querySelector(selector);

      if (favoredOption) {
        favoredOption.checked = true;
      } else if (window.primaryOption) {
        // Fallback to primary theme, if the favored theme is not found
        // e.g., when the theme options have changed, and the stored theme is no longer available.
        window.primaryOption.checked = true;
      }

      applyDynamicColorInvert();
    }
  }

  document.addEventListener("DOMContentLoaded", function () {
    window.themeOptions = document.getElementById("theme-options");
    const templateContent = document.getElementById("theme-option-template").content;

    customElements.define(
      "theme-option",
      class extends HTMLElement {
        constructor() {
          super();

          const node = templateContent.cloneNode(true);
          const themeName = this.getAttribute("name");

          const input = node.querySelector("input");
          input.setAttribute("id", themeName);
          input.setAttribute("value", themeName);

          const label = node.querySelector("label");
          label.setAttribute("for", themeName);
          label.addEventListener("click", () => selectTheme(themeName));

          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
          this.appendChild(node);
        }
      },
    );

    const baseUrl = document.getElementById("grid-wrapper").dataset.baseUrl;
    window.themeKey = `${baseUrl}-kodama-theme`;

    window.primaryOption = window.themeOptions.querySelector("input[type='radio']");
    window.primaryTheme = primaryOption?.value;

    applyFavorTheme();
  });
</script>

<script>
  const clamp = (value) => Math.max(0, Math.min(255, value));

  const multiply = ([r, g, b], matrix) => {
    const nr = clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
    const ng = clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
    const nb = clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    return [nr, ng, nb];
  };

  const hueRotate = ([r, g, b], angle = 0) => {
    const rad = (angle / 180) * Math.PI;
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    const matrix = [
      0.213 + cos * 0.787 - sin * 0.213,
      0.715 - cos * 0.715 - sin * 0.715,
      0.072 - cos * 0.072 + sin * 0.928,
      0.213 - cos * 0.213 + sin * 0.143,
      0.715 + cos * 0.285 + sin * 0.140,
      0.072 - cos * 0.072 - sin * 0.283,
      0.213 - cos * 0.213 - sin * 0.787,
      0.715 - cos * 0.715 + sin * 0.715,
      0.072 + cos * 0.928 + sin * 0.072,
    ];
    return multiply([r, g, b], matrix);
  };

  const grayscale = ([r, g, b], value = 1) => {
    const matrix = [
      0.2126 + 0.7874 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 + 0.2848 * (1 - value),
      0.0722 - 0.0722 * (1 - value),
      0.2126 - 0.2126 * (1 - value),
      0.7152 - 0.7152 * (1 - value),
      0.0722 + 0.9278 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const sepia = ([r, g, b], value = 1) => {
    const matrix = [
      0.393 + 0.607 * (1 - value),
      0.769 - 0.769 * (1 - value),
      0.189 - 0.189 * (1 - value),
      0.349 - 0.349 * (1 - value),
      0.686 + 0.314 * (1 - value),
      0.168 - 0.168 * (1 - value),
      0.272 - 0.272 * (1 - value),
      0.534 - 0.534 * (1 - value),
      0.131 + 0.869 * (1 - value),
    ];
    return multiply([r, g, b], matrix);
  };

  const saturate = ([r, g, b], value = 1) => {
    const matrix = [
      0.213 + 0.787 * value,
      0.715 - 0.715 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 + 0.285 * value,
      0.072 - 0.072 * value,
      0.213 - 0.213 * value,
      0.715 - 0.715 * value,
      0.072 + 0.928 * value,
    ];
    return multiply([r, g, b], matrix);
  };

  const linear = ([r, g, b], slope = 1, intercept = 0) => {
    const scale = 255;
    return [
      clamp(r * slope + intercept * scale),
      clamp(g * slope + intercept * scale),
      clamp(b * slope + intercept * scale),
    ];
  };

  const brightness = (rgb, value = 1) => linear(rgb, value);
  const contrast = (rgb, value = 1) => linear(rgb, value, -0.5 * value + 0.5);

  const invert = ([r, g, b], value = 1) => {
    const nr = (value + r / 255 * (1 - 2 * value)) * 255;
    const ng = (value + g / 255 * (1 - 2 * value)) * 255;
    const nb = (value + b / 255 * (1 - 2 * value)) * 255;
    return [clamp(nr), clamp(ng), clamp(nb)];
  };

  // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
  const rgbToHsl = (r, g, b) => {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 100, s: s * 100, l: l * 100 };
  };

  const applyFilters = (rgb, [inv, sep, sat, hue, bri, con]) => {
    let color = [...rgb];
    color = invert(color, inv / 100);
    color = sepia(color, sep / 100);
    color = saturate(color, sat / 100);
    color = hueRotate(color, hue * 3.6);
    color = brightness(color, bri / 100);
    color = contrast(color, con / 100);
    return color;
  };

  const lossFn = (targetRgb, filters) => {
    const resultRgb = applyFilters([0, 0, 0], filters);
    const targetHsl = rgbToHsl(...targetRgb);
    const resultHsl = rgbToHsl(...resultRgb);
    return (
      Math.abs(resultRgb[0] - targetRgb[0]) +
      Math.abs(resultRgb[1] - targetRgb[1]) +
      Math.abs(resultRgb[2] - targetRgb[2]) +
      Math.abs(resultHsl.h - targetHsl.h) +
      Math.abs(resultHsl.s - targetHsl.s) +
      Math.abs(resultHsl.l - targetHsl.l)
    );
  };

  const fix = (value, idx) => {
    let max = 100;
    if (idx === 2) max = 7500;                  // saturate
    else if (idx === 4 || idx === 5) max = 200; // brightness, contrast
    if (idx === 3) { // hue-rotate
      if (value > max) return value % max;
      if (value < 0) return max + (value % max);
      return value;
    }
    return Math.max(0, Math.min(max, value));
  };

  const spsa = (targetRgb, A, a, c, initial, iters) => {
    const alpha = 1;
    const gamma = 1 / 6;
    let values = [...initial];
    let best = [...values];
    let bestLoss = Infinity;

    for (let k = 0; k < iters; k++) {
      const ck = c / Math.pow(k + 1, gamma);
      const deltas = Array(6).fill().map(() => (Math.random() > 0.5 ? 1 : -1));
      const highArgs = values.map((v, i) => v + ck * deltas[i]);
      const lowArgs = values.map((v, i) => v - ck * deltas[i]);
      const lossDiff = lossFn(targetRgb, highArgs) - lossFn(targetRgb, lowArgs);

      values = values.map((v, i) => {
        const g = (lossDiff / (2 * ck)) * deltas[i];
        const ak = a[i] / Math.pow(A + k + 1, alpha);
        return fix(v - ak * g, i);
      });

      const loss = lossFn(targetRgb, values);
      if (loss < bestLoss) {
        best = [...values];
        bestLoss = loss;
      }
    }
    return { values: best, loss: bestLoss };
  };

  // Threshold for acceptable color loss. This value determines when the SPSA algorithm stops early.
  // A loss below this value is considered visually indistinguishable for most use cases.
  // The value 25 was determined empirically to balance performance and color accuracy.
  const ACCEPTABLE_COLOR_LOSS = 25;

  const solveWide = (targetRgb) => {
    const A = 5;
    const c = 15;
    const a = [60, 180, 18000, 600, 1.2, 1.2];
    let best = { loss: Infinity, values: null };
    for (let i = 0; best.loss > ACCEPTABLE_COLOR_LOSS && i < 3; i++) {
      const initial = [50, 20, 3750, 50, 100, 100];
      const result = spsa(targetRgb, A, a, c, initial, 1000);
      if (result.loss < best.loss) best = result;
    }
    return best;
  };

  const solveNarrow = (targetRgb, wideResult) => {
    const A = wideResult.loss;
    const c = 2;
    const A1 = A + 1;
    const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
    return spsa(targetRgb, A, a, c, wideResult.values, 500);
  };

  const cssFilterString = (filters) => {
    const [inv, sep, sat, hue, bri, con] = filters.map(Math.round);
    const hueDeg = Math.round(hue * 3.6);
    return `filter: invert(${inv}%) sepia(${sep}%) saturate(${sat}%) hue-rotate(${hueDeg}deg) brightness(${bri}%) contrast(${con}%);`;
  };

  const solveColor = (targetRgb) => {
    const wide = solveWide(targetRgb);
    const narrow = solveNarrow(targetRgb, wide);
    return {
      values: narrow.values,
      loss: narrow.loss,
      filter: cssFilterString(narrow.values),
    };
  };

  // Reuse a single canvas / context to avoid memory leaks
  const colorParseCanvas = document.createElement('canvas');
  colorParseCanvas.width = 1;
  colorParseCanvas.height = 1;
  const colorParseContext = colorParseCanvas.getContext('2d');
  
  const toRGBArray = (cssColor) => {
    colorParseContext.fillStyle = cssColor;
    colorParseContext.fillRect(0, 0, 1, 1);

    // The `getImageData().data` returns a Uint8ClampedArray with 4 values per pixel (RGBA). 
    // also see: https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData/data
    const rgba = colorParseContext.getImageData(0, 0, 1, 1).data;
    return Array.from(rgba.slice(0, 3));
  };

  const dynamicStyleId = 'dynamic-color-invert-style';

  function applyDynamicColorInvert() {
    const textColor = getComputedStyle(document.body).getPropertyValue('--text-color');
    if (textColor && textColor.length > 0) {
      const rgb = toRGBArray(textColor);
      const result = solveColor(rgb);
      const filter = result.filter;

      const existingStyle = document.getElementById(dynamicStyleId);
      if (existingStyle) {
        existingStyle.textContent = `.color-invert {${filter}}`;
      } else {
        const style = document.createElement('style');
        style.id = dynamicStyleId;
        style.textContent = `.color-invert {${filter}}`;
        document.head.appendChild(style);
      }
    }
  }
</script></head><body><header class="header"><nav class="nav"><div class="logo"><span onclick="window.location.href='/index'" title="回声">« 回声</span></div></nav></header><div id="grid-wrapper" style="grid-template-areas: 'article toc';" data-base-url="/"><nav id="toc" class="sticky-nav mobile-sticky-nav"><div id="theme-options"><!-- Copyright (c) 2025 Kodama Project. All rights reserved. -->
<!-- Released under the Apache-2.0 license as described in the file LICENSE. -->
<!-- Authors: Kokic (@kokic)  -->
<!-- Inspired by Pink Floyd - The Dark Side of the Moon -->

<style>
  body:has(input[value="moon"]:checked) {
    --hover-primary-color: 181, 140, 114;

    --text-color: rgb(32, 28, 48);
    --toc-link-color: #555;
    --background-color: rgb(255, 238, 228);

    --hover-color-block: rgba(var(--hover-primary-color), 0.1);
    --hover-color-link: rgba(var(--hover-primary-color), 0.2);

    --link-color: rgb(227, 66, 114);
    --slug-color: rgb(184, 170, 161);
    --logo-color: #666;
    --logo-hover-color: #aaa;
    --span-taxon-color: black;
    --article-taxon-color: #888;
    --mark-color: rgb(255, 255, 151);
    --em-color: rgb(220, 121, 113);
  }

  @media (prefers-color-scheme: dark) {
    body:has(input[value="moon"]:checked) {
      --hover-primary-color: 196, 136, 193;

      --text-color: rgb(187 176 169);
      --toc-link-color: rgb(187 176 169);
      --background-color: rgb(32, 28, 48);

      --background-color-pre: rgba(100, 100, 100, 0.2);
      --background-color-code: rgba(150, 150, 150, 0.2);

      --hover-color-block: rgba(var(--hover-primary-color), 0.06);
      --hover-color-link: rgba(var(--hover-primary-color), 0.2);
      --target-color: rgb(255, 255, 151);

      --link-color: rgb(255, 128, 165);
      --slug-color: #aeaeae;
      --logo-color: #999;
      --logo-hover-color: #eee;
      --span-taxon-color: rgb(236, 230, 226);
      --em-color: rgb(255, 219, 230);

      .block:has(.block:hover) {
        background-color: var(--background-color);
      }
    }
  }

  body:has(input[value="moon-light"]:checked) {
    --hover-primary-color: 181, 140, 114;

    --text-color: rgb(32, 28, 48);
    --toc-link-color: #555;
    --background-color: rgb(255, 238, 228);

    --hover-color-block: rgba(var(--hover-primary-color), 0.1);
    --hover-color-link: rgba(var(--hover-primary-color), 0.2);

    --link-color: rgb(227, 66, 114);
    --slug-color: rgb(184, 170, 161);
    --logo-color: #666;
    --logo-hover-color: #aaa;
    --span-taxon-color: black;
    --article-taxon-color: #888;
    --mark-color: rgb(255, 255, 151);
    --em-color: rgb(220, 121, 113);
  }

  body:has(input[value="moon-dark"]:checked) {
    --hover-primary-color: 196, 136, 193;

    --text-color: rgb(187 176 169);
    --toc-link-color: rgb(187 176 169);
    --background-color: rgb(32, 28, 48);

    --background-color-pre: rgba(100, 100, 100, 0.2);
    --background-color-code: rgba(150, 150, 150, 0.2);

    --hover-color-block: rgba(var(--hover-primary-color), 0.06);
    --hover-color-link: rgba(var(--hover-primary-color), 0.2);
    --target-color: rgb(255, 255, 151);

    --link-color: rgb(255, 128, 165);
    --slug-color: #aeaeae;
    --logo-color: #999;
    --logo-hover-color: #eee;
    --span-taxon-color: rgb(236, 230, 226);
    --em-color: rgb(255, 219, 230);

    .block:has(.block:hover) {
      background-color: var(--background-color);
    }
  }
</style>

<theme-option name="moon">朔望</theme-option>
<theme-option name="moon-light">望月</theme-option>
<theme-option name="moon-dark">朔月</theme-option><!-- Copyright (c) 2025 Kodama Project. All rights reserved. -->
<!-- Released under the Apache-2.0 license as described in the file LICENSE. -->
<!-- Authors: Kokic (@kokic) -->
<!-- Inspired by https://www.forester-notes.org/ -->

<style>
  body:has(input[value="default"]:checked) {
    --text-color: black;
    --toc-link-color: #555;
    --background-color: white;

    --background-color-pre: rgba(0, 100, 100, 0.04);
    --background-color-code: rgba(0, 100, 100, 0.04);

    --hover-color-block: rgba(0, 100, 255, 0.04);
    --hover-color-link: rgba(0, 100, 255, 0.1);
    --target-color: rgb(67, 92, 255);

    --link-color: black;
    --slug-color: gray;
    --logo-color: #666;
    --logo-hover-color: #aaa;
    --span-taxon-color: #444;
    --article-taxon-color: #888;
    --mark-color: rgb(255, 255, 151);
  }

  @media (prefers-color-scheme: dark) {
    body:has(input[value="default"]:checked) {
      --text-color: white;
      --toc-link-color: white;
      --background-color: #2f2f2f;

      --background-color-pre: rgba(100, 100, 100, 0.2);
      --background-color-code: rgba(150, 150, 150, 0.2);

      --hover-color-block: rgba(100, 162, 255, 0.06);
      --hover-color-link: rgba(100, 162, 255, 0.2);
      --target-color: rgb(255, 255, 151);

      --link-color: white;
      --slug-color: #aeaeae;
      --logo-color: #999;
      --logo-hover-color: #eee;
      --span-taxon-color: #bbb;
    }
  }
</style>

<theme-option name="default">default</theme-option><!-- Copyright (c) 2025 Kodama Project. All rights reserved. -->
<!-- Released under the Apache-2.0 license as described in the file LICENSE. -->
<!-- Authors: Kokic (@kokic) -->
<!-- Inspired by https://github.com/zenbones-theme/zenbones.nvim - zenwritten -->

<style>
  body:has(input[value="zen"]:checked) {
    --hover-primary-color: 229, 229, 229;
    --link-primary-color: 115, 80, 87;

    --text-color: rgb(20, 22, 27);
    --toc-link-color: #555;
    --background-color: rgb(238, 238, 238);

    --background-color-pre: rgba(0, 100, 100, 0.04);
    --background-color-code: rgba(0, 100, 100, 0.04);

    --hover-color-block: rgba(var(--hover-primary-color));
    --hover-color-link: rgba(201, 201, 201);
    --target-color: rgb(255, 255, 151);

    --link-color: rgb(var(--link-primary-color));
    --slug-color: rgb(99, 99, 99);
    --logo-color: #999;
    --logo-hover-color: #666;
    --span-taxon-color: rgb(var(--link-primary-color));
    --em-color: rgb(53, 53, 53);

    .block:has(.block:hover) {
      background-color: var(--background-color);
    }
  }

  @media (prefers-color-scheme: dark) {
    body:has(input[value="zen"]:checked) {
      --hover-primary-color: 34, 34, 34;
      --link-primary-color: 150, 150, 150;

      --text-color: rgb(222, 223, 231);
      --toc-link-color: #555;
      --background-color: rgb(25, 25, 25);

      --background-color-pre: rgba(0, 100, 100, 0.04);
      --background-color-code: rgba(0, 100, 100, 0.04);

      --hover-color-block: rgba(var(--hover-primary-color));
      --hover-color-link: rgb(64, 64, 64);
      --target-color: rgb(255, 255, 151);

      --link-color: rgb(var(--link-primary-color));
      --slug-color: rgb(99, 99, 99);
      --logo-color: #999;
      --logo-hover-color: #eee;
      --span-taxon-color: rgb(var(--link-primary-color));
      --em-color: rgb(139, 139, 139);
    }
  }

  body:has(input[value="zen-light"]:checked) {
    --hover-primary-color: 229, 229, 229;
    --link-primary-color: 115, 80, 87;

    --text-color: rgb(20, 22, 27);
    --toc-link-color: #555;
    --background-color: rgb(238, 238, 238);

    --background-color-pre: rgba(0, 100, 100, 0.04);
    --background-color-code: rgba(0, 100, 100, 0.04);

    --hover-color-block: rgba(var(--hover-primary-color));
    --hover-color-link: rgba(201, 201, 201, 0.8);
    --target-color: rgb(255, 255, 151);

    --link-color: rgb(var(--link-primary-color));
    --slug-color: rgb(99, 99, 99);
    --logo-color: #999;
    --logo-hover-color: #666;
    --span-taxon-color: rgb(var(--link-primary-color));
    --em-color: rgb(53, 53, 53);

    .block:has(.block:hover) {
      background-color: var(--background-color);
    }
  }

  body:has(input[value="zen-dark"]:checked) {
    --hover-primary-color: 34, 34, 34;
    --link-primary-color: 150, 150, 150;

    --text-color: rgb(222, 223, 231);
    --toc-link-color: #555;
    --background-color: rgb(25, 25, 25);

    --background-color-pre: rgba(0, 100, 100, 0.04);
    --background-color-code: rgba(0, 100, 100, 0.04);

    --hover-color-block: rgba(var(--hover-primary-color));
    --hover-color-link: rgba(64, 64, 64, 0.3);
    --target-color: rgb(255, 255, 151);

    --link-color: rgb(var(--link-primary-color));
    --slug-color: rgb(99, 99, 99);
    --logo-color: #999;
    --logo-hover-color: #eee;
    --span-taxon-color: rgb(var(--link-primary-color));
    --em-color: rgb(139, 139, 139);

    .block:has(.block:hover) {
      background-color: var(--background-color);
    }
  }
</style>

<theme-option name="zen-light">zen light</theme-option>
<theme-option name="zen-dark">zen dark</theme-option>
<theme-option name="zen">zen</theme-option></div></nav>

<article><section class="block" data-taxon=""><details open><summary id="pearls"><header><h1><span class="taxon"></span>Pearls <a class="slug" href="/pearls">[pearls]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p>Short, elegant, and enlightening proof that illustrate important principles or techniques.</p>
</details></section><footer><section class="block"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="Exegesis"><details ><summary id="CN2A"><header><h1><span class="taxon">Exegesis. </span>Cauchy–Aczél 论证 <a class="slug" href="/CN2A">[CN2A]</a></h1><div class="metadata"><ul><li class="meta-item">June 25, 2021</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link local"><a href="/pearls" title="Pearls [pearls]">Pearls</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>Cauchy–Aczél 论证是 <span class="link local"><a href="/SL2A" title="次线性归纳 [SL2A]">次线性归纳</a></span> 的一个直接应用. 凭此能够同时证明以下四个不等式.</p>
<p><section class="block" data-taxon="Theorem"><details ><summary id="CN2B"><header><h1><span class="taxon">Theorem. </span>Cauchy 不等式 <a class="slug" href="/CN2B">[CN2B]</a></h1><div class="metadata"><ul><li class="meta-item">June 25, 2021</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link external"><a href="https://mathworld.wolfram.com/CauchysInequality.html" title="Cauchy’s Inequality [https://mathworld.wolfram.com/CauchysInequality.html]">Cauchy’s Inequality</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>$$
\Big(\sum_{k=1}^na_k^2\Big) \Big(\sum_{k=1}^nb_k^2\Big) \spaces\ge \Big(\sum_{k=1}^na_kb_k\Big)^2
$$</p>
</details></section>
<section class="block" data-taxon="Lemma"><details ><summary id="CN2C"><header><h1><span class="taxon">Lemma. </span>Titu 引理 <a class="slug" href="/CN2C">[CN2C]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>Titu 引理又名 <span class="link external"><a href="https://handwiki.org/wiki/Sedrakyan%27s_inequality" title="Sedrakyan 不等式 [https://handwiki.org/wiki/Sedrakyan%27s_inequality]">Sedrakyan 不等式</a></span>、Bergström 不等式、<span class="link external"><a href="https://artofproblemsolving.com/wiki/index.php/Cauchy-Schwarz_Inequality" title="Engel 形式 [https://artofproblemsolving.com/wiki/index.php/Cauchy-Schwarz_Inequality]">Engel 形式</a></span>. 在 <span class="link local"><a href="/CN2B" title="Cauchy 不等式 [CN2B]">Cauchy 不等式</a></span> 中实行替换 $a_k \mapsto \frac{x_k}{\sqrt\ell_k}$, $b_k \mapsto \sqrt\ell_k$, 随后移项即得</p>
<p>$$
\sum_{k=1}^n\dfrac{x_k^2}{\ell_k} 
\spaces\ge \Big(\sum_{k=1}^nx_k\Big)^2 \Big({\sum_{k=1}^n{\ell_k}}\Big)^{-1} 
$$</p>
</details></section>
<section class="block" data-taxon="Theorem"><details ><summary id="CN2D"><header><h1><span class="taxon">Theorem. </span>Aczél 不等式 <a class="slug" href="/CN2D">[CN2D]</a></h1><div class="metadata"><ul><li class="meta-item">June 25, 2021</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>设 $\{a_i\}_{1\le i \le n}$ 满足 $a_1^2 \ge a_2^2 + a_3^2 + \cdots + a_n^2$, $\{b_i\}_{1 \le i \le n}$ 满足 $b_1^2 \ge b_2^2 + b_3^2 + \cdots + b_n^2$ 则</p>
<p>$$
\Big(a_1b_1 - \sum_{k=2}^na_kb_k\Big)^2 \spaces\ge \Big(a_1^2 - \sum_{k=2}^na_k^2\Big) \Big(b_1^2 - \sum_{k=2}^nb_k^2\Big)
$$</p>
</details></section>
<section class="block" data-taxon="Theorem"><details ><summary id="CN2E"><header><h1><span class="taxon">Theorem. </span>Aczél 不等式 Engel 形式 <a class="slug" href="/CN2E">[CN2E]</a></h1><div class="metadata"><ul><li class="meta-item">June 25, 2021</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>与 <span class="link local"><a href="/CN2C" title="Titu 引理 [CN2C]">Titu 引理</a></span> 具有 <span class="link local"><a href="/CN2B" title="Cauchy 不等式 [CN2B]">Engel 形式</a></span> 类似, Aczél 不等式也有相应的 Engel 形式. 实行替换 $a_k \mapsto \frac{x_k}{\sqrt\ell_k}$, $b_k \mapsto \sqrt\ell_k$, 得</p>
<p>$$
\Big(x_1^2 - \sum_{k=2}^nx_k\Big)^2 \Big(\ell_1 - {\sum_{k=2}^n{\ell_k}}\Big)^{-1}
\spaces\ge \frac{x_1^2}{\ell_1} - \sum_{k=2}^n\dfrac{x_k^2}{\ell_k} 
$$</p>
</details></section>
<section class="block" data-taxon="Lemma"><details ><summary id="SL2A"><header><h1><span class="taxon">Lemma. </span>次线性归纳 <a class="slug" href="/SL2A">[SL2A]</a></h1><div class="metadata"><ul><li class="meta-item">June 25, 2021</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>如果 $f$ 满足 $\eta: f(x) + f(y) \ge f(x+y)$, 则成立</p>
<p>$$ \eta_* \spaces: \sum_{i} f(x_i) \spaces\ge f\Big(\sum_i x_i\Big) $$</p>
<p>证明只需反复使用已知条件即可. 这同时意味着 $\eta, \eta_*$ 等价. 另一方面, 在 $\eta$ 中置 $x \mapsto x-y$, 就有 $f(x-y) + f(y) \ge f(x)$, 也即 $\varphi: f(x-y) \ge f(x) - f(y)$. 类似的可知</p>
<p>$$
\varphi_* \spaces: f(x - \sum_i f(x_i)) \spaces\ge f(x) - \sum_i f(x_i)
$$</p>
<p>故此 $\eta \iff \eta_* \iff \varphi_* \iff \varphi$.</p>
</details></section></p>
<p>在 <span class="link local"><a href="/SL2A" title="次线性归纳 [SL2A]">次线性归纳</a></span> 中取 $f(x, \ell) = \frac{x^2}{\ell}$, 于是 <span class="link local"><a href="/CN2C" title="Titu 引理 [CN2C]">Titu 引理</a></span> $\iff$ <span class="link local"><a href="/CN2E" title="Aczél 不等式 Engel 形式 [CN2E]">Aczél 不等式 Engel 形式</a></span>, 又因为 <span class="link local"><a href="/CN2B" title="Cauchy 不等式 [CN2B]">Cauchy 不等式</a></span> 等价于 <span class="link local"><a href="/CN2C" title="Titu 引理 [CN2C]">Titu 引理</a></span>, <span class="link local"><a href="/CN2D" title="Aczél 不等式 [CN2D]">Aczél 不等式</a></span> 等价于 <span class="link local"><a href="/CN2E" title="Aczél 不等式 Engel 形式 [CN2E]">Aczél 不等式 Engel 形式</a></span>. 于是只需证明 <span class="link local"><a href="/CN2B" title="Cauchy 不等式 [CN2B]">Cauchy 不等式</a></span> 中 $n=2$ 的情况, 现在做差</p>
<p>$$ (a_1^2 + a_2^2)(b_1^2 + b_2^2) - (a_1b_1 + a_2b_2)^2 \spaces= (a_1b_2 - a_2b_1)^2 $$</p>
<p>右侧非负, 从而证毕. 读者也应留意到, 尝试直接说明 <span class="link local"><a href="/CN2B" title="Cauchy 不等式 [CN2B]">Cauchy 不等式</a></span> 和 <span class="link local"><a href="/CN2D" title="Aczél 不等式 [CN2D]">Aczél 不等式</a></span> 等价往往不容易看出, 而沿着下面的路径就要轻松的多.</p>
<p>$$
\begin{CD}
\text{Cauchy} @&gt;\text{Engel}&gt;&gt; \text{Titu} \\
@. @VV\text{次线性归纳}V \\
\text{Aczél} @&lt;&lt;\text{Engel}&lt; \text{Aczél--Engel}
\end{CD}
$$</p>
</details></section><section class="block" data-taxon="Exegesis"><details ><summary id="YL2A"><header><h1><span class="taxon">Exegesis. </span>Young 引理 <a class="slug" href="/YL2A">[YL2A]</a></h1><div class="metadata"><ul><li class="meta-item">May 14, 2019</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link local"><a href="/pearls" title="Pearls [pearls]">Pearls</a></span></li></ul></div></header></summary>
<p><span class="link local"><a href="/YL3A" title="Young 不等式 [YL3A]">Young 不等式</a></span> 有许多风格迥然的证明, 最常见的办法可能是使用 <span class="link local"><a href="/trees/YL4A" title=" [trees/YL4A]">定积分</a></span>.</p>
<p>我们在此介绍一种充分利用对数线性化 $\log x \le x -1 $ 的方法, 即 <span class="link local"><a href="/YL2B" title="Young 引理 [YL2B]">Young 引理</a></span>.
并展示 Young 不等式与其他常见不等式如何作为此结果的直接推论.</p>
<p><section class="block" data-taxon="Lemma"><details ><summary id="YL2B"><header><h1><span class="taxon">Lemma. </span>Young 引理 <a class="slug" href="/YL2B">[YL2B]</a></h1><div class="metadata"><ul><li class="meta-item">May 14, 2019</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>对数函数 $\log$ 的独特性质体现在 $\log a^b = b\log a$ 和 $\log a b = \log a + \log b$. 另一方面, 我们知道对于非负的 $X,Y$, 不等式 $X \le Y$ 等价于 $\log \frac XY \le 0$. 如果我们希望充分利用这三点, 那么就可以试着去考虑</p>
<p>$$ \log \frac{f_1^{p_1}f_2^{p_2}}{g^{p_1+p_2}} \spaces= p_1\log\frac{f_1}g \spaces+ p_2\log\frac{f_2}g $$</p>
<p>现在对右侧使用对数的线性化, 得到</p>
<p>$$ 
\begin{aligned}
\log \frac{f_1^{p_1}f_2^{p_2}}{g^{p_1+p_2}} 
&amp;\spaces\le p_1\Big(\frac{f_1}g-1\Big) \spaces+ p_2\Big(\frac{f_2}g-1\Big) \\
&amp;\spaces= g^{-1}(p_1f_1+p_2f_2) - (p_1+p_2)
\end{aligned}
$$</p>
<p>我们当然希望 $\log\frac\Box\Box \le 0$. 这就是说, 如果有关于加法和乘法的条件</p>
<p>$$
p_1f_1+p_2f_2 \spaces\le (p_1+p_2)g
$$</p>
<p>那么可以推出 $f_1^{p_1}f_2^{p_2} \le g^{p_1+p_2}$ 这样一个指数上的结果. 有时我们也写成</p>
<p>$$
p_1 \log f_1 + p_2 \log f_2 \spaces\le (p_1+p_2)\log g 
$$</p>
<p>用完全相同的步骤, 也可以证明任意多个 $p_i$ 和 $f_i$ 时的情况.</p>
</details></section>
<section class="block" data-taxon="Corollary"><details ><summary id="YL3A"><header><h1><span class="taxon">Corollary. </span>Young 不等式 <a class="slug" href="/YL3A">[YL3A]</a></h1><div class="metadata"><ul><li class="meta-item">May 14, 2019</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>我们在 <span class="link local"><a href="/YL2B" title="Young 引理 [YL2B]">此处</a></span> 的条件中再添一笔 $p_1+p_2=1$, 然后替换 $(p_1,p_2)$ 为 $(\frac1p, \frac1q)$, 替换 $(f_1,f_2)$ 为 $(a,b)$, 这样就有</p>
<p>$$ (p_1f_1 + p_2f_2 \space =) \quad \frac ap + \frac bq \quad (= \space g) $$</p>
<p>立刻得出 $a^{\frac1p}b^{\frac1q} \le \frac ap + \frac bq$, 当且仅当 $a=b$ 取得等号.</p>
</details></section>
<section class="block" data-taxon="Corollary"><details ><summary id="YL3B"><header><h1><span class="taxon">Corollary. </span>Bernoulli 不等式 <a class="slug" href="/YL3B">[YL3B]</a></h1><div class="metadata"><ul><li class="meta-item">May 15, 2019</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>Bernoulli 不等式是说 $(1+x)^n \ge 1+nx$. 这里 $n \ge 1$, $x \ge -1$. 等价地, 我们来证明</p>
<p>$$ x^n + n-1 \spaces\ge nx, \qquad (n \ge 1, x \ge 0) $$</p>
<p>在 <span class="link local"><a href="/YL2B" title="Young 引理 [YL2B]">Young 引理</a></span> 的条件中令 $p_i = \frac1n$, $(f_i)_{1\le i \le n}=(x^n, 1, 1, \cdots)$, $g = (x^n + n-1)n^{-1}$, 这个时候以下条件显然成立</p>
<p>$$
\frac1n x^n + \underbrace{\frac1n + \frac1n + \cdots + \frac1n}_{n-1 ~ \text{times}} \spaces= \frac{x^n + n-1}n
$$</p>
<p>于是可以得到 $(x^n)^{n^{-1}} \le (x^n + n-1)n^{-1}$. $\quad\Box$</p>
</details></section>
<section class="block" data-taxon="Corollary"><details ><summary id="YL3C"><header><h1><span class="taxon">Corollary. </span>加权算术平均–几何平均不等式 <a class="slug" href="/YL3C">[YL3C]</a></h1><div class="metadata"><ul><li class="meta-item">May 15, 2019</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>我们要证的结果可以写成下面的样子</p>
<p>$$
\Big(\prod_{i \in S}z_i^{w_i}\Big)^{(\sum_{i \in S}w_{i})^{-1}}
\spaces\le 
\Big(\sum_{i \in S}w_iz_i\Big) \Big(\sum_{i \in S}w_i\Big)^{-1}
$$</p>
<p>实际上可以利用对数的线性化对这个定理给出一个直接的证明, 不过这并非本文的重点. 我们在此处更关心如何将这些表达式调整为适合使用 <span class="link local"><a href="/YL2B" title="Young 引理 [YL2B]">此引理</a></span> 的形式. 先引入一些记号, 用 $\Sigma_w$ 表示 $\sum_{i \in S}w_{i}$, 用 $\omega_i$ 表示 $w_i\Sigma_w^{-1}$. 这样目标就变成了</p>
<p>$$ \prod_{i \in S}z_i^{\omega_i} \spaces\le \sum_{i \in S}\omega_iz_i $$</p>
<p>如果把这里的 $\omega_i$ 看作 $p_i$, $z_i$ 看作 $f_i$, $\sum_{i \in S}\omega_iz_i$ 看作 $g$. 那我们只要验证下面这件事</p>
<p>$$
\sum_{i \in S}\omega_iz_i \spaces\le \sum_{i \in S}\omega_iz_i
$$</p>
<p>而这应该是很容易的. $\quad\Box$</p>
</details></section></p>
</details></section><section class="block" data-taxon=""><details ><summary id="daily-surf-CAN0"><header><h1><span class="taxon"></span>代数数可数 <a class="slug" href="/daily-surf/CAN0">[CAN0]</a></h1><div class="metadata"><ul><li class="meta-item">July 25, 2020</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link local"><a href="/pearls" title="Pearls [pearls]">Pearls</a></span></li></ul></div></header></summary>
<p>$\gdef\Q{\mathbf{Q}}$
$\gdef\N{\mathbf{N}}$</p>
<p>代数数即 $\Q$-系数首一多项式的根, 容易看出这也是任意整系数多项式方程的根. 1874 年, Cantor 在文章 <span class="link external"><a href="https://en.wikipedia.org/wiki/Cantor's_first_set_theory_article" title="“Ueber eine Eigenschaft des Inbegriffes aller reellen algebraischen Zahlen” [https://en.wikipedia.org/wiki/Cantor's_first_set_theory_article]">“Ueber eine Eigenschaft des Inbegriffes aller reellen algebraischen Zahlen”</a></span> 中运用 <span class="link local"><a href="/daily-surf/CAN2" title="多项式高度 [daily-surf/CAN2]">多项式高度</a></span> 的概念证明了实代数数的可数性.</p>
<p><section class="block" data-taxon="Exegesis"><details ><summary id="daily-surf-CAN1"><header><h1><span class="taxon">Exegesis. </span>Cantor 的思路 <a class="slug" href="/daily-surf/CAN1">[CAN1]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p>$\gdef\N{\mathbf{N}}$
$\gdef\C{\mathbf{C}}$</p>
<p>Cantor 的思路很大程度上可以视为一种数论策略. 他首先想的是对多项式 $P$ 定义一个恰当的 <span class="link local"><a href="/daily-surf/CAN2" title="多项式高度 [daily-surf/CAN2]">高度概念</a></span> $H(P) \in \N$, 使得一旦我们固定了正整数 $h$, 则只会存在有限个多项式 $P$ 满足 $H(P) = h$, 且任意多项式都能被某个高度覆盖. 即用高度分类全体多项式的同时又控制了多项式的复杂程度. 随后, 代数基本定理保证给定 $n$ 次多项式, 其根在 $\C$ 上至多只有 $n$ 个, 全体代数数便可以写为可数个有限集的并, 如此证得.</p>
</details></section>
<section class="block" data-taxon="Definition"><details ><summary id="daily-surf-CAN2"><header><h1><span class="taxon">Definition. </span>多项式高度 <a class="slug" href="/daily-surf/CAN2">[CAN2]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\N{\mathbf{N}}$</p>
<p>遵循着 <span class="link local"><a href="/daily-surf/CAN1" title="Cantor 的思路 [daily-surf/CAN1]">这种思路</a></span>, Cantor 给出的高度定义为:</p>
<p>$$
H(P) \spaces= \deg P - 1 + \sum_{0 \le i \le n} |a_i|
$$</p>
<p>反过来, 任给一个整系数多项式 $P$, 我们都能计算他的 $H(P) \in \N$.</p>
</details></section>
<section class="block" data-taxon="Lemma"><details ><summary id="daily-surf-CAN3"><header><h1><span class="taxon">Lemma. </span>定高多项式集有限 <a class="slug" href="/daily-surf/CAN3">[CAN3]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p>$\gdef\N{\mathbf{N}}$
$\gdef\Z{\mathbf{Z}}$</p>
<p>固定 $h \in \N$, 则集合 $P_h = \{ P \in \Z[x] : H(P) = h \}$ 有限. 为了证明这件事, 注意到此时多项式的次数最多是 $h$, 因为至少有一个非零整系数 $a_i$ 使得 $|a_i| \ge 1$. 另一方面, 每个 $a_i$ 也满足 $|a_i| \le h$, 因此一个多项式的所有信息都被正整数 $h$ 控制, 故 $P_h$ 有限.</p>
</details></section>
<section class="block" data-taxon="Lemma"><details ><summary id="daily-surf-CAN4"><header><h1><span class="taxon">Lemma. </span>定高多项式根集有限 <a class="slug" href="/daily-surf/CAN4">[CAN4]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p>$\gdef\C{\mathbf{C}}$</p>
<p>固定 $h \in \N$, 集合 $R_h = \{ z \in \C : P(z) = 0, P \in P_h \}$ 有限. 对 $P \in P_h$ 处每一个固定的 $P$ 使用代数基本定理, 便可得到此时的 $z$ 也只有有限多个.</p>
</details></section>
<section class="block" data-taxon="Theorem"><details ><summary id="daily-surf-CAN5"><header><h1><span class="taxon">Theorem. </span>代数数只有可数多个 <a class="slug" href="/daily-surf/CAN5">[CAN5]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\A{\mathbb{A}}$
$\gdef\N{\mathbf{N}}$</p>
<p>根据代数数域 $\A$ 的定义之一, 我们知道 $\A = \bigcup_{h \in \N} R_h$ 所以 $|\A| = |\N|$, 即可数.</p>
</details></section></p>
</details></section><section class="block" data-taxon="Example"><details ><summary id="daily-surf-CPSI"><header><h1><span class="taxon">Example. </span>循环幂和不等式 <a class="slug" href="/daily-surf/CPSI">[CPSI]</a></h1><div class="metadata"><ul><li class="meta-item">June 20, 2019</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link local"><a href="/pearls" title="Pearls [pearls]">Pearls</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>设 $0 &lt; x_1, x_2, \cdots, x_n &lt; 1$. 试证</p>
<p>$$
x_1^{x_2} + x_2^{x_3} + \cdots + x_n^{x_1} &gt; 1
$$</p>
<p>利用 <span class="link local"><a href="/YL3B" title="Bernoulli 不等式 [YL3B]">Bernoulli 不等式</a></span>, $(1+\frac{x}{y})^{\frac{1}{x}} \geqslant 1+\frac{1}{y} &gt; \frac{1}{y}$ 得到 $1+\frac{x}{y} &gt; \frac{1}{y^x}$, 即 $y^x &gt; \frac{1}{1+\frac{x}{y}}$.</p>
<p>$$
\begin{aligned}
x_1^{x_2} + x_2^{x_3} + \cdots + x_n^{x_1} 
&amp;\spaces&gt; \sum_{1 \leqslant i \leqslant n} \frac{1}{1+\frac{x_1}{x_{i+1}}} \\
&amp;\spaces&gt; \sum_{1 \leqslant i \leqslant n} \frac{x_{i+1}}{x_1 + x_2 + \cdots + x_n} \\
&amp;\spaces= 1
\end{aligned}
$$</p>
<p>此处 $i+1$ 按照 $\Z/n\Z$ 处理.</p>
</details></section><section class="block" data-taxon=""><details ><summary id="daily-surf-GF2A"><header><h1><span class="taxon"></span>生成函数系数 <a class="slug" href="/daily-surf/GF2A">[GF2A]</a></h1><div class="metadata"><ul><li class="meta-item">August 15, 2021</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link local"><a href="/pearls" title="Pearls [pearls]">Pearls</a></span></li></ul></div></header></summary>
<p>$\gdef\Z{\mathbf{Z}}$</p>
<p>设 $\frac1{(1-q)^3} = \sum_{u \ge 0} a_u q^u$, 求 $a_n$.</p>
<p>不难发现, <span class="link local"><a href="/daily-surf/GF2A" title="生成函数系数 [daily-surf/GF2A]">此处 $a_n$</a></span> 同时也是 $x_1+x_2+x_3 = n$
于 $\Z_{\ge 0}$ 上解的个数.
在 <span class="link local"><a href="/daily-surf/GF3A" title="特殊有理函数展开式的系数 [daily-surf/GF3A]">$(1-q)^{-n}$ 的系数</a></span> 中取 $n = 3$, 得到 $a_{u} = \frac{1}{2}(u + 2)(u + 1)$.</p>
</details></section><section class="block" data-taxon="Lemma"><details ><summary id="daily-surf-GF3A"><header><h1><span class="taxon">Lemma. </span>$\footnotesize (1-q)^{-m}$ 的系数 <a class="slug" href="/daily-surf/GF3A">[GF3A]</a></h1><div class="metadata"><ul><li class="meta-item">August 15, 2021</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link local"><a href="/pearls" title="Pearls [pearls]">Pearls</a></span></li></ul></div></header></summary>
<p>$\gdef\d{\operatorname{d}}$
$\gdef\spaces#1{~ #1 ~}$
$\gdef\quads#1{\quad #1 \quad}$</p>
<p>我们来证明</p>
<p>$$
\frac{1}{(1 - q)^{n}} 
\spaces= \sum_{u \geq 0}\binom{n + u - 1}{u}q^{u}
$$</p>
<p>对于 $(1-q)^{-m}$ 这类特殊的有理函数, 注意到
$((1-q)^{-1})' = (1 - q)^{- 2}$. 归纳地, 可以得到</p>
<p>$$
\frac{\d^{n}}{\d q^{n}}(1 - q)^{- 1} 
\spaces= \frac{n!}{(1 - q)^{n + 1}} 
\quads\Longrightarrow \frac{1}{(1 - q)^{n}} 
\spaces= \frac{1}{(n - 1)!} \cdot \frac{\d^{n - 1}}{dq^{n - 1}}(1 - q)^{- 1}
$$</p>
<p>另一方面, 我们知道几何级数满足
$\frac{1}{1 - q} = 1 + q + q^2 + \cdots = \sum_{u \geq 0}q^{u}$, 代入可得</p>
<p>$$
\frac{1}{(1 - q)^{n}} 
\spaces= \frac{1}{(n - 1)!} \cdot \frac{\d^{n - 1}}{\d q^{n - 1}}\sum_{u \geq 0}q^{u}
$$</p>
<p>现在我们再使用下面的观察</p>
<p>$$ 
\frac{\d^n}{\d x^n} x^m
\spaces=
\begin{cases}
  x^{m-n} \prod_{0 \le k \le n-1}(m-k) &amp; n \le m \\
  0 &amp; \text{otherwise} 
\end{cases}
$$</p>
<p>就可以算出 $\frac{\d^{n - 1}}{\d q^{n - 1}}\sum_{u \geq 0}q^{u}$ 这一部分</p>
<p>$$
\begin{aligned}
\frac{1}{(1 - q)^{n}} 
&amp;\spaces= \frac{1}{(n - 1)!} \cdot \sum_{u \geq n - 1}q^{u - (n - 1)}\prod_{0 \leq k \leq n - 2}(u - k) \\
&amp;\spaces= \frac{1}{(n - 1)!} \cdot \sum_{u \geq 0}q^{u}\prod_{0 \leq k \leq n - 2}(u + n - k - 1) \\
&amp;\spaces= \frac{1}{(n - 1)!} \cdot \sum_{u \geq 0}q^{u}(u + n - 1)(u + n - 2) \spaces\cdots (u + 1)
\end{aligned}
$$</p>
<p>$q^{u}$ 的系数从 $u = 0$ 开始, 则系数可再一次简化为组合数</p>
<p><figure><img src="/daily-surf/GF3B.svg" class="color-invert"/></figure></p>
<p>于是明所欲证.</p>
</details></section><section class="block" data-taxon=""><details ><summary id="daily-surf-euclid-step"><header><h1><span class="taxon"></span>辗转相除法步数估计 <a class="slug" href="/daily-surf/euclid-step">[euclid-step]</a></h1><div class="metadata"><ul><li class="meta-item">June 10, 2021</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link local"><a href="/pearls" title="Pearls [pearls]">Pearls</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>1844 年, 49 岁的法国数学家 <span class="link external"><a href="https://en.wikipedia.org/wiki/Gabriel_Lam%C3%A9" title="Gabriel Lamé [https://en.wikipedia.org/wiki/Gabriel_Lam%C3%A9]">Gabriel Lamé</a></span> 发现, 设 $a,b$ 两数辗转相除至余数为零所用步数为 $n$, 则</p>
<p>$$ n \spaces\le 1 + \log_\phi \min(a,b) $$</p>
<p>其中 $\phi = \frac{1+\sqrt5}{2}$ 为黄金分割. 当然, 这也给出用递归实现 $\gcd$ 函数的时间复杂度. 如今认为, 此结果标志着计算复杂度理论的开始.</p>
<p>我们首先来证明 $n\le\log_\phi\sqrt{5}\min(a,b)$.
不妨设 $a\gt b$, 于是有 $a=qb+r_1,r_{k-1}=q_kr_k+r_{k+1}$, 其中 $1\le k\le n-1$, 显然一定有 $r_n=0$.
还注意 $r_k$ 依次递减且有 $r_k-r_{k+1}\ge1$, 则 $r_{k-1}=q_kr_k+r_{k+1}\ge r_k+r_{k+1}$.
将下标取反 $(s_k=r_{n-k})$ 即 $s_{k+1}\ge s_k+s_{k-1}$. 故考虑 Fibonacci 数列 $F_n$, 知 $s_k\ge F_k$, 即 $b\ge F_n$, 又 $F_n \sim \frac{\phi^n}{\sqrt5}$, 证毕.</p>
<p>现在, 注意到此估计与待证估计之差为</p>
<p>$$
\begin{aligned}
\log_{\phi}\sqrt5-1 \
&amp;\spaces= \dfrac{\log\sqrt5}{\log\dfrac{1+\sqrt5}{2}}-1 \\ 
&amp;\spaces= \dfrac{1}{2}\cdot\dfrac{\log5}{\log(1+\sqrt5)-\log2}-1\\ 
&amp;\spaces\lt 2\cdot\dfrac{\log5}{\log5}-1 \\ 
&amp;\spaces= 1
\end{aligned}
$$</p>
<p>其中最后一个不等号是因为, 根据基本不等式 $1+\sqrt5 \ge 2\cdot5^{1/4}$, 于是</p>
<p>$$
\log(1+\sqrt5) - \log2 
\spaces\gt\log(2\cdot5^{1/4})-\log2 
\spaces=\tfrac{1}{4}\log5
$$</p>
<p>故 $n \le \log_{\phi}b+1$.</p>
</details></section><section class="block" data-taxon=""><details ><summary id="daily-surf-gaussian-integral"><header><h1><span class="taxon"></span>极坐标出现前人们怎样计算高斯积分 <a class="slug" href="/daily-surf/gaussian-integral">[gaussian-integral]</a></h1><div class="metadata"><ul><li class="meta-item">November 2, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link local"><a href="/pearls" title="Pearls [pearls]">Pearls</a></span></li></ul></div></header></summary>
<p>这一证明最早似乎来自 Michael Rozman. 除此之外 MSE 上也有极类似的回答, 见 <span class="link external"><a href="https://math.stackexchange.com/questions/390850/integrating-int-infty-0-e-x2-dx-using-feynmans-parametrization-trick" title="此处 [https://math.stackexchange.com/questions/390850/integrating-int-infty-0-e-x2-dx-using-feynmans-parametrization-trick]">此处</a></span>.</p>
<blockquote>
<p>M. Rozman, Evaluate Gaussian integral using differentiation under the integral sign, Course notes for Physics 2400 (UConn), Spring 2016.</p>
</blockquote>
<p>$\gdef\R{\mathbf{R}}$
$\gdef\spaces#1{~ #1 ~}$
$\gdef\d{\operatorname{d}}$</p>
<p>核心技巧来自一个函数 $F(t)$ 的构造. 对 $t \in \R$ 定义如下函数</p>
<p>$$
F(t) \spaces= \int_0^\infty \frac{e^{-t^2(1+x^2)}}{1+x^2} \d x
$$</p>
<p>容易验证 $F(t)$ 满足 $F(0)=\frac{\pi}{2}$, $F(\infty) = 0$, 以及最关键的</p>
<p>$$
F'(t) 
\spaces= \int_0^\infty -2te^{-t^2(1+x^2)} \d x 
\spaces= -2te^{-t^2} \int_0^\infty e^{-(tx)^2} \d x
$$</p>
<p>记高斯积分为 $I$. 这就有 $F'(t) = -2Ie^{-t^2}$, 此时再求 $F'(t)$ 于 $[0, \infty)$, 上的积分, 就能得到</p>
<p>$$
F(\infty)- F(0) \spaces= -2I \int_0^\infty e^{-t^2} \d t \spaces= -2I^2
$$</p>
<p>于是这给出 $I = \frac{\sqrt\pi}2$.</p>
</details></section><section class="block" data-taxon="Theorem"><details ><summary id="data-structure-deletion-contraction"><header><h1><span class="taxon">Theorem. </span>删除–收缩公式 <a class="slug" href="/data-structure/deletion-contraction">[deletion-contraction]</a></h1><div class="metadata"><ul><li class="meta-item">July 21, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link local"><a href="/pearls" title="Pearls [pearls]">Pearls</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\quads#1{\quad #1 \quad}$
$\gdef\without{\setminus}$</p>
<p>对于简单图 $G$, 其色多项式 $\pi(G)$ 成立如下关系</p>
<p>$$ \pi(G) \spaces= \pi(G \without e) \spaces- \pi(G / e), \quad \forall ~ e \in \text{Edge}(G) $$</p>
<p><section class="block" data-taxon="Proof"><details ><summary id="data-structure-deletion-contraction-pf"><header><h1><span class="taxon">Proof. </span> <a class="slug" href="/data-structure/deletion-contraction-pf">[deletion-contraction-pf]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\spaces#1{~ #1 ~}$
$\gdef\without{\setminus}$</p>
<p>$\gdef\str#1{{\footnotesize #1}}$
$\gdef\sstr#1{~{\footnotesize #1}~}$</p>
<p>假定边 $e$ 的两个端点分别为 $A,B$, 不难发现</p>
<p>$$
\begin{aligned} 
\pi(G \without e) 
&amp;\spaces= \pi(G \without e \sstr{中} A,B ~\str{同色的部分}) ~ + ~ \pi(G \without e \sstr{中} A,B ~\str{异色的部分}) \\
&amp;\spaces= \pi(G / e) ~ + ~ \pi(G)
\end{aligned}
$$</p>
<p>此处, $G \without e$ 是将 $G$ 的边 $e$ 删去, $G/e$ 是将 $e$ 两侧的顶点合并为一个.</p>
</details></section></p>
<p>这个结果可等价地叙述成连接的版本, 可称为 “连接–收缩公式”. 对于简单图 $G = (V, E)$</p>
<p>$$ \pi(G) \spaces= \pi(G + uv) \spaces+ \pi(G / uv), \quad \forall ~ uv \notin E $$</p>
<p>这里, $G+e$ 是指将 $e$ 两侧的顶点连接, $u v$ 是指顶点 $u, v$ 连接得到的边.</p>
</details></section><section class="block" data-taxon=""><details ><summary id="index"><header><h1><span class="taxon"></span>回声 <a class="slug" href="/index">[index]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p>本站点使用 <span class="link external"><a href="https://github.com/kokic/kodama" title="Kodama [https://github.com/kokic/kodama]">Kodama</a></span> 构建,
可在 <span class="link external"><a href="https://github.com/kokic/kokic.github.io" title="此处 [https://github.com/kokic/kokic.github.io]">此处</a></span> 查看网页源文件.
另有专栏 <span class="link local"><a href="/pearls" title="Pearls [pearls]">证明珠玑</a></span>.</p>
<p><section class="block" data-taxon=""><details ><summary id="mille-plateaux-index"><header><h1><span class="taxon"></span>千高原 <a class="slug" href="/mille-plateaux/index">[mille-plateaux]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p><section class="block" data-taxon=""><details ><summary id="mille-plateaux-rational-points"><header><h1><span class="taxon"></span> 平面曲线的有理点 <a class="slug" href="/mille-plateaux/rational-points">[rational-points]</a></h1><div class="metadata"><ul><li class="meta-item">December 26, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\ul#1{\underline{#1}}$
$\gdef\spaces#1{~ #1 ~}$
$\gdef\quads#1{\quad #1 \quad}$
$\gdef\eqq{\quads=}$
$\gdef\R{\mathbf{R}}$
$\gdef\Q{\mathbf{Q}}$</p>
<p><section class="block" data-taxon="Exegesis"><details ><summary id="mille-plateaux-canterbury"><header><h1><span class="taxon">Exegesis. </span>Canterbury 物语 <a class="slug" href="/mille-plateaux/canterbury">[canterbury]</a></h1><div class="metadata"><ul><li class="meta-item">December 26, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p><span class="link local"><a href="/mille-plateaux/canterbury-2A" title="古代物理学博士问题 [mille-plateaux/canterbury-2A]">此问题</a></span> 来自一本名为 <span class="link external"><a href="https://en.wikipedia.org/wiki/The_Canterbury_Puzzles" title="The Canterbury Puzzles [https://en.wikipedia.org/wiki/The_Canterbury_Puzzles]">The Canterbury Puzzles</a></span> 的书, 是其中的 “The Puzzle of the Doctor of Physic” 的重述. 本文希望以此问题为起点, 介绍历史上若干算术问题的几何方法.</p>
<p><section class="block" data-taxon="Problem"><details ><summary id="mille-plateaux-canterbury-2A"><header><h1><span class="taxon">Problem. </span>古代物理学博士问题 <a class="slug" href="/mille-plateaux/canterbury-2A">[canterbury-2A]</a></h1><div class="metadata"><ul><li class="meta-item">December 26, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link local"><a href="/pearls" title="Pearls [pearls]">Pearls</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>有两个正方体, 一个边长为 $1$, 另一个边长为 $2$. 请找到另外两个边长为有理数的正方体使它们的体积总和相同. 换言之, 求下述方程的一组 (正) 有理解.</p>
<p>$$ x^3 + y^3 \spaces= 9 \quad \color{gray}{(= ~ 1^3+2^3)} $$</p>
<p><section class="block" data-taxon="Solution"><details ><summary id="mille-plateaux-canterbury-2B"><header><h1><span class="taxon">Solution. </span> <a class="slug" href="/mille-plateaux/canterbury-2B">[canterbury-2B]</a></h1><div class="metadata"><ul><li class="meta-item">December 26, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>我们先画出 $x^3 + y^3 = 9$. 然后由已知的 $P=(1,2)$ 出发做切线得到 $2P$, $4P$, $8P$. 这种几乎全凭借运气的操作是 <span class="link external"><a href="https://en.wikipedia.org/wiki/Pierre_de_Fermat" title="Fermat [https://en.wikipedia.org/wiki/Pierre_de_Fermat]">Fermat</a></span> 及 <span class="link external"><a href="https://en.wikipedia.org/wiki/Fran%C3%A7ois_Vi%C3%A8te" title="Viète [https://en.wikipedia.org/wiki/Fran%C3%A7ois_Vi%C3%A8te]">Viète</a></span> 研究此类问题的方式.</p>
<p><figure><img src="/mille-plateaux/8P.svg" class="color-invert"/></figure></p>
<p>如图, 随后注意到 $8P$ 恰好位于 $x &gt; 0,y &gt; 0$ 的区域, 现在写出其坐标.</p>
<p>$$ 8P \spaces= \left(\frac{1243617733990094836481}{609623835676137297449}, \frac{487267171714352336560}{609623835676137297449}\right) $$</p>
</details></section></p>
</details></section>
<section class="block" data-taxon="Lemma"><details ><summary id="mille-plateaux-canterbury-3A"><header><h1><span class="taxon">Lemma. </span>切线与交点 <a class="slug" href="/mille-plateaux/canterbury-3A">[canterbury-3A]</a></h1><div class="metadata"><ul><li class="meta-item">December 27, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\quads#1{\quad #1 \quad}$
$\gdef\eqq{\quads=}$</p>
<p>对 $\Gamma: x^3+y^3=c$ 求导得 $3x^2 + 3y^2y^\prime = 0$, 故 $y^\prime = -\frac{x^2}{y^2}$. 任取 $\Gamma$ 上一个点 $P(x_\Box, y_\Box)$. 由此得到该点处的切线 $\ell_P: y - y_\Box = -\frac{x_\Box^2}{y_\Box^2}(x - x_\Box)$. 代入 $\Gamma$, 即</p>
<p>$$ x^3 + (y_\Box-\frac{x_\Box^2}{y_\Box^2}(x - x_\Box))^3 \spaces= x_\Box^3 + y_\Box^3 $$</p>
<p>注意这里有一个 $(\frac1{y_\Box^2})^3$, 我们将其提出其即可得到</p>
<p>$$ y_\Box^{-6}(x-x_\Box)^2(y_\Box^6x - x_\Box^6x + x_\Box^7 + 3x_\Box^4y_\Box^3+2x_\Box y_\Box^6) \spaces= 0 $$</p>
<p>随后解这个关于 $x,y$ 的方程. 注意这里 $(x-x_\Box)^2$ 当然来自于我们做的 $P$ 点切线, 也就是重根 $x_\Box$. $\Gamma$ 是一条三次曲线, 与直线的交点方程最多三个解, 因此最后一项关于 $x$ 是线性的, 故只需要解一个线性方程, 立刻得到</p>
<p>$$ 2P: (x_\Box, y_\Box) \quad \leadsto \quad \left(\frac{x_\Box(x_\Box^3 + 2y_\Box^3)}{x_\Box^3 - y_\Box^3}, \frac{y_\Box(y_\Box^3 + 2x_\Box^3)}{y_\Box^3 - x_\Box^3}\right) $$</p>
<p>反复利用映射 $2P$ 即可得到 <span class="link local"><a href="/mille-plateaux/canterbury-2B" title=" [mille-plateaux/canterbury-2B]">前文</a></span> 的 $8P$. 当然, 这也给出如下经典的恒等式. 最早亦可追溯到 <span class="link external"><a href="https://en.wikipedia.org/wiki/Fran%C3%A7ois_Vi%C3%A8te" title="Viète [https://en.wikipedia.org/wiki/Fran%C3%A7ois_Vi%C3%A8te]">Viète</a></span> 和 Bacht.</p>
<p>$$ x^3 + y^3 \eqq \left(\frac{x(x^3 + 2y^3)}{x^3 - y^3}\right)^3 + \left(\frac{y(y^3 + 2x^3)}{y^3 - x^3}\right)^3 $$</p>
</details></section>
<section class="block" data-taxon="Exegesis"><details ><summary id="mille-plateaux-fermat-ascent"><header><h1><span class="taxon">Exegesis. </span>Fermat 提升法 <a class="slug" href="/mille-plateaux/fermat-ascent">[fermat-ascent]</a></h1><div class="metadata"><ul><li class="meta-item">December 26, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\Q{\mathbf{Q}}$</p>
<p>考虑一般的三次曲线 $\Gamma$. 已知一有理点时, 我们可以过此点做切线. 已知两有理点 $P, Q$ 时, 连接两点得到直线 $\ell$ 交曲线 $\Gamma$ 于另一点 $S$, 这个时候 $\ell$ 和 $\Gamma$ 的交点方程仍然是一个三次方程. 根与系数的关系给出</p>
<p>$$ x(P) \spaces + x(Q) \spaces + x(S) \spaces 
\in \Q $$</p>
<p>这使得 $x(S) \in \Q$. 我们也可以将这个想法直接应用到二次曲线上.</p>
</details></section></p>
</details></section>
<section class="block" data-taxon="Exegesis"><details ><summary id="mille-plateaux-circular-parameterization"><header><h1><span class="taxon">Exegesis. </span>圆的参数化 <a class="slug" href="/mille-plateaux/circular-parameterization">[circular-parameterization]</a></h1><div class="metadata"><ul><li class="meta-item">December 28, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\Q{\mathbf{Q}}$
$\gdef\R{\mathbf{R}}$</p>
<p>我们对于 $\R$ 上的单位圆周曲线 $C(\R):x^2+y^2=1$ 和它关于角度 $\theta$ 的参数化 $\theta \mapsto (\cos\theta, \sin\theta)$ 是不陌生的. 通过计算这类统称为三角函数或者圆函数的映射, 很容易就能发现圆上的一些不同寻常的点</p>
<p>$$ (\tfrac1{\sqrt2}, \tfrac1{\sqrt2}), \quad (\tfrac{1+\sqrt5}4, \sqrt{\tfrac58 - \tfrac{\sqrt5}8}), \quad (\tfrac{\sqrt3}2, \tfrac12) $$</p>
<p>但是如果我们希望找到 $C(\Q)$ 上的点, 这个参数化就没有那么有用了. 考虑 $C(\Q):x^2+y^2=r^2$, 我们从点 $P(-r, 0)$ 出发, 任选一个 $t \in \R$ 作为过 $P$ 点直线的斜率, 即 $y = t(x+r)$, 随后联立之.</p>
<p>$$ (1+t^2)x^2 + 2rt^2x + r^2t^2 - r^2 = 0 $$</p>
<p>由于我们已经知道它的一个根 $x_1 = -r$. 且根与系数的关系给出</p>
<p>$$ x_1 + x_2 = -\frac{2rt^2}{1+t^2} $$</p>
<p>立得 $x_2 = r \cdot \frac{1-t^2}{1+t^2}$. 从而给出一个熟知的有理参数化</p>
<p>$$ t \quads\mapsto r \cdot \bigg(\frac{1-t^2}{1+t^2}, \frac{2t}{1+t^2}\bigg) $$</p>
<p>这样一种寻找点的方式, 通常被称为弦切法.</p>
<p><figure><img src="/mille-plateaux/chord-tangent.svg" class="color-invert"/></figure></p>
</details></section>
<section class="block" data-taxon="Exegesis"><details ><summary id="mille-plateaux-circular-curve"><header><h1><span class="taxon">Exegesis. </span>圆曲线 <a class="slug" href="/mille-plateaux/circular-curve">[circular-curve]</a></h1><div class="metadata"><ul><li class="meta-item">December 30, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\spaces#1{~ #1 ~}$
$\gdef\d{\operatorname{d}}$
$\gdef\E{\operatorname{E}}$
$\gdef\arc{\text{arc}}$
$\gdef\R{\mathbf{R}}$
$\gdef\Q{\mathbf{Q}}$</p>
<p>考虑半径为 $r$ 的实圆周 $x^2+y^2=r^2$，其在上半平面的轨迹可表为函数 $y=\sqrt{r^2-x^2},x\in[-r,r]$，<span class="link local"><a href="/mille-plateaux/arc-length" title="曲线弧长计算 [mille-plateaux/arc-length]">长度</a></span> 为</p>
<p>$$
L 
\spaces= \int_{-r}^r\dfrac{r}{\sqrt{r^2-x^2}}\d x
\spaces= r\arcsin\dfrac{x}{r}\bigg|_{-r}^r
\spaces= \pi r
$$</p>
<p>因而圆的弧长定义了反正弦函数，即</p>
<p>$$
\arcsin x \spaces= \int_0^x\dfrac{1}{\sqrt{1-t^2}}\d t
$$</p>
<p>其反函数被称为正弦函数，统称圆函数或者三角函数.</p>
<p>现在, 注意到 $\cot(x)$ 和 $\cot^\prime(x)$ 满足   $\cot^2(x) + \cot^\prime(x) = 1$, 令 $(\cot(x), \cot^\prime(x)) \mapsto (x,y)$, 即 $y=c-x^2$.</p>
<p>其他三角函数及其导数也有类似的关系, 以下列出.</p>
<p>$$\def\arraystretch{2}\begin{array}{|c|c|c|c|} 
\hline
u &amp; (u, u^\prime) \mapsto (x,y) &amp; g &amp; \int \frac{\d x}{y} \\
\hline
\cot &amp; y = -x^2-1 &amp; 0 &amp; -\tan^{-1} x \\ 
\hline
\tan &amp; y = x^2 + 1 &amp; 0 &amp; \tan^{-1} x \\ 
\hline
\cos, \sin &amp; y^2 = 1-x^2 &amp; 0 &amp; \tan^{-1}\dfrac{x}{\sqrt{1-x^2}} \\
\hline
\sec, \csc &amp; y^2 = x^4-x^2 &amp; 0 &amp; \dfrac{x\sqrt{x^2-1} \tan^{-1}(\sqrt{x^2-1})}{\sqrt{x^4-x^2}} \\
\hline
\end{array}$$</p>
<p>现在取 $C(\Q): y=x^2+1$ 上一定点 $(0, 1)$, 固定斜率 $t$ 从而有直线 $\ell(\Q): y=tx+1$, 类似地求曲线 $\ell(\Q) \cdot C(\Q) = 0$ 的交点, 得到 $(t, t^2+1)$.</p>
<p>如果我们对抛物线 $C(\R)$ 求弧长, 所得到的将是 $\log$ 或 $\sinh^{-1}$ 的代数函数. 当然, $\sinh^{-1}$ 实际上也是 $\log$ 的代数函数.
$$
\begin{aligned} 
s
&amp;\spaces= \int\sqrt{1+(2x)^2}\d x \\
&amp;\spaces= \frac12 \sqrt{1+4x^2} + \frac14\sinh^{-1}(2x)
\end{aligned}
$$</p>
<p>现在重新回顾</p>
<p>$$
\int\dfrac{\d x}{y}, \quad y = \sqrt{r^2-x^2}
$$</p>
<p>积分号内的项是 $x,y$ 的有理函数, $y$ 是 $x$ 的代数函数, 同时我们已经知道 $x,y$ 满足的代数方程有一个 <span class="link local"><a href="/mille-plateaux/circular-parameterization" title="圆的参数化 [mille-plateaux/circular-parameterization]">有理参数化</a></span>, 也就是说</p>
<p>$$
\begin{aligned}
\int\dfrac{\d x}{y} 
&amp;\spaces= \int \frac{\d{(\frac{1-t^2}{1+t^2})}}{\frac{2t}{1+t^2}} \\
&amp;\spaces= \int -\frac{4t}{(1+t^2)^2} \cdot \frac{1+t^2}{2t} \d t \\
&amp;\spaces= \int -\frac{2}{1+t^2} \d t \\
&amp;\spaces= -2\tan^{-1} t
\end{aligned}
$$</p>
<p>这是 <span class="link external"><a href="https://en.wikipedia.org/wiki/Tangent_half-angle_substitution" title="切线半角换元 [https://en.wikipedia.org/wiki/Tangent_half-angle_substitution]">切线半角换元</a></span> 或者按俄罗斯与国内更流行的称呼则是万能三角换元. 另一方面, 我们知道 $t = \pm\frac{\sqrt{1-x}}{\sqrt{1+x}}$. 这就意味着 $\arcsin x$ 和 $-2\tan^{-1} t$ 之间最多只相差一个常数, 容易计算这个常数正是 $\frac{\pi}2$, 则有</p>
<p>$$
\arcsin x \spaces= \frac{\pi}2-2\arctan\frac{\sqrt{1-x}}{\sqrt{1+x}}
$$</p>
<p>双曲线时的情况略有不同. 考虑 $C(\R):x^2-y^2=1$, 如果朴素地计算平面直角坐标系上的积分, 将得到一个会被归类为椭圆积分的表达式</p>
<p>$$ 
\int \sqrt{\frac{2x^2-1}{x^2-1}} \d x 
\spaces= \int \frac{4x^4-1}{\sqrt{x^2-1}\sqrt{2x^2+1}} \d x
$$</p>
<p>由于分子部分的 $4x^4-1$ 是多项式函数, 因此整个积分的核心就在于下面这一项</p>
<p>$$
\int \frac1{\sqrt{(x^2-1)(2x^2+1)}} \d x
\tag{1}
$$</p>
<p><span class="link local"><a href="/mille-plateaux/elliptic-integral" title="椭圆积分 [mille-plateaux/elliptic-integral]">椭圆积分的经验</a></span> 很容易让我们认为最后的结果当中势必会出现 <span class="link local"><a href="/mille-plateaux/elliptic-functions" title="椭圆函数 [mille-plateaux/elliptic-functions]">椭圆函数</a></span>. 事实正是如此, 注意这个时候 $y^2 = (x^2-1)(2x^2+1)$ 的 $g$ 是 $1$, 而且实际上在引入椭圆函数后, $(1)$ 的表达式要远比弧长的表达式复杂.</p>
<p>现在考虑双曲线 $C(\R)$ 的一个参数化
$$ (x,y) \quads\mapsto (\cosh t, \sinh t) $$</p>
<p>相应的, 关于 $x \in [a,b]$ 弧长积分变为 $t \in [\cosh^{-1}a, \cosh^{-1}b]$ 的积分</p>
<p>$$
\begin{aligned}
\int \sqrt{\sinh^2 t + \cosh^2 t} \d t
&amp;\spaces= \int \sqrt{\cosh 2t} \d t \\
&amp;\spaces= -i \E(it \mid 2) \\
&amp;\spaces= -i \E(i \cosh^{-1}x \mid 2) \\
&amp;\spaces= \E(\sin^{-1}x \mid 2) \\
\end{aligned}
$$</p>
</details></section></p>
</details></section>
<section class="block" data-taxon=""><details ><summary id="mille-plateaux-periodic-2A"><header><h1><span class="taxon"></span>周期函数的构造 <a class="slug" href="/mille-plateaux/periodic-2A">[periodic-2A]</a></h1><div class="metadata"><ul><li class="meta-item">December 31, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\R{\mathbf{R}}$
$\gdef\Z{\mathbf{Z}}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>我们的目的是构造某些完备域上的非常值周期函数. 对于实数域 $\R$, <span class="link local"><a href="/mille-plateaux/circular-curve" title="圆曲线 [mille-plateaux/circular-curve]">圆函数</a></span> 告诉我们这当然是可行的, 不过我们的构造过程应当不依赖于对圆函数的印象.</p>
<p><section class="block" data-taxon="Exegesis"><details ><summary id="mille-plateaux-periodic-2B"><header><h1><span class="taxon">Exegesis. </span>Weierstraß 的灵感来源 <a class="slug" href="/mille-plateaux/periodic-2B">[periodic-2B]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>对于周期 $1$. 下面这个观察因为 Weierstraß 的使用而变得广为人知. 具体来说, 可以从这样一个级数出发</p>
<p>$$ f(x) \spaces= \sum_{n \in \Z} \frac1{(n-x)^2}, \quad x \notin \Z $$</p>
<p>因为 $n$ 取遍了所有整数, $f(x)$ 在映射 $n \mapsto n + k$, $k \in \Z$ 下不变. 这样一来, 如果 $x$ 被选定为任意一个整数, 总会存在 $n-x$ 为零的项使整个级数发散, 这就要求 $x \notin \Z$. 同样的, $f(x)$ 在映射 $x \mapsto x + k$, $k \in \Z$ 下不变, 这就意味着 $f(x)$ 以 $1$ 为周期. 现在我们当然知道这个 $f(x)$ 其实就是 $\pi^2\csc^2(\pi x)$.</p>
<p>由于 $(n-x)^2 \ge x^2-n^2$, 这使得如下级数也是收敛的</p>
<p>$$ \sum_{n \in \Z} \frac{x}{x^2-n^2} \quad (= ~ \pi\cot(\pi x)) $$</p>
</details></section>
<section class="block" data-taxon="Exegesis"><details ><summary id="mille-plateaux-periodic-2C"><header><h1><span class="taxon">Exegesis. </span>双周期函数 <a class="slug" href="/mille-plateaux/periodic-2C">[periodic-2C]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p>$\gdef\R{\mathbf{R}}$
$\gdef\Q{\mathbf{Q}}$
$\gdef\Z{\mathbf{Z}}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>我们要求两个 $\R$-周期 $T_1,T_2$ 是 $\R$-线性无关的, 否则周期之比 $\frac{T_1}{T_2} = \frac{p}{q} \in \Q$, $\gcd(p,q) = 1$, 这意味着 $T_i$ 生成的周期集合退化</p>
<p>$$
\begin{aligned}
\{ nT_1 + mT_2 : n,m \in \Z \} 
&amp;\spaces= \left\{ \left(\frac{np}{q} + m \right) T_2 : n,m \in \Z \right\} \\
&amp;\spaces= \left\{ (np + mq) \cdot \frac{T_2}{q} : n,m \in \Z \right\}
\end{aligned}
$$</p>
<p>此时 $np + mq \in \Z$, 所以该集合被周期 $\frac{T_2}{q}$ 生成, 矛盾.</p>
</details></section></p>
</details></section></p>
</details></section>
<section class="block" data-taxon=""><details ><summary id="data-structure-index"><header><h1><span class="taxon"></span>数据与可计算结构 <a class="slug" href="/data-structure/index">[data-structure]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p><section class="block" data-taxon=""><details ><summary id="data-structure-seven-trees-in-one"><header><h1><span class="taxon"></span>七树合一定理 <a class="slug" href="/data-structure/seven-trees-in-one">[seven-trees-in-one]</a></h1><div class="metadata"><ul><li class="meta-item">September 24, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link external"><a href="https://ncatlab.org/nlab/show/seven+trees+in+one" title="$n$Lab [https://ncatlab.org/nlab/show/seven+trees+in+one]">$n$Lab</a></span></li></ul></div></header></summary>
<p><section class="block" data-taxon="Definition"><details ><summary id="data-structure-binary-tree"><header><h1><span class="taxon">Definition. </span>二叉树类型 <a class="slug" href="/data-structure/binary-tree">[binary-tree]</a></h1><div class="metadata"><ul><li class="meta-item">September 24, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>二叉树意味树的每个结点最多两个子树. 其类型由两个构造器归纳给出</p>
<p><details><summary><figure><img src="/data-structure/tree-def.svg" class="color-invert"/></figure></summary><pre>inductive Tree α
  | leaf : Tree α
  | node : α → Tree α → Tree α → Tree α</pre></details></p>
<p>叶结点构造器 <code>leaf</code> 用于构造出一棵空树, 空树作为某个结点的所有子结点时, 该结点正是叶结点. 相应的, 二叉树的值存储在非叶结点中. 每个 (非空, 无标记) 二叉树类型的值要么是一个单结点 $\{\text{pt}\} = 1$, 要么等价于二叉树的有序配对 $B \times B = B^2$. 即 $B \xrightarrow{\sim} \{\text{pt}\} \sqcup B^2$.</p>
<p><figure><img src="/data-structure/binary-tree.svg" class="color-invert"/></figure></p>
<p>换言之, 二叉树可定义为某种满足 $B=1+B^2$ 的 (代数) 结构. 回顾 $6$ 次分圆多项式 $$ \Phi_6(x) \spaces= x^2-x+1 $$ 其复根 $\zeta_6$, $\zeta^{-1}_6$ 是所谓的 $6$ 次本原单位根.</p>
</details></section>
<section class="block" data-taxon="Theorem"><details ><summary id="data-structure-blass-lawvere"><header><h1><span class="taxon">Theorem. </span>Blass–Lawvere 定理 <a class="slug" href="/data-structure/blass-lawvere">[blass-lawvere]</a></h1><div class="metadata"><ul><li class="meta-item">September 24, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\N{\mathbf{N}}$
$\gdef\Z{\mathbf{Z}}$</p>
<p>记 $B$ 是二叉树类型, 则存在一个 <span class="link local"><a href="/bib/blass1995seven" title="Seven trees in one [bib/blass1995seven]">“极精确的双射”</a></span> $B \xrightarrow{\sim} B^7$.</p>
<p>显然并非所有 $\zeta_6$ 满足的等式都能提升到 $B$ 之间的同构, 如 $B^6 \ncong 1$. 自然的问题是, 哪些等式能提升到同构? 这个问题由下面的 <span class="link local"><a href="/data-structure/fiore-leinster" title="Fiore–Leinster [data-structure/fiore-leinster]">Fiore–Leinster 定理</a></span> 回答.</p>
<p><section class="block" data-taxon="Theorem"><details ><summary id="data-structure-fiore-leinster"><header><h1><span class="taxon">Theorem. </span>Fiore–Leinster <a class="slug" href="/data-structure/fiore-leinster">[fiore-leinster]</a></h1><div class="metadata"><ul><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item">September 24, 2024</li><li class="meta-item"><span class="link external"><a href="https://arxiv.org/pdf/math/9405205" title="https://arxiv.org/pdf/math/9405205">https://arxiv.org/pdf/math/9405205</a></span></li></ul></div></header></summary>
<p>$\gdef\N{\mathbf{N}}$
$\gdef\Z{\mathbf{Z}}$</p>
<p>设 $f,g_1,g_2 \in \N[x]$, 其中 $f$ 有非零常数项且 $\deg f \ge 2$. 若 $f(x) - x$ 整除非常值的 $g_1-g_2$ (在 $\Z[x]$ 中), 则在 $\N[x]/(x=f(x))$ 中, $g_1(x)=g_2(x)$.</p>
</details></section></p>
<p>特别的, 取 $f(x)=1+x^2$, <span class="link local"><a href="/data-structure/fiore-leinster" title="Fiore–Leinster [data-structure/fiore-leinster]">Fiore–Leinster 定理</a></span> 表明, 若在 $\N[x]/(x=1+x^2)$ 中成立  $f(x) = g(x)$, 则存在 “极精确的双射” $f(B) \cong g(B)$. 在 $\N[x]/(x=1+x^2)$ 中可以演绎得到 $x=x^7$ 但无法给出 $1=x^6$. 对于前者 $x^7-x = (x^2-x+1)(x^5+x^4-x^2-x) = 0$. 再看 $x^4 + x^2 + 1 = (x^2 + x + 1)(x^2 - x + 1)$, 这给出 $B^4+B^2+1 \ncong 0$, $B^4+B^2+B+1=B$.</p>
<p>这套想法亦可应用于其他树结构, 如有根平面树, 其每个结点有 $0$, $1$ 或 $2$ 个子结点, 即 $T \cong 1+T+T^2$. 由 <span class="link local"><a href="/data-structure/fiore-leinster" title="Fiore–Leinster [data-structure/fiore-leinster]">Fiore–Leinster 定理</a></span>, 存在 “极精确的双射” $T \cong T^5$.</p>
</details></section></p>
</details></section>
<section class="block" data-taxon=""><details ><summary id="data-structure-stack-permutation-isomorphism"><header><h1><span class="taxon"></span>栈置换–二叉树同构 <a class="slug" href="/data-structure/stack-permutation/isomorphism">[isomorphism]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024 — November 08, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link external"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" title="CC BY-NC-SA 4.0 [https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en]">CC BY-NC-SA 4.0</a></span></li><li class="meta-item"><span class="link external"><a href="https://kokic.github.io/assets/publications/A%20Correspondence%20between%20Stack%20Permutations%20and%20Binary%20Trees%20via%20Hille%20Encoding.pdf" title="PDF [https://kokic.github.io/assets/publications/A%20Correspondence%20between%20Stack%20Permutations%20and%20Binary%20Trees%20via%20Hille%20Encoding.pdf]">PDF</a></span></li></ul></div></header></summary>
<p></p>
<p><section class="block" data-taxon="Definition"><details ><summary id="data-structure-stack-permutation-stack-permutation"><header><h1><span class="taxon">Definition. </span>栈置换 <a class="slug" href="/data-structure/stack-permutation/stack-permutation">[stack-permutation]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>栈置换 (<em>stack permutation</em>) 也称作栈混洗 (<em>stack shuffle</em>). 给定一个非空栈 $A$ 和空栈 $B$ 与 $S$, 每次只允许 $(i)$ 弹出 $A$ 并压入 $S$. $(ii)$ 弹出 $S$ 并压入 $B$. 可以想见, 最终 $A$ 的元素一定会全部进入 $B$. 这样的 $B$ 就称为 $A$ 的一个栈置换.</p>
</details></section></p>
<p>不难发现, $A$ 的所有栈置换其实就是 $A$ 的所有出栈可能. 熟知 $n$ 元素栈共有 $\frac1{n+1}{2n \choose n}$ 种出栈情况. 另一方面, $n$ 个节点能构成 $\frac1{n+1}{2n \choose n}$ 种二叉树, 两者的计算都可以在 Catalan 数的相关条目中找到. 这表明两者作为集合同构, 一个可以考虑的问题是, 如何实现该同构? 即, 具体地写出这个双射. 这方面的 <span class="link local"><a href="/bib/hille1982stack" title="Stack permutations and an order relation for binary trees [bib/hille1982stack]">开创性工作</a></span> 来自 R. F. Hille.</p>
<p><section class="block" data-taxon="Definition"><details ><summary id="data-structure-stack-permutation-hille-encode"><header><h1><span class="taxon">Definition. </span>Hille 编码 <a class="slug" href="/data-structure/stack-permutation/hille-encode">[hille-encode]</a></h1><div class="metadata"><ul><li class="meta-item">1982</li><li class="meta-item">Reinhold Friedrich Hille</li><li class="meta-item"><span class="link local"><a href="/bib/hille1982stack" title="Stack permutations and an order relation for binary trees [bib/hille1982stack]">Stack permutations and an order relation for binary trees</a></span></li></ul></div></header></summary>
<p>以下三条规则给出 Hille 编码到二叉树的转换过程. 同时不难验证, 任给一个二叉树, 可以通过这三条规则得到其 Hille 编码.</p>
<ul>
<li><code>1</code> 表示添加当前树节点的左子树. 例如 <code>111</code> 表示的树为 <code>(⋅ (⋅ (⋅)))</code>.</li>
<li><code>01</code> 表示添加当前树节点的右子树. 例如 <code>10101</code> 表示的树为 <code>(⋅ _ (⋅ _ (⋅)))</code>.</li>
<li>而对于 <code>01</code> 前的 $k$ 个 <code>0</code>, 这些 <code>0</code> 用于表示将当前树节点回溯到前 $k$ 层. 例如 <code>11001</code> 表示的树为 <code>(⋅ (⋅) (⋅))</code>.</li>
</ul>
<p>注意到每个树节点的双亲 (<em>parent</em>) 节点是唯一的, 因此回溯操作良定, 一次回溯就是将当前节点改为其双亲.</p>
</details></section></p>
<p>相应的, 可以据此定义 Hille 编码的解析规则, 用于将这样一段有效的二进制序列转换为构造一颗二叉树的若干操作. 我们使用一种类 BNF 文法来定义这个解析器, 仅供读者理解.</p>
<p><figure><img src="/data-structure/stack-permutation/hille-parser.svg" class="color-invert"/></figure></p>
<p>由于我们的讨论不涉及具体元素, 不失一般性, 可以固定栈置换的入栈顺序为 $123\cdots n$. 同时这些数字也是二叉树节点的标签. 影响出栈序列的只有压入和弹出两个操作, 而构建二叉树允许的操作粗看起来要多一些. 因此首先需要通过一些技巧将二叉树构建操作的表示简化. 我们将栈的压入和弹出分别编码为 <code>1</code> 和 <code>0</code>, 并将栈置换对应的二进制序列称为栈编码. 对应的, 以 <span class="link local"><a href="/data-structure/stack-permutation/hille-encode" title="Hille 编码 [data-structure/stack-permutation/hille-encode]">Hille 编码</a></span> 刻画二叉树的构建.</p>
<p><section class="block" data-taxon="Example"><details ><summary id="data-structure-stack-permutation-three-nodes"><header><h1><span class="taxon">Example. </span>$n=3$ <a class="slug" href="/data-structure/stack-permutation/three-nodes">[three-nodes]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>以下写出三节点二叉树的所有 $5$ 种情况, 以展示这些树的二进制序列如何对应到栈置换.
此处二进制序列按栈弹空为标准, 补充了末尾的零.</p>
<p><figure><img src="/data-structure/stack-permutation/three-nodes.svg" class="color-invert"/></figure></p>
</details></section></p>
<p>这个过程的反向实际上并不平凡, 如果只考虑 $n=3$ 也就是上图的情况, 敏锐的读者可以发现, 这些栈置换其实就是二叉树按节点添加顺序 <sup class="footnote-reference" id="data-structure_stack-permutation_isomorphism_hille-order-back"><a href="#data-structure_stack-permutation_isomorphism_hille-order">1</a></sup> 编号后的中序遍历序列 <sup class="footnote-reference" id="data-structure_stack-permutation_isomorphism_inorder-sequence-back"><a href="#data-structure_stack-permutation_isomorphism_inorder-sequence">2</a></sup>. 我们接下来将解释其中的不平凡之处, 以及这一巧合发生的 <span class="link local"><a href="/data-structure/stack-permutation/equivalence" title="栈编码与 Hille 编码的等价性 [data-structure/stack-permutation/equivalence]">具体条件</a></span>. 首先是对原始文献的一个观察, <span class="link local"><a href="/bib/hille1982stack" title="Stack permutations and an order relation for binary trees [bib/hille1982stack]">Hille 原始文献</a></span> 当中提出的算法实际上存在错误, 将之改写成 Lean4 语言, 即</p>
<p><details><summary><figure><img src="/data-structure/stack-permutation/encode.svg" class="color-invert"/></figure></summary><pre>def encode : Tree → String
  | .node l r => "1" ++ encode l ++ encode r
  | _ => "0"</pre></details></p>
<p>只要考虑下面这个例子即可发现, 将一棵二叉树转化为它的 Hille 编码并非是简单的中序遍历.</p>
<p><figure><img src="/data-structure/stack-permutation/counterexample.svg" class="color-invert"/></figure></p>
<p>可以验证, 从 <code>110100100</code> 这个编码出发, 无法直接恢复原本的 
<span class="inline-typst"><svg class="typst-doc" viewBox="0 0 18.044079999999997 22.672179999999997" width="18.044079999999997pt" height="22.672179999999997pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:h5="http://www.w3.org/1999/xhtml">
    <path class="typst-shape" fill="#00000000" fill-rule="nonzero" d="M 0 0v 22.67218 h 18.04408 v -22.67218 Z "/>
    <g>
        <g class="typst-group">
            <g>
                <g class="typst-group" transform="matrix(0.4 0 0 0.4 1 1)">
                    <g>
                        <g class="typst-group">
                            <g>
                                <g class="typst-group">
                                    <g>
                                        <path class="typst-shape" fill="none" stroke="#000000" stroke-width="0.7404959999999999" stroke-linecap="round" stroke-linejoin="miter" stroke-miterlimit="4" transform="matrix(1 0 0 1 10.533055765200158 10.533055765199913)" d="M 0 0m 5.1597886 0 l -5.1597886 5.1597886 "/>
                                        <path class="typst-shape" fill="none" stroke="#000000" stroke-width="0.7404959999999999" stroke-linecap="round" stroke-linejoin="miter" stroke-miterlimit="4" transform="matrix(1 0 0 1 10.533055648846556 24.417355900815053)" d="M 0 0l 5.1597886 5.1597886 "/>
                                        <path class="typst-shape" fill="none" stroke="#000000" stroke-width="0.7404959999999999" stroke-linecap="round" stroke-linejoin="miter" stroke-miterlimit="4" transform="matrix(1 0 0 1 24.41735564884644 10.533055900814961)" d="M 0 0l 5.1597886 5.1597886 "/>
                                        <path class="typst-shape" fill="none" stroke="#000000" stroke-width="0.8" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" transform="matrix(1 0 0 1 13.884300000000003 0)" d="M 0 0m 6.1708 0 c -3.404949 0 -6.1708 2.7658513 -6.1708 6.1708 c 0 3.4049482 2.7658513 6.1708 6.1708 6.1708 c 3.4049482 0 6.1708 -2.765852 6.1708 -6.1708 c 0 -3.404949 -2.765852 -6.1708 -6.1708 -6.1708 Z "/>
                                        <path class="typst-shape" fill="none" stroke="#000000" stroke-width="0.8" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" transform="matrix(1 0 0 1 0 13.88429999999999)" d="M 0 0m 6.1708 0 c -3.404949 0 -6.1708 2.7658513 -6.1708 6.1708 c 0 3.4049482 2.7658513 6.1708 6.1708 6.1708 c 3.4049482 0 6.1708 -2.765852 6.1708 -6.1708 c 0 -3.404949 -2.765852 -6.1708 -6.1708 -6.1708 Z "/>
                                        <path class="typst-shape" fill="none" stroke="#000000" stroke-width="0.8" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" transform="matrix(1 0 0 1 13.884300000000003 27.768599999999996)" d="M 0 0m 6.1708 0 c -3.404949 0 -6.1708 2.7658513 -6.1708 6.1708 c 0 3.4049482 2.7658513 6.1708 6.1708 6.1708 c 3.4049482 0 6.1708 -2.765852 6.1708 -6.1708 c 0 -3.404949 -2.765852 -6.1708 -6.1708 -6.1708 Z "/>
                                        <path class="typst-shape" fill="none" stroke="#000000" stroke-width="0.8" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" transform="matrix(1 0 0 1 27.7686 13.88429999999999)" d="M 0 0m 6.1708 0 c -3.404949 0 -6.1708 2.7658513 -6.1708 6.1708 c 0 3.4049482 2.7658513 6.1708 6.1708 6.1708 c 3.4049482 0 6.1708 -2.765852 6.1708 -6.1708 c 0 -3.404949 -2.765852 -6.1708 -6.1708 -6.1708 Z "/>
                                    </g>
                                </g>
                            </g>
                        </g>
                    </g>
                </g>
            </g>
        </g>
    </g>
</svg>
</span>
, 其正确的 Hille 编码应该为 <code>1101000100</code>. 但是另一方面, 如果将序列 <code>110100100</code> 解释为栈的压入弹出操作, 即栈编码, 则可以得到正确的栈置换 <code>2314</code>. 这就意味着, 当二叉树的节点个数 $n &gt; 3$ 时, 存在二叉树使得其栈编码与 Hille 编码不同. 回忆二叉树和栈置换之间的双射关系, 这表明必然存在一套手续允许我们在两者之间互相转换, 下面我们将构造性地给出这个结果. 见 <span class="link local"><a href="/data-structure/stack-permutation/equivalence" title="栈编码与 Hille 编码的等价性 [data-structure/stack-permutation/equivalence]">栈编码与 Hille 编码的等价性</a></span>. 随后通过 <span class="link local"><a href="/data-structure/stack-permutation/ratio" title="相交率 [data-structure/stack-permutation/ratio]">相交率</a></span> 解释, 为何中序遍历在 $n$ 不大情况下能够频繁得到正确的 Hille 编码.</p>
<p><section class="block" data-taxon="Proposition"><details ><summary id="data-structure-stack-permutation-equivalence"><header><h1><span class="taxon">Proposition. </span>栈编码与 Hille 编码的等价性 <a class="slug" href="/data-structure/stack-permutation/equivalence">[equivalence]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>首先容易验证的是, 中序遍历总是能够给出二叉树 $b \in B$ 到栈置换 $s \in S$ 的映射, 而对于每一个栈置换 $s \in S$, 都能够写出唯一的二进制序列, 即栈编码 $c \in C$. 不考虑末尾连续的 <code>0</code>, 当栈编码 $c$ 与二叉树 $b$ 的 Hille 编码 $h \in H$ 相同时, 对 $B$ 直接进行中序遍历便能得出正确的 Hille 编码.</p>
<p>$$
\begin{CD}
B @&gt;&gt;&gt; S \\
  @VVV @VVV \\
H @&gt;&gt;&gt; C
\end{CD}
$$</p>
<p><section class="block" data-taxon="Proof"><details ><summary id="data-structure-stack-permutation-equivalence-pf"><header><h1><span class="taxon">Proof. </span> <a class="slug" href="/data-structure/stack-permutation/equivalence-pf">[equivalence-pf]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>记 $B \to H$ 为 $f$, 根据 <span class="link local"><a href="/data-structure/stack-permutation/hille-encode" title="Hille 编码 [data-structure/stack-permutation/hille-encode]">Hille 编码</a></span> 的定义, $f$ 是一个双射. 根据二叉树的性质, $g: B \to S$ 是中序遍历, 前文已经固定栈置换的入栈顺序为 $123\cdots n$, 这样一来就固定了 $B$ 的层序遍历, 因此 $g$ 也是双射. 现在来看 $h: S \to C$, 这显然也是一个双射. 最后, 我们能够从 $h \in H$ 当中恢复出 $c \in C$ 的信息, 只要将 $h$ 序列视为栈编码, 并且忽略空栈的弹出, 这就意味着 $H \to C$ 是满射, 随后利用 $C \to S \to B \to H$, 这样就得到了 $H \cong C$.</p>
</details></section></p>
<p>现在, Hille 原文所使用的 <code>encode</code> 算法就是 $h \circ g: B \to C$, 而预期的正确实现则是 $f$, 因此两者在结果上相差一个同构.</p>
</details></section></p>
<p><section class="block" data-taxon="Proposition"><details ><summary id="data-structure-stack-permutation-intersection"><header><h1><span class="taxon">Proposition. </span>相交数 <a class="slug" href="/data-structure/stack-permutation/intersection">[intersection]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\eqdef{\overset{\scriptscriptstyle\text{def}}{=}}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>所有 $n$ 节点二叉树的 Hille 编码构成的集合记为 $H_n$, 所有 $n$ 节点二叉树的栈编码构成的集合记为 $C_n$. 对于 $H_n \cap C_n$ 的大小 $a_n \eqdef |H_n \cap C_n|$, 我们有如下刻画.</p>
<p>$$
a_n \spaces= \sum_{k = 0}^{n-1} \sum_{j = 0}^{n-k} \frac{1}{j+1}\binom{n-k-j}j \binom kj \binom{k+j+2}j
$$</p>
<p>记 $N = n+1$. 等式的证明可以通过分析一个半长为 $N$ 且不包含 <code>UUDD</code> 子序列的 Dyck 路径得到. 同时这也是从 $(0,0)$ 到 $(N,N)$ 不越过对角线且允许步长 $(1,k), (k,1), k \geqslant 1$ 的格路径的个数. 或者更简单地说, 是长度为 $N$ 的斜 Motzkin 路径的个数.</p>
</details></section></p>
<p><section class="block" data-taxon="Corollary"><details ><summary id="data-structure-stack-permutation-ratio"><header><h1><span class="taxon">Corollary. </span>相交率 <a class="slug" href="/data-structure/stack-permutation/ratio">[ratio]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>记 Catalan 数为 $c_n$, 也即 $H_n$ 或 $C_n$ 的个数. 自然要问 $|H \cap C_n|$ 在全体 $n$ 节点二叉树个数中所占的比例与 $n$ 的关系. 根据 <span class="link local"><a href="/data-structure/stack-permutation/intersection" title="相交数 [data-structure/stack-permutation/intersection]">相交数</a></span> 与 Catalan 数的渐进估计 $a_{n} \sim \frac{\sqrt{2 + r}}{2\sqrt{\pi}n^{3/2}r^{n}}$, $c_n \sim \frac{4^n}{\sqrt\pi n^{3/2}}$ 可以知道 $\lim\limits_{n\to\infty} \frac{a_n}{c_n} = 0$. 并且事实上只要二叉树的节点个数 $n$ 大于 $8$, $H_n$ 与 $C_n$ 相同的部分就会少于整体的一半.</p>
</details></section></p>
<p><section class="block" data-taxon="Exegesis"><details ><summary id="data-structure-stack-permutation-bounds"><header><h1><span class="taxon">Exegesis. </span>有效长度的上下界 <a class="slug" href="/data-structure/stack-permutation/bounds">[bounds]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>一个可供探究的问题是, 给定 $n$ 节点二叉树, 询问其 Hille 编码 $H_n$ 有效长度 $\ell(H_n)$ 的范围. 这里的有效不外乎是指去除末尾连续的 <code>0</code>. 我们将对此问题给出确切的回答.</p>
<p>任意 $n$ 节点二叉树的 Hille 编码的有效长度满足下面的不等式</p>
<p>$$n \spaces\leqslant \ell_{n} \spaces\leqslant \max(0,2n - 1,3n - 4)$$</p>
<p>下界 $n$ 的验证是容易的, 构造一棵 $n$ 节点二叉树最少也需要 $n$ 个 <code>1</code>.
由于 <span class="link local"><a href="/data-structure/stack-permutation/three-nodes" title="三节点二叉树 [data-structure/stack-permutation/three-nodes]">此处</a></span> 的讨论, 我们只需要验证 $n \geqslant 3$ 时 Hille 编码的有效长度至多是 $3n - 4$.</p>
<p><section class="block" data-taxon="Proof"><details ><summary id="data-structure-stack-permutation-bounds-pf"><header><h1><span class="taxon">Proof. </span> <a class="slug" href="/data-structure/stack-permutation/bounds-pf">[bounds-pf]</a></h1><div class="metadata"><ul><li class="meta-item">November 06, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>注意到为使有效长度最大, 相应的二叉树中的右节点个数和回溯次数要尽可能多.
同时满足这两个要求意味着 $(i)$ 除根节点外至少有一个左结点 <sup class="footnote-reference" id="data-structure_stack-permutation_bounds-pf_1-back"><a href="#data-structure_stack-permutation_bounds-pf_1">1</a></sup>. $(ii)$
该二叉树必有一个位于根节点右侧的节点 <sup class="footnote-reference" id="data-structure_stack-permutation_bounds-pf_2-back"><a href="#data-structure_stack-permutation_bounds-pf_2">2</a></sup>. 如下图所示</p>
<p><figure><img src="/data-structure/stack-permutation/tree-three.svg" class="color-invert"/></figure></p>
<p>由此出发, 我们将剩余的所有 $n-3$ 个节点全部添加到树中唯一的左节点的右侧. 即</p>
<p><figure><img src="/data-structure/stack-permutation/tree-max.svg" class="color-invert"/></figure></p>
<p>下面我们只需算出 $\ell(M)$, 便可得到 $\ell_n$ 的最大值. 不妨直接写出 $h(M)$</p>
<p><figure><img src="/data-structure/stack-permutation/hm-evaluate.svg" class="color-invert"/></figure></p>
<p>立刻看出 $\ell(M) = 2 + 2(n-3) + (n-2) + 2 = 3n-4$.</p>
<div class="footnote-definition" id="data-structure_stack-permutation_bounds-pf_1">
  <sup class="footnote-definition-label"><a href="#data-structure_stack-permutation_bounds-pf_1-back">1</a></sup>
<p>如若不然, 这颗二叉树只会形如 <code>1010101</code>$\cdots$, 其长度为 $2n - 1$.</p>
</div>
<div class="footnote-definition" id="data-structure_stack-permutation_bounds-pf_2">
  <sup class="footnote-definition-label"><a href="#data-structure_stack-permutation_bounds-pf_2-back">2</a></sup>
<p>否则回溯贡献的长度便不是最大值 $n-2$.</p>
</div>
</details></section></p>
<p>反过来, 从树 $M$ 出发, 也可以验证任何使得节点总数不变的操作都不会增加其 Hille 编码的有效长度. 更进一步, 我们可以断言任何使得节点总数不变的操作都将严格减小其 Hille 编码的有效长度. 换言之, 使得 $\ell(B) = 3n-4$ 的二叉树 $B$ 的结构是唯一的, 即 $M$.</p>
</details></section></p>
<div class="footnote-definition" id="data-structure_stack-permutation_isomorphism_hille-order">
  <sup class="footnote-definition-label"><a href="#data-structure_stack-permutation_isomorphism_hille-order-back">1</a></sup>
<p>即按照 Hille 编码逐步添加节点的顺序.</p>
</div>
<div class="footnote-definition" id="data-structure_stack-permutation_isomorphism_inorder-sequence">
  <sup class="footnote-definition-label"><a href="#data-structure_stack-permutation_isomorphism_inorder-sequence-back">2</a></sup>
<p>如二叉树 <code>1101000100</code> 按添加顺序对节点编号, 然后做中序遍历得到的是 <code>2314</code>.</p>
</div>
</details></section>
<section class="block" data-taxon=""><details ><summary id="data-structure-synthetic-differential-index"><header><h1><span class="taxon"></span>综合微分法 <a class="slug" href="/data-structure/synthetic-differential/index">[synthetic-differential]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024 — May 14, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p><section class="block" data-taxon="Exegesis"><details ><summary id="data-structure-synthetic-differential-numerical"><header><h1><span class="taxon">Exegesis. </span>数值微分的误差 <a class="slug" href="/data-structure/synthetic-differential/numerical">[numerical]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\quads#1{\quad #1 \quad}$
$\gdef\eqq{\quads=}$</p>
<p>我们首先观察朴素的数值微分的计算过程. 待微分函数为 $(x+3)^2$, 此处不妨取 $x=-2$, $h=10^{-5}$, 这一位置的导数 $A$ 近似为</p>
<p>$$ 
A \quads\approx \frac{f(x+h)-f(x)}h \eqq \frac{(1 + 10^{-5})^2 - 1^2}{10^{-5}} \eqq 2.00001 
$$</p>
<p>并且如果试图得到与预期的 $A=2$ 更接近的结果, 则须将无穷小近似 $h$ 选取为更靠近 $0$ 的数值, 这对于浮点精度有限的计算机来说极为不利.</p>
<p>而常规符号微分程序视表达式为树结构, 通过遍历树并对符合模式的节点应用求导规则 $(uv)' = u'v+uv'$. 即</p>
<p>$$
\begin{aligned}
(x+3)^2 
&amp; \spaces\to (x+3)'(x+3) + (x+3)(x+3)' \\
&amp; \spaces\to 1 \cdot (x+3) + (x+3) \cdot 1 \\
&amp; \spaces\to 2x+6 
\end{aligned}
$$</p>
<p>此时再应用 $x=-2$ 得到 $A=2$. 这个做法在结果上可行, 但处理复杂的表达式时, 复合求导的中间过程本身会产生大量新的结点, 使递归遍历的实际时间达到指数级 $\mathcal{O}(2^N)$.</p>
<p>有没有方法可以既避免递归又减少中间结点呢? 我们先看一个涉及复数域的观察.</p>
</details></section>
<section class="block" data-taxon="Exegesis"><details ><summary id="data-structure-synthetic-differential-complex-step"><header><h1><span class="taxon">Exegesis. </span>复步微分法 <a class="slug" href="/data-structure/synthetic-differential/complex-step">[complex-step]</a></h1><div class="metadata"><ul><li class="meta-item">May 13, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>Mathworks 的创始人 Cleve Moler 约 60 年 <sup class="footnote-reference" id="data-structure_synthetic-differential_complex-step_publish-time-back"><a href="#data-structure_synthetic-differential_complex-step_publish-time">1</a></sup> 前提出了借用虚数单位 $i$ 的数值微分, 相关文献称为 <span class="link external"><a href="https://blogs.mathworks.com/cleve/2013/10/14/complex-step-differentiation/" title="complex step 微分法 [https://blogs.mathworks.com/cleve/2013/10/14/complex-step-differentiation/]">complex step 微分法</a></span> <sup class="footnote-reference" id="data-structure_synthetic-differential_complex-step_complex-step-back"><a href="#data-structure_synthetic-differential_complex-step_complex-step">2</a></sup>. 考虑光滑函数 $f(x)$, 其在 $x=a$ 处可表为关于 $X$ 的 Taylor 级数 <sup class="footnote-reference" id="data-structure_synthetic-differential_complex-step_distinguish-back"><a href="#data-structure_synthetic-differential_complex-step_distinguish">3</a></sup> $f(a) + f'(a)(X-a) + \text{etc.}$, 注意</p>
<p>$$
f(a+i h) \spaces= f(a) + i h f'(a) - \frac{h^2}{2!}f''(a) - \frac{ih^3}{3!}f'''(a) + \cdots
$$</p>
<p>这个其实就是将 Taylor 级数的每一项完全展开, 在 <span class="link local"><a href="/data-structure/synthetic-differential/kock-lawvere" title="Kock–Lawvere [data-structure/synthetic-differential/kock-lawvere]">后续</a></span> 的计算中也会继续用到. 如此便有
$$ 
\frac{\partial f}{\partial x} \spaces= \frac{\Im f(x+ih)}{h} + \mathcal{O}(h^2) \quads\implies 
\frac{\partial f}{\partial x} \quads\approx \frac{\Im f(x+ih)}{h} 
$$</p>
<p>这个方法最初被设计用于处理数值微分问题, 但稍加思考就能发现, 该过程也适用于符号微分. 与前一个问题所改进的结果的精度不同, 用于 <span class="link local"><a href="/data-structure/synthetic-differential/dual-number" title="对偶数 [data-structure/synthetic-differential/dual-number]">符号微分</a></span> 时, 所取得的优势是更精简的中间表达式和非递归的计算过程.</p>
<div class="footnote-definition" id="data-structure_synthetic-differential_complex-step_publish-time">
  <sup class="footnote-definition-label"><a href="#data-structure_synthetic-differential_complex-step_publish-time-back">1</a></sup>
<p>即 1967 年. 不过这个名字要等到 1998 年, William Squire 和 George Trapp 才正式提出.</p>
</div>
<div class="footnote-definition" id="data-structure_synthetic-differential_complex-step_complex-step">
  <sup class="footnote-definition-label"><a href="#data-structure_synthetic-differential_complex-step_complex-step-back">2</a></sup>
<p>按方法的流程看, <span class="link local"><a href="/data-structure/synthetic-differential/complex-step" title="Complex step 微分法 [data-structure/synthetic-differential/complex-step]">complex step 微分</a></span> 可以翻译为 “复步微分”.</p>
</div>
<div class="footnote-definition" id="data-structure_synthetic-differential_complex-step_distinguish">
  <sup class="footnote-definition-label"><a href="#data-structure_synthetic-differential_complex-step_distinguish-back">3</a></sup>
<p>习惯上会混淆 $x$ 与 $X$.</p>
</div>
</details></section>
<section class="block" data-taxon="Exegesis"><details ><summary id="data-structure-synthetic-differential-moler-correction"><header><h1><span class="taxon">Exegesis. </span>误差修正 <a class="slug" href="/data-structure/synthetic-differential/moler-correction">[moler-correction]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\C{\mathbf{C}}$
$\gdef\quads#1{\quad #1 \quad}$
$\gdef\eqq{\quads=}$</p>
<p>选取同样的 $h=10^{-5}$, 以下计算表明 <span class="link local"><a href="/data-structure/synthetic-differential/complex-step" title="Complex step 微分法 [data-structure/synthetic-differential/complex-step]">Moler 的方法</a></span> 相比 <span class="link local"><a href="/data-structure/synthetic-differential/numerical" title="数值微分的误差 [data-structure/synthetic-differential/numerical]">此处</a></span> 基于有限差分的数值微分方法能够很好的避免精度损失.</p>
<p>$$
\frac{\Im(1 + 10^{-5}i)^{2}}{10^{-5}} \eqq \frac{\Im(\square + 2 \times 10^{- 5}i)}{10^{- 5}} \eqq 2
$$</p>
<p>实际上此处 $h$ 的选取, 只要其非零, 从而带有 $i$ 的项不消失, 就不会影响到最终的结果. 换言之, 这个方法从根本上来说, 是无关于 $h \in \R\smallsetminus\{0\}$ 和 $i$ 的, 只是在数值计算时借由复数算术和复函数值可以免去一些幂零结构的讨论. 一旦意识到这一点, 我们便可以将 <span class="link local"><a href="/data-structure/synthetic-differential/complex-step" title="Complex step 微分法 [data-structure/synthetic-differential/complex-step]">复步微分法</a></span> 的</p>
<p>$$ \frac{\partial f}{\partial x} \quads\approx \frac{\Im f(x+ih)}{h} $$</p>
<p>中的近似 “$\approx$” <span class="link local"><a href="/data-structure/synthetic-differential/matrix-represent" title="矩阵表示 [data-structure/synthetic-differential/matrix-represent]">修正</a></span> 为严格等于 “$=$”, 这只需要将 $\{z \in \C : z^2 = -1\}$ 替换为 $D = \{x \in R : x^2 = 0\}$, 问题就来到了如何构造这样的 $R$ 使得 $D$ 中有非零的元素, 这样的结构实际上会 <span class="link local"><a href="/data-structure/synthetic-differential/dual-number" title="对偶数 [data-structure/synthetic-differential/dual-number]">动摇</a></span> 经典逻辑中对于排中律的看法.</p>
</details></section>
<section class="block" data-taxon="Definition"><details ><summary id="data-structure-synthetic-differential-dual-number"><header><h1><span class="taxon">Definition. </span>对偶数 <a class="slug" href="/data-structure/synthetic-differential/dual-number">[dual-number]</a></h1><div class="metadata"><ul><li class="meta-item">May 14, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\R{\mathbf{R}}$
$\gdef\C{\mathbf{C}}$</p>
<p>一种通俗的讲法是, 认为对偶数 $R[x]/(x^2)$ 可以作为复数 $\R[x]/(x^2+1)$ 的类比. 如果有读者能轻率地暂时忽略 $R[x]/(x^2)$ 这种结构的存在性, 或者说接受了下面的 $d$ 的定义</p>
<p>$$ \exists ~ d \in R\smallsetminus\{0\}, ~ d^2 = 0 $$</p>
<p>不能接受也很正常, 因为这轻易就会导致某个经典逻辑中的 <span class="link local"><a href="/data-structure/synthetic-differential/schanuel-lavendhomme" title="Schanuel–Lavendhomme 构造 [data-structure/synthetic-differential/schanuel-lavendhomme]">矛盾</a></span>. 相比之下满足 $x^2 = -1$ 的 $x$ 对于大众而言要更容易接受的多, 甚至对于三次方程是 <span class="link local"><a href="/linear-algebra/casus-irreducibilis" title="Casus irreducibilis [linear-algebra/casus-irreducibilis]">必须品</a></span>. 为此我们需要下面的准备工作.</p>
<p><section class="block" data-taxon="Axiom"><details ><summary id="data-structure-synthetic-differential-kock-lawvere"><header><h1><span class="taxon">Axiom. </span>Kock–Lawvere <a class="slug" href="/data-structure/synthetic-differential/kock-lawvere">[kock-lawvere]</a></h1><div class="metadata"><ul><li class="meta-item">May 13, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\R{\mathbf{R}}$</p>
<p>首先需要强调的是, 这个公理所涉及到的结构的有效性全都依赖于 <span class="link local"><a href="/bib/jin2024topos" title="意象理论讲义 [bib/jin2024topos]">意象理论</a></span>, 而相关基础的严格性保证基本上在 1970 年之前就已经由 <span class="link local"><a href="/person/william-lawvere" title="Francis William Lawvere [person/william-lawvere]">William Lawvere</a></span> 完工. 记 $\mathcal{E}$ 是光滑空间之间的光滑映射构成的范畴, 同时假定 $\mathcal{E}$ 还是笛卡尔闭范畴, 也就是 $\mathcal{E}$ 中的箭头对笛卡尔积封闭.</p>
<p>我们可以从 $\mathcal{E}$ 中选出一条几何直线 $R$, 通过指定 $R$ 上两点 $0$ 和 $1$ 之间的距离作为单位长度来确定其他线段的长度. 发挥一些古希腊精神, 线段的移动可以给出 $R$ 上的加法, 尺规作图所构造的 <span class="link local"><a href="/bib/methods-of-algebra-1" title="代数学方法 卷一：基础架构 [bib/methods-of-algebra-1]">相似三角形</a></span> 能给出 $R$ 上的乘法 $\gamma = \alpha\beta$.</p>
<p><figure><img src="/data-structure/synthetic-differential/similar-triangle.svg" class="color-invert"/><figcaption>Methods in Algebra - Volume 1, p. 369</figcaption></figure></p>
<p>因此 $R$ 带有交换环结构, 并且允许经典数学中的对象实数环 $\R$ 成为 $R$ 的模型, 注意这里我们只能考虑 $\R$ 作为环的部分, 因为 $R$ 中存在着幂零元.</p>
<p>Kock–Lawvere 公理说的是, 对任意映射 $f: D \to R$, 存在唯一的 $a,b \in R$, 使得</p>
<p>$$ 
f(\epsilon) \spaces= a + b \epsilon, \quad \forall \epsilon \in D 
$$</p>
<p>将这里的 $a$ 换成 $f(0)$, 并完全使用量词叙述, 则是</p>
<p>$$ 
\forall ~ f \in R^D, ~ \exists! ~ b ~ \text{s.t.} ~ \forall ~ d \in D \quad (f(d) = f(0) + b d) 
$$</p>
<p>如果说这个公理的形式还不足以暗示它的目的, 那么下面这个推论就完全能做到了.</p>
<p><section class="block" data-taxon="Corollary"><details ><summary id="data-structure-synthetic-differential-smooths"><header><h1><span class="taxon">Corollary. </span>所有函数都光滑 <a class="slug" href="/data-structure/synthetic-differential/smooths">[smooths]</a></h1><div class="metadata"><ul><li class="meta-item">May 13, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>对任意函数 $f:R \rightarrow R$, 存在唯一的函数 $f':R \rightarrow R$ 满足</p>
<p>$$
f(x + \varepsilon) \spaces= f(x) + f'(x)\varepsilon,\quad \forall ~ x \in R, ~ \forall ~ \varepsilon \in D
$$</p>
<p>这个通常作为 <span class="link local"><a href="/data-structure/synthetic-differential/kock-lawvere" title="Kock–Lawvere [data-structure/synthetic-differential/kock-lawvere]">Kock–Lawvere 公理</a></span> 的推论出现, 不过从 $\mathcal{E}$ 的定义来看, 这才是整套框架真正的目的之一. 即, 为全体函数恢复牛顿时期 “幂零无穷小量” 计算上的直观, 而不导致矛盾.</p>
<p><figure><img src="/data-structure/synthetic-differential/maclaurin.svg" class="color-invert"/></figure></p>
</details></section></p>
<blockquote>
<p>Axiom is incompatible with the law of excluded middle.
Either the one or the other has to leave the scene.
In Part I of this book, the law of excluded middle has to leave,
being incompatible with the natural synthetic reasoning
on smooth geometry to be presented here.
In the terms which the logicians use, this means that
the logic employed is ‘constructive’ or ‘intuitionistic’.
We prefer to think of it just as ‘that reasoning
which can be carried out in all sufficiently good
cartesian closed categories’. <p style="text-align: right;">— Anders Kock, <span class="link local"><a href="/bib/kock2006synthetic" title="Synthetic differential geometry [bib/kock2006synthetic]">Synthetic Differential Geometry</a></span></p></p>
</blockquote>
</details></section></p>
<p>无论是单纯接受这个 <span class="link local"><a href="/data-structure/synthetic-differential/kock-lawvere" title="Kock–Lawvere [data-structure/synthetic-differential/kock-lawvere]">公理</a></span> 还是认可该公理存在的舞台 $\mathcal{E}$, 其实都会导致完全相同的结果, 那就是 $\mathcal{E}$ 当中一般函数的性质发生了变化, 让所有的函数都变得光滑. 与之相对的, 这样的好性质所要求的代价是, $\mathcal{E}$ 当中不能使用经典逻辑中的选择公理、排中律、反证法等命题.</p>
<p><section class="block" data-taxon="Exegesis"><details ><summary id="data-structure-synthetic-differential-matrix-represent"><header><h1><span class="taxon">Exegesis. </span>矩阵表示 <a class="slug" href="/data-structure/synthetic-differential/matrix-represent">[matrix-represent]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\str#1{{\footnotesize #1}}$
$\gdef\C{\mathbf{C}}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>这样一来, 我们所说的 <span class="link local"><a href="/data-structure/synthetic-differential/moler-correction" title="复步微分法 对数值微分误差的修正 [data-structure/synthetic-differential/moler-correction]">“将近似修正为严格等于”</a></span> 就可以精确表示为</p>
<p>$$ \frac{\partial f}{\partial x} \quads= f(x+\varepsilon) ~ \str{中} ~ \varepsilon ~ \str{项的系数} $$</p>
<p><span class="link local"><a href="/data-structure/synthetic-differential/complex-step" title="Complex step 微分法 [data-structure/synthetic-differential/complex-step]">复步微分法</a></span> 的来源是完全解析的, 但其得到的微分方法却能代数地刻画. 正如我们可以考虑复数的 $z = a+b\sqrt{-1} \in \C$ 矩阵表示</p>
<p>$$
A \spaces= \begin{pmatrix}
a &amp; -b \\
b &amp; ~~~a \\
\end{pmatrix}
,\quad
\det A \spaces= (a+b\sqrt{-1})(a-b\sqrt{-1}) 
$$</p>
<p>我们也可以构造 <span class="link local"><a href="/data-structure/synthetic-differential/dual-number" title="对偶数 [data-structure/synthetic-differential/dual-number]">对偶数</a></span> $a + b \varepsilon \in R$ 的矩阵表示, 并自动得到微分运算的加法和乘法规则, 这可以被简单地视为 Moler 方法的矩阵版本.</p>
<p>$$
A \spaces= \begin{pmatrix}
a &amp; a' \\
0 &amp; a \\
\end{pmatrix}
,\quad
\det A \spaces= (a+b\varepsilon)(a-b\varepsilon)
$$</p>
</details></section>
<section class="block" data-taxon="Example"><details ><summary id="data-structure-synthetic-differential-derived-differential"><header><h1><span class="taxon">Example. </span>导出微分运算 <a class="slug" href="/data-structure/synthetic-differential/derived-differential">[derived-differential]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\Mat{\operatorname{Mat}}$
$\gdef\d{\operatorname{d}}$
$\gdef\Z{\mathbf{Z}}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>设 $u, v \in R^R$, $n \in \Z$. 记 $A(u, u') = (\begin{smallmatrix} u &amp; u' \\ 0 &amp; u \end{smallmatrix})$. 从矩阵运算中立刻得到</p>
<ol>
<li>$A(u, u') + A(v, v') \spaces= A(u+v, u'+v')$</li>
<li>$A(u, u') - A(v, v') \spaces= A(u-v, u'-v')$</li>
<li>$A(u, u') \cdot A(v, v') \spaces= A(uv, u'v + uv')$</li>
<li>$A(u, u') \cdot (A(v, v'))^{-1} \spaces= A(uv^{-1}, (u'v - uv')v^{-2})$</li>
<li>$(A(u, u'))^n = A(u^n, nu^{n-1}u')$</li>
</ol>
<p>对于 $e^{A(u,u')}$, 注意 $A(u, u') = A(u, 0) + A(0, u')$, 这里 $(A(0, u))^2 = 0$. 同样可以计算得到 $e^{A(u,u')} = A(e^u, 0) \cdot A(1, u') = A(e^u, e^u u')$. 而对于 $\log A(u,u')$ 我们直接展开为 $\sum_{k \ge 1}\frac{(-1)^{k+1}}{k} \cdot (A-1)^k$ 即可验证:</p>
<p>$$
\begin{pmatrix} \sum_{k \ge 1}\frac{(-1)^{k+1}}{k} \cdot (u-1)^k &amp; \sum_{k \ge 0} (-1)^k (u-1)^k \cdot u'  \\ 0 &amp; \sum_{k \ge 1}\frac{(-1)^{k+1}}{k} \cdot (u-1)^k \end{pmatrix}
\spaces= 
\begin{pmatrix} \log u &amp; u'u^{-1} \\ 0 &amp; \log u \end{pmatrix}
$$</p>
</details></section>
<section class="block" data-taxon="Exegesis"><details ><summary id="data-structure-synthetic-differential-chain-rule"><header><h1><span class="taxon">Exegesis. </span>链式法则 <a class="slug" href="/data-structure/synthetic-differential/chain-rule">[chain-rule]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\Mat{\operatorname{Mat}}$
$\gdef\spaces#1{~ #1 ~}$
$\gdef\d{\operatorname{d}}$
$\gdef\eqdef{\overset{\scriptscriptstyle\text{def}}{=}}$</p>
<p>与 $\Mat_{2 \times 2}(R^R)$ 上的 <span class="link local"><a href="/data-structure/synthetic-differential/derived-differential" title="矩阵表示导出微分运算 [data-structure/synthetic-differential/derived-differential]">运算</a></span> 不同, 复合运算是只位于 $R^R$ 上的, 或者说 $\Mat_{2 \times 2}(R^R)$ 上并没有周知的复合运算. 为了自然地给出 $A: J^1(R, R) \to \Mat_{2 \times 2}(R^R)$ 上的复合, 这里 $J^1$ 是一阶 <span class="link external"><a href="https://ncatlab.org/nlab/show/jet+bundle" title="射流丛 [https://ncatlab.org/nlab/show/jet+bundle]">射流丛</a></span>. 记 $\square(x)$ 为 $\square_x $, $A(u)$ 为 $A(u,u')$, 考虑显式应用的 $A(u)$, 即</p>
<p>$$
A(u)_x \spaces\eqdef \begin{pmatrix} u_x &amp; u'_x \\ 0 &amp; u_x \end{pmatrix} \spaces\in \Mat_{2 \times 2}(R), \quad x \in R
$$</p>
<p>对于 $u: Y \to Z$, $v: X \to Y$. $A$ 上的复合 $A(u) \circ A(v)$ 可定义为 $A(u)_{v_x}$, $(v_x, v'_x) \in A(v)_x$. 我们来验证 $A(u) \circ A(v) = A(u \circ v)$.</p>
<p>$$
\begin{aligned}
A(u)_{v_x} 
&amp;\spaces= \Big(u \cdot \frac{\partial A}{\partial u} + \frac{\d u}{\d x} \cdot \frac{\partial A}{\partial u'}\Big)\Big|_{v_x} \\
&amp;\spaces= u(v_x) \cdot \frac{\partial A}{\partial u} + \frac{\d u(v_x)}{\d v_x} \frac{\d v_x}{\d x} \cdot \frac{\partial A}{\partial u'} \\
&amp;\spaces= A(u(v(x)), u'(v(x))v'(x)) \\
\end{aligned}
$$</p>
</details></section></p>
</details></section></p>
</details></section></p>
</details></section>
<section class="block" data-taxon=""><details ><summary id="linear-algebra-index"><header><h1><span class="taxon"></span>线性代数杂记 <a class="slug" href="/linear-algebra/index">[linear-algebra]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p><section class="block" data-taxon="Conjecture"><details ><summary id="linear-algebra-kontsevich-periodicity"><header><h1><span class="taxon">Conjecture. </span>Kontsevich 周期性猜想 <a class="slug" href="/linear-algebra/kontsevich-periodicity">[kontsevich-periodicity]</a></h1><div class="metadata"><ul><li class="meta-item">February 16, 2025</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\Mat{\operatorname{Mat}}$
$\gdef\Q{\mathbf{Q}}$</p>
<p>令 $(M_{ij})_{1 \le i,j \le 3}$ 是包含 $9$ 个非交换独立变量的矩阵. $I_1: M \to M^{-1}$ 是对矩阵求逆, $I_2: M_{ij} \to M_{ij}^{-1}$ 是对矩阵各分量求逆, $I_3: M \to M^T$ 是矩阵的转置. 则 Kontsevich 猜测, 存在两个 $3$ 阶对角矩阵 $L,R$ 使得</p>
<p>$$
(I_3 \circ I_2 \circ I_1)^3(M) \spaces= LMR
$$</p>
<p>且这里 $I,R$ 的分量是以 $M$ 的 $9$ 个分量 $M_{ij}$ 为变量的非交换有理函数.</p>
<p><span class="link local"><a href="/linear-algebra/kontsevich-periodicity" title="Kontsevich 周期性猜想 [linear-algebra/kontsevich-periodicity]">Kontsevich 周期性猜想</a></span> 已由 Natalia Iyudu 和 Stanislav Shkarin 于 2013 年 5 月 8 日 <span class="link external"><a href="https://arxiv.org/abs/1305.1965v3" title="证明 [https://arxiv.org/abs/1305.1965v3]">证明</a></span>, 因此这一猜想有时也被称作 Iyudu–Shkarin 定理. 不过这个证明过于暴力, 也没有对于一般的矩阵 $M \in \Mat_{n \times n}$ 回答 $n&gt;3$ 时的 <span class="link local"><a href="/linear-algebra/kontsevich-periodicity" title="Kontsevich 周期性猜想 [linear-algebra/kontsevich-periodicity]">Kontsevich 周期性猜想</a></span></p>
<p>$$
(I_3 \circ I_2 \circ I_1)^n(M) \spaces= LMR
$$</p>
<p>为何不成立 <sup class="footnote-reference" id="linear-algebra_kontsevich-periodicity_kontsevich-hold-back"><a href="#linear-algebra_kontsevich-periodicity_kontsevich-hold">1</a></sup>.</p>
<p><section class="block" data-taxon="Exegesis"><details ><summary id="linear-algebra-kontsevich-periodicity-2A"><header><h1><span class="taxon">Exegesis. </span>$n=2$ 交换版本 <a class="slug" href="/linear-algebra/kontsevich-periodicity-2A">[kontsevich-periodicity-2A]</a></h1><div class="metadata"><ul><li class="meta-item">February 18, 2025</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\Mat{\operatorname{Mat}}$</p>
<p>我们来观察对于交换环 $R$ 和对应的 $\Mat_{2\times 2}(R)$ 中的矩阵, $(I_3 \circ I_2 \circ I_1)^2$ 具体做了些什么. 令 $\varphi = I_3 \circ I_2 \circ I_1$, 则 $\varphi(M)$ 可以算出是</p>
<p>$$
\varphi: ~ M ~\leadsto~ \det M \cdot S I_2(M) S^T
$$</p>
<p>其中 $S = (\begin{smallmatrix}0 &amp; -1 \\ 1 &amp; ~~~0\end{smallmatrix})$ 是一个行列式为 $1$ 的反对称矩阵 <sup class="footnote-reference" id="linear-algebra_kontsevich-periodicity-2A_skew-adjoint-back"><a href="#linear-algebra_kontsevich-periodicity-2A_skew-adjoint">1</a></sup>, 记 $\tau: M \leadsto SI_2(M)S^T$, 可以验证 $\tau \circ \tau = \text{id}$. 现在我们来计算 $\varphi^2(M)$.</p>
<p>$$
\begin{aligned}
\varphi^2(M) 
&amp;\spaces= \varphi(\det M \cdot SI_2(M)S^T) \\
&amp;\spaces= \det(\det M \cdot SI_2(M)S^T) \cdot S I_2(\det M \cdot SI_2(M)S^T) S^T \\
&amp;\spaces= (\det M)^2 \det(SI_2(M)S^T) \cdot (\det M)^{-1}M \\
&amp;\spaces= \det M \det(SI_2(M)S^T) \cdot M \\
&amp;\spaces= \det M \det(I_2(M)) \cdot M
\end{aligned}
$$</p>
<p>也就是说 $\varphi^2(M)$ 实际上会是 $M$ 的常数倍, 并且这个常数是</p>
<p>$$
\det M \det(I_2(M)) \spaces= (ad-bc)\Big(\frac1{ad}-\frac1{bc}\Big)
$$</p>
<div class="footnote-definition" id="linear-algebra_kontsevich-periodicity-2A_skew-adjoint">
  <sup class="footnote-definition-label"><a href="#linear-algebra_kontsevich-periodicity-2A_skew-adjoint-back">1</a></sup>
<p>当我们把 $S$ 看作线性映射 $A$ 的表示时, 在定义上 $A$ 就被称为反自伴算子.</p>
</div>
</details></section></p>
<div class="footnote-definition" id="linear-algebra_kontsevich-periodicity_kontsevich-hold">
  <sup class="footnote-definition-label"><a href="#linear-algebra_kontsevich-periodicity_kontsevich-hold-back">1</a></sup>
<p>如果矩阵的分量是交换元, 则 $n=1,2$ 情况很容易 <span class="link local"><a href="/linear-algebra/kontsevich-periodicity-2A" title="二阶矩阵交换版本 [linear-algebra/kontsevich-periodicity-2A]">验证</a></span>. Iyudu 和 Shkarin 在他们的 <span class="link external"><a href="https://arxiv.org/abs/1305.1965v3" title="论文 [https://arxiv.org/abs/1305.1965v3]">论文</a></span> 中首先验证了 <span class="link local"><a href="/linear-algebra/kontsevich-periodicity" title="Kontsevich 周期性猜想 [linear-algebra/kontsevich-periodicity]">Kontsevich 周期性猜想</a></span> 对于 $n=2$ 非交换的情况也正确, 随后才讨论 $n=3$ 的版本.</p>
</div>
</details></section>
<section class="block" data-taxon="Theorem"><details ><summary id="linear-algebra-rayleigh-quotient"><header><h1><span class="taxon">Theorem. </span>Rayleigh 商定理 <a class="slug" href="/linear-algebra/rayleigh-quotient">[rayleigh-quotient]</a></h1><div class="metadata"><ul><li class="meta-item">November 5, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>设矩阵 $M$ 是 $n$ 阶对角矩阵, 即</p>
<p>$$
M \spaces= \begin{pmatrix}
\lambda_{1} \\
  &amp; \ddots \\
  &amp; &amp; \lambda_{n}
\end{pmatrix}
$$</p>
<p>则对非零向量 $x$ 和 $x$ 的共轭转置 $x^*$
有如下结果:</p>
<p>$$
\min\limits_{1 \leqslant i \leqslant n}\lambda_{i}
\spaces\leqslant \frac{x^{\ast}Mx}{x^{\ast}x} 
\spaces\leqslant \max\limits_{1 \leqslant i \leqslant n}\lambda_{i}
$$</p>
<p>其中 $\max\limits_{1 \leqslant i \leqslant n}\lambda_{i}$ 常被称作谱半径.</p>
<p><section class="block" data-taxon="Exegesis"><details ><summary id="linear-algebra-rayleigh-quotient-2A"><header><h1><span class="taxon">Exegesis. </span> 某类二次型的商 <a class="slug" href="/linear-algebra/rayleigh-quotient-2A">[rayleigh-quotient-2A]</a></h1><div class="metadata"><ul><li class="meta-item">November 5, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>注意, $x^* M x$ 和 $x^*x = \|x\|$ 当然都是标准二次型. 特别的, 取 $x = \left( x_{1},\cdots,x_{n} \right)^{T}$, 则</p>
<p>$$
x^{\ast}Mx \spaces= \sum_{1 \leqslant i \leqslant n}\lambda_{i}x_{i}^{2},\quad 
x^{\ast}x \spaces= \sum_{1 \leqslant i \leqslant n}x_{i}^{2}
$$</p>
<p>Rayleigh 商定理正是在说</p>
<p>$$
\min\limits_{1 \leqslant i \leqslant n}\lambda_{i} 
\spaces\leqslant 
\frac{\sum_{1 \leqslant i \leqslant n}\lambda_{i}x_{i}^{2}}{\sum_{1 \leqslant i \leqslant n}x_{i}^{2}} 
\spaces\leqslant 
\max\limits_{1 \leqslant i \leqslant n}\lambda_{i}
$$</p>
</details></section></p>
<p>Rayleigh 商定理中的对角矩阵 $M$ 可推广到 Hermite 矩阵 <sup class="footnote-reference" id="linear-algebra_rayleigh-quotient_hermite-matrix-back"><a href="#linear-algebra_rayleigh-quotient_hermite-matrix">1</a></sup>, 也即 $M$ 是共轭对称的方阵 $M^* = M$, 对实数而言这当然就是对称矩阵. 稍稍回忆线性代数, 有限维谱定理说:</p>
<ul>
<li>任何实对称矩阵都可以由正交矩阵对角化.</li>
<li>任何复对称矩阵都可以由酉矩阵对角化, 即 Autonne–Takagi 分解.</li>
</ul>
<p>具体而言, 对于每个实对称矩阵 [resp., 复对称矩阵] $A$, 都存在一个实正交矩阵 [resp., 酉矩阵] 使得 $Q^* A Q$ 是对角矩阵.</p>
<p><section class="block" data-taxon="Example"><details ><summary id="linear-algebra-rayleigh-quotient-2B"><header><h1><span class="taxon">Example. </span> 二阶情形 <a class="slug" href="/linear-algebra/rayleigh-quotient-2B">[rayleigh-quotient-2B]</a></h1><div class="metadata"><ul><li class="meta-item">November 5, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\quads#1{\quad #1 \quad}$
$\gdef\eqq{\quads=}$</p>
<p>考虑 $M = \scriptsize\begin{pmatrix} 1 &amp; 2 \\ 2 &amp; 1 \end{pmatrix}$,
将 $M$ 对角化得到 $D = \scriptsize\begin{pmatrix} 3 &amp; ~~~0 \\ 0 &amp; -1 \end{pmatrix}$,
相应的正交矩阵是 $\frac1{\sqrt{2}}\scriptsize\begin{pmatrix} 1 &amp; ~~~1 \\ 1 &amp; -1 \end{pmatrix}$.
注意, $(uP)^*M(uP) = u^{2}P^*MP$, 因此我们通过 $P^*MP$
来计算 $Q^*MQ$ <sup class="footnote-reference" id="linear-algebra_rayleigh-quotient-2B_rayleigh-quotient-2B-1-back"><a href="#linear-algebra_rayleigh-quotient-2B_rayleigh-quotient-2B-1">1</a></sup>:</p>
<p>$$
\frac12 \begin{pmatrix} 1 &amp; ~~~1 \\ 1 &amp; -1 \end{pmatrix}^*\begin{pmatrix} 1 &amp; 2 \\ 2 &amp; 1 \end{pmatrix}\begin{pmatrix} 1 &amp; ~~~1 \\ 1 &amp; -1 \end{pmatrix} \spaces= \frac12 \begin{pmatrix} 6 &amp; ~~~0 \\ 0 &amp; -2 \end{pmatrix} \spaces= \begin{pmatrix} 3 &amp; ~~~0 \\ 0 &amp; -1 \end{pmatrix}
$$</p>
<p>那么, 这就得到了 $M$ 的 Rayleigh 商之值域</p>
<p>$$
\frac{a^{2} + 4ab + b^{2}}{a^{2} + b^{2}}
\quads\to
\frac{3a^{2} - b^{2}}{a^{2} + b^{2}}
\quads\in \lbrack - 1,3\rbrack
$$</p>
<p>下面讨论 $A = \scriptsize\begin{pmatrix} p &amp; q \\ q &amp; p \end{pmatrix}$ 的对角化问题.
依然取正交矩阵 $Q = \frac1{\sqrt2} \scriptsize\begin{pmatrix} 1 &amp;~~~1 \\ 1 &amp; -1 \end{pmatrix}$, 相应的
$Q^*AQ = \scriptsize\begin{pmatrix} p + q &amp; 0 \\ 0 &amp; p - q \end{pmatrix}$. 故</p>
<p>$$
\begin{aligned}
\frac{pa^{2} + 2qab + pb^{2}}{a^{2} + b^{2}} \quads\to &amp;
\frac{(p + q)a^{2} + (p - q)b^{2}}{a^{2} + b^{2}} \\
\quads\in &amp; [p-q, p + q]
\end{aligned}
$$</p>
<p>最后, 对于对称矩阵 $\scriptsize\begin{pmatrix} a &amp; b \\ b &amp; c \end{pmatrix}$ 也就是二次形 $ax^2 + 2bxy + cy^2$. 其对角化为</p>
<p>$$
\begin{pmatrix} a &amp; b \\ b &amp; c \end{pmatrix}
\quads\mapsto
\frac12 \begin{pmatrix}
r - \sqrt{s} &amp; 0 \\
0 &amp; r + \sqrt{s}
\end{pmatrix}
$$</p>
<p>这里 $r = a + c$, $s = (a-c)^2 + 4b^2$.</p>
<div class="footnote-definition" id="linear-algebra_rayleigh-quotient-2B_rayleigh-quotient-2B-1">
  <sup class="footnote-definition-label"><a href="#linear-algebra_rayleigh-quotient-2B_rayleigh-quotient-2B-1-back">1</a></sup>
<p>由此, 其实不需要真的找一个正交矩阵 $Q$ 使得 $M = Q^*MQ$, 只需让 $P$ 满足 $MP = PD$.</p>
</div>
</details></section></p>
<p>广义 Rayleigh 商 $\frac{x^* A x}{x^* B x}$ 可以通过变换 $D = C^{-1} A C^*{}^{-1}$ 简化为 Rayleigh 商 $\frac{x^* D x}{(C^*x)^*(C^*x)}$, 其中 $C C^*$ 是 Hermite 正定矩阵的 Cholesky 分解. 对此, 我们也给出一例.</p>
<p><section class="block" data-taxon="Example"><details ><summary id="linear-algebra-rayleigh-quotient-3A"><header><h1><span class="taxon">Example. </span> 一般二次型的商 <a class="slug" href="/linear-algebra/rayleigh-quotient-3A">[rayleigh-quotient-3A]</a></h1><div class="metadata"><ul><li class="meta-item">November 5, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>我们要求解问题可以叙述成下面的形式</p>
<p>$$
F \spaces= \frac{3a^2 + 4ab + 3b^2}{4a^2 + 12ab + 34b^2}, \quad \min_\R F, \quad \max_\R F
$$</p>
<p>这里相应的 $A = \scriptsize\begin{pmatrix} 3 &amp; 2 \\ 2 &amp; 3 \end{pmatrix}$, $B = \scriptsize\begin{pmatrix} 4 &amp; ~~6 \\ 6 &amp; 34 \end{pmatrix}$. 我们首先对 $B$ 进行 Cholesky 分解, 得到 $C = \scriptsize\begin{pmatrix} 2 &amp; 0 \\ 3 &amp; 5 \end{pmatrix}$ 使得 $B = CC^*$. 接下来通过 $C^{-1} A C^*{}^{-1}$ 求出 $D$ 及其对角化 $E$, 这样就结束了此问题.</p>
<p>$$
\begin{aligned}
D \spaces= \frac14 \begin{pmatrix} ~~~3 &amp; -1 \\ -1 &amp; ~~~\frac35 \end{pmatrix}, ~~
E \spaces= &amp; \begin{pmatrix} 9-\sqrt{61} &amp; 0 \\ 0 &amp; 9+\sqrt{61} \end{pmatrix} \cdot \frac1{20}  \\ \spaces= &amp;\begin{pmatrix} \min_\R F &amp; 0 \\ 0 &amp; \max_\R F \end{pmatrix} 
\end{aligned}
$$</p>
</details></section></p>
<div class="footnote-definition" id="linear-algebra_rayleigh-quotient_hermite-matrix">
  <sup class="footnote-definition-label"><a href="#linear-algebra_rayleigh-quotient_hermite-matrix-back">1</a></sup>
<p>自伴随矩阵, 复对称矩阵.</p>
</div>
</details></section>
<section class="block" data-taxon="Exegesis"><details ><summary id="linear-algebra-permutation-matrix"><header><h1><span class="taxon">Exegesis. </span>置换矩阵构造 <a class="slug" href="/linear-algebra/permutation-matrix">[permutation-matrix]</a></h1><div class="metadata"><ul><li class="meta-item">January 16, 2025</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\quads#1{\quad #1 \quad}$
$\gdef\eqq{\quads=}$
$\gdef\str#1{{\footnotesize #1}}$
$\gdef\sstr#1{~{\footnotesize #1}~}$
$\gdef\Mat{\operatorname{Mat}}$</p>
<p>置换矩阵基本上可以认为是置换群的矩阵构造, 或者说矩阵表示. 这也可以为 <span class="link local"><a href="/mille-plateaux/bubble-compose" title="冒泡排序合成置换分解 [mille-plateaux/bubble-compose]">此处</a></span> 的结论及证明提供直观.</p>
<p>首先, 显然所有的置换矩阵都是单位矩阵 $I_n$ 的重新排列. 我们先从置换群 $S_2$ 也就是对换开始. 只考虑其中的非单位元 $\sigma = (1 ~~ 2)$.</p>
<p>$$
\begin{pmatrix} 0 &amp; 1 \\ 1 &amp; 0 \\ \end{pmatrix}
\begin{pmatrix} x_1 \\ x_2 \\ \end{pmatrix}
\spaces=
\begin{pmatrix} x_2 \\ x_1 \\ \end{pmatrix}
, \quad
\begin{pmatrix} 0 &amp; 1 \\ 1 &amp; 0 \\ \end{pmatrix} 
\spaces\hookrightarrow 
(1 ~~ 2)
$$</p>
<p>现在来考虑对换的复合, 为了通过矩阵去计算 $(2 ~~ 3)(1 ~~ 2)$, 我们实际上需要先对齐这两个方阵的阶. 换一种角度说, 对换记号 $(i ~~ j)$ 对应的并不是某个固定的方阵, 而是全体如下形式方阵当中的一个 <sup class="footnote-reference" id="linear-algebra_permutation-matrix_horizontal-exchange-back"><a href="#linear-algebra_permutation-matrix_horizontal-exchange">1</a></sup>.</p>
<p>$$ I_n \sstr{交换水平方向的} i ~ j \sstr{列得到的方阵} $$</p>
<p>当然, 如果我们固定 $n$, 这样的对应就是唯一的了.
我们在这里强调水平方向是因为台湾等地区关于行列的称呼与大陆是相反的. 具体到矩阵乘法时, 从 $(i ~ ~ j)$ 对应的方阵中选取同阶方阵进行运算.</p>
<p>$$
\underbrace{\begin{pmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 0 \end{pmatrix}}_{(2 ~ 3) ~ \curvearrowright ~ I_3}
\spaces\cdot
\underbrace{\begin{pmatrix} 0 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{pmatrix}}_{(1 ~ 2) ~ \curvearrowright ~ I_3}
\eqq
\underbrace{\begin{pmatrix} 0 &amp; 0 &amp; 1 \\ 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \end{pmatrix}}_{(3 ~ 1 ~ 2) ~ \curvearrowright ~ I_3}
$$</p>
<p>将矩阵乘法得到的结果翻译回置换，这当然就是 $(3 ~~ 1 ~~ 2)$, 与我们直接计算置换的复合相符. 也就是说</p>
<p>$$
\sigma_2\sigma_1 \quads\cong (\sigma_2 \curvearrowright I) \cdot (\sigma_1 \curvearrowright I)
$$</p>
<!-- 
$$ 
\sigma \curvearrowright \vec x \eqq (\sigma \curvearrowright I_{|\vec x|}) \cdot \vec x
$$ 
-->
<div class="footnote-definition" id="linear-algebra_permutation-matrix_horizontal-exchange">
  <sup class="footnote-definition-label"><a href="#linear-algebra_permutation-matrix_horizontal-exchange-back">1</a></sup>
<p>规定为垂直方向当然也可行, 但这样会使得 $A\vec x$ 当中的 $A$ 必须记为它的转置 $A^T$.</p>
</div>
</details></section>
<section class="block" data-taxon="Exegesis"><details ><summary id="linear-algebra-amtx"><header><h1><span class="taxon">Exegesis. </span>自动机与矩阵求逆 <a class="slug" href="/linear-algebra/amtx">[amtx]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024 — May 10, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link local"><a href="/cc" title="CC BY-NC-SA 4.0 [cc]">CC BY-NC-SA 4.0</a></span></li></ul></div></header></summary>
<p><section class="block" data-taxon="Definition"><details ><summary id="linear-algebra-regular-language"><header><h1><span class="taxon">Definition. </span>正则语言集 <a class="slug" href="/linear-algebra/regular-language">[regular-language]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\quads#1{\quad #1 \quad}$
$\gdef\eqq{\quads=}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>固定有限字母表 $\Sigma$, 正则语言集 $\textbf{Reg}_\Sigma$ 可定义如下</p>
<ul>
<li>空集 $\varnothing$ 是正则语言, 作为加法单位 $0_\Sigma$.</li>
<li>只包含空字符串的集合 $\{\epsilon\}$ 是正则语言, 作为乘法单位 $1_\Sigma$.</li>
<li>对于 $a \in \Sigma$, $\{a\}$ 是正则语言.</li>
<li>对于正则语言 $A$, $B$. $A \cup B$, $A \times_\Sigma B$ 和 $A^*$ 是正则语言.</li>
<li>$\Sigma$ 上不存在其它正则语言.</li>
</ul>
<p>这里 $A \times_\Sigma B$ 基本就是
$A \times B = \{ (a, b) : a \in A, b \in B \}$, 但将配对 $(a, b)$ 视为字符串拼接 $a b$.
$A$ 的闭包 $A^*$ 定义为满足如下性质的最小集合.</p>
<p>$\quad (i)$ 匹配空. 即 $\epsilon \in A^*$. $\quad (ii)$ 对拼接封闭. 即 $A \times_\Sigma A \times_\Sigma \cdots \times_\Sigma A \subset A^*$.</p>
<p>这里的 $\square^*$ 通常被称为 Kleene 星运算, 按照数学的习惯, $A^*$ 也被称为集合 $A$ 的自由幺半群. 约定 $A^0 = \{\epsilon\}, A^1 = A, A^{i+1} = \{wv : w \in V^i, v \in V \}$, $i \ge 1$. 同样的, 如果 $A$ 是一个字母表或形式语言, $A^i$ 收集的就是所有长度为 $i$ 且字符属于 $V$ 的字符串. 于是 $A^*$ 也可以定义成如下形式</p>
<p>$$
A^* \eqq \bigcup_{i \ge 0} A^i
$$</p>
<p>从直觉上说, $A^*$ 是为了刻画 $A$ 的零次或多次重复. 如果读者熟悉正则表达式, 那么显然此处的 $\cup$ 就是 $+$ 的别名, 对应匹配器的或运算, 于是我们也用 $+_\Sigma$ 表示 $\cup$. 注意这里的 $\cup$ 有无穷多个, 从这个定义可以直接看出 $(A^*)^* = A^*$, 这样一来, $\square^*$ 就会是一个幂等运算.</p>
<p>可以验证, 正则语言集 $\textbf{Reg}_\Sigma$ 连同其上的加法 $+_\Sigma$ 和乘法 $\times_\Sigma$ 构成一个半环 $(\textbf{Reg}_\Sigma, +_\Sigma, \times_\Sigma, 0_\Sigma, 1_\Sigma)$. 从匹配的角度, 我们还能明白以下两点为何是必须的.</p>
<p>$\quad (i)~$ 加法单位 $0_\Sigma$ 对于乘法运算 $\times_\Sigma$ 的吸收性. <br />
$\quad (ii)$ 加法 $+_\Sigma$ 是幂等运算, 即 $a+a = a$.</p>
<p>现在, 从半环 $(\textbf{Reg}_\Sigma, +_\Sigma, \times_\Sigma)$ 出发, 在其上定义偏序 $a \le b$ $\iff$ $a+b=b$, 等价地 $\exists ~ x$ 使得 $a+x = b$. 最后, 可以验证 $\square^*$ 与定义的偏序还满足下面的公理.</p>
<p>$$
\begin{aligned}
(1) &amp;~~ 1+aa^* \le a^* \\
(2) &amp;~~ 1+a^*a \le a^* \\
(3) &amp;~~ ax \le x \implies a^* x \le x \\
(4) &amp;~~ xa \le x \implies xa^* \le x
\end{aligned}
$$</p>
<p>这使 $\textbf{Reg}_\Sigma$ 成为 Kleene 代数 $(\textbf{Reg}_\Sigma, +_\Sigma, \times_\Sigma, \square^*)$. 反过来, 按照公理化定义的顺序, 从正则语言集的性质 $(1)\sim(4)$ 能够直接得出 Kleene 星运算 $\square^*$ 的定义, 正则语言集本身就是 Kleene 代数的一个模型. Kleene 代数的另一个简单例子是 Boole 代数, 其中的 $a^* = 1$. 而热带半环尽管有幂等加法, 但可以验证它并非 Kleene 代数.</p>
</details></section>
<section class="block" data-taxon="Exegesis"><details ><summary id="linear-algebra-semiring"><header><h1><span class="taxon">Exegesis. </span>关于半环的注释 <a class="slug" href="/linear-algebra/semiring">[semiring]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\N{\mathbf{N}}$
$\gdef\Z{\mathbf{Z}}$
$\gdef\Q{\mathbf{Q}}$
$\gdef\R{\mathbf{R}}$
$\gdef\C{\mathbf{C}}$
$\gdef\Mat{\operatorname{Mat}}$</p>
<p>半环取消了环中加法逆的存在, 仅仅从定义上来看, 可能很难认识到半环的作用, 并轻率地认为半环是一种性质不够好的结构, 哪怕考虑一些具体的例子如布尔代数和 $\N$ 也难以影响这样的印象. 但是人们对于环的印象就完全不同, 因为环总是与域紧密关联着, 为此人们可能会列举出下面的证据:</p>
<p>$\quad (i)$ 整数环 $\Z$ 处于数论研究的中心位置, 它的分式域是有理数域 $\Q$, 这种构造适用于任何整环 $R$, 通过商 $(R \times R \smallsetminus \{0\})/\sim$ 来完成, 此处 $(a,b) \sim (c,d) \iff ad = bc$. 从域 $\Q$ 出发, 构造以它为系数的多项式, 这些多项式将形成一个新的环结构 $\Q[x]$. 现在我们从中取一个不可约多项式 $p(x)$, 然后再利用 $\Q[x]$ 对 $p$ 生成的理想 $(p)$ 的商, 于是我们又得到一个新的域 $\Q[x]/(p)$. 另一方面, 记 $p(x)$ 在商环中的一个根为 $r$, 能够验证 $\Q[r] \cong \Q[x]/(p)$. $\Q[r]$ 的重要之处在于, 它是包含 $\Q$ 和 $r$ 的最小的域. 如果我们把这个步骤中的 $\Q$ 换成 $\R$ 并让 $p(x) = x^2+1$, 我们就得到了 $\C$.</p>
<p>$\quad (ii)$ 同样从域 $\Q$ 出发, 另一种从域中产生环的方法是考虑以它为元素的矩阵. 类似的, 所有的这些矩阵构成矩阵环 $\Mat(\Q)$. 不同于一般是交换环的多项式环, 矩阵环往往非交换. 仅从统计的意义上说, 在数学之外的领域, 恐怕很少有什么结构能够比矩阵更为重要.</p>
<p>现在请回忆, 正如我们可以把 $(i)$ 当中用于构造多项式环的域 $\Q$ 更换为一般的交换环 $R$, 这个时候 $R[x]$ 仍然是交换环. 当我们把 $(ii)$ 的域 $\Q$ 更换为半环 $\mathcal{Q}$ 时, $\Mat_{n \times n}(\mathcal{Q})$ 能够恰好地成为半环. 这个事实导致了半环上能够操作相当一部分的线性代数, 并且在很多场景下激发了半环结构的用途 <sup class="footnote-reference" id="linear-algebra_semiring_semiring-applications-back"><a href="#linear-algebra_semiring_semiring-applications">1</a></sup>. 另外值得注意的一点是, 矩阵半环上可以通过 Leibniz 律定义导子.</p>
<div class="footnote-definition" id="linear-algebra_semiring_semiring-applications">
  <sup class="footnote-definition-label"><a href="#linear-algebra_semiring_semiring-applications-back">1</a></sup>
<p>例如: 求解最短路径问题的 Floyd 算法, 计算 Boole 矩阵传递闭包的 Warshall 算法, 求逆矩阵的 Gauss–Jordan 消元, 以及 Kleene 对 “每个正则语言都可被正则表达式定义” 的证明.</p>
</div>
</details></section>
<section class="block" data-taxon="Definition"><details ><summary id="linear-algebra-star-semiring"><header><h1><span class="taxon">Definition. </span>星半环 <a class="slug" href="/linear-algebra/star-semiring">[star-semiring]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\quads#1{\quad #1 \quad}$</p>
<p>$\gdef\Q{\mathbf{Q}}$
$\gdef\R{\mathbf{R}}$</p>
<p>仅仅只是为半环添加闭包或者说 Kleene 星运算, 所得到的结构称为星半环. 与 <span class="link local"><a href="/linear-algebra/regular-language" title="正则语言集 [linear-algebra/regular-language]">Kleene 代数</a></span> 类似, 星半环也通过递归公理定义星运算. 但是 <span class="link local"><a href="/linear-algebra/regular-language" title="正则语言集 [linear-algebra/regular-language]">Kleene 代数</a></span> 所要求的幂等加法对于很多数字系统如 $\Q, \R$ 而言都难以实现, 因为这破坏了 Archimedes 性. 如果我们取消幂等加法这一点, 此时所得到的结构是完备星半环或称为闭半环, 因为 <span class="link local"><a href="/linear-algebra/regular-language" title="正则语言集 [linear-algebra/regular-language]">Kleene 代数</a></span> 本身还允许了无穷和 $\sum_{i \ge 0}a^i$ 以及 $a^*$ 的存在性, 这就是称它 “完备” 或者 “闭” 的原因.</p>
<p>下面来介绍一个重要的例子. 非负扩展实数集 $\R_{\ge 0} \cup \{\infty\}$ 也即 $\R_{\ge 0}$ 的单点紧化连同实数的通常加法和乘法构成闭半环, 其中 $a \ne 1$ 时 $a^* = \frac1{1-a}$, 否则 $a^* = \infty$. 注意这个结构中不存在非零的加法逆 $-a$, 而乘法逆 $a^{-1}$ 则是未必存在. $\frac1{1-a}$ 应当被认为是一个整体记号, 或者说它实际上是无穷和 $1 + a + a^2 + \cdots$ 在 $\R_{\ge 0}$ 被添入全体非零加法逆 $\R_{\lt0}$ 后所得的环 $\R$ 中于 $(-1,1)$ 处收敛的结果. 然后由于</p>
<p>$$
\R_{\ge 0} ~ \cap ~ \{a &lt; 1 : a \in \R_{\ge 0}\} \quads= [0, 1) \spaces\subset (-1,1)
$$</p>
<p>从而在闭半环的 $a&lt;1$ 处继续沿用这个记号. 这样, 一旦当我们扩大到环 $\R$ 时, 闭半环 $\R_{\ge 0} \cup \{\infty\}$ 当中得出的结果仍然有效. 我们在这里要求 $\R_{\ge 0} \cup \{\infty\}$ 还有另一个原因, 如果对所有 $a$ 都定义 $a^* = \frac1{1-a}$, 那么 $a^{***} = a$, 即 $\square^*$ 是 $3$-幂等的运算, 这会让 Kleene 闭包和正则表达式的概念无从谈起.</p>
<p>我们的论证可以直接拓展到一般的闭半环 $(\mathcal{Q}, +, \times, \square^*)$. 当其中的半环 $(\mathcal{Q}, +, \times)$ 被替换为环 $(R, +, \times)$ 时, 如果 $R$ 当中的 $\frac1{1-a}$ 在 $\mathcal{Q}$ 当中存在, 则 $\mathcal{Q}$ 当中的 $a^*$ 对应于 $R$ 当中的 $\frac1{1-a}$. 当然, 隐含的条件是, $R$ 的加法和乘法与 $\mathcal{Q}$ 兼容.</p>
</details></section>
<section class="block" data-taxon="Exegesis"><details ><summary id="linear-algebra-amtx-2A"><header><h1><span class="taxon">Exegesis. </span>矩阵闭包 <a class="slug" href="/linear-algebra/amtx-2A">[amtx-2A]</a></h1><div class="metadata"><ul><li class="meta-item">May 10, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\Mat{\operatorname{Mat}}$
$\gdef\R{\mathbf{R}}$
$\gdef\str#1{{\footnotesize #1}}$
$\gdef\sstr#1{~{\footnotesize #1}~}$</p>
<p>记 $\R_{\ge 0}^* = \R_{\ge 0} \cup \{\infty\}$. 从现在起, 我们对于 $\R_{\ge 0}^* ~ (= \mathcal{Q})$ 当中的许多有用的观察可以安全地转移到 $\R ~ (= R)$. 根据 <span class="link local"><a href="/linear-algebra/semiring" title="关于半环的注释 [linear-algebra/semiring]">半环注释</a></span>, 我们优先考虑 $\Mat_{n \times n}(\mathcal{Q})$, 从最小的非平凡情况 $n=2$ 开始, 由于我们的目的是计算矩阵的逆, 故取这个半环的可逆子集也即幺半群 $\Mat_{n \times n}(\mathcal{Q})^\times$,  其中的元素会形如</p>
<p>$$
M \spaces= \begin{pmatrix} a &amp; b \\ c &amp; d \end{pmatrix}, \quad
ad - bc \spaces\neq 0
$$</p>
<p>请注意, 接下来应该考虑的是 $\square^*$. 因为我们要利用 $X^* = \frac1{1-X}$ 这个关系间接地计算 $M^{-1}$. 只要取 $X = 1-M$, 我们就得到了</p>
<p>$$
(1-M)^* \spaces= \frac1M \quad (= ~ M^{-1})
$$</p>
<p>此处的 $1-M$ 非常微妙, 因为一般情况下它只能存在于 $\Mat_{n \times n}(R)$ 而非 $\Mat_{n \times n}(\mathcal{Q})$.  如果我们暂时忽略这个问题, 那么根据 <span class="link local"><a href="/linear-algebra/semiring" title="关于半环的注释 [linear-algebra/semiring]">半环注释</a></span>, 由于矩阵的加法直接就是 $\mathcal{Q}$ 或者 $R$ 的加法, 而乘法来自线性空间. 此时 $M$ 与 $M^*$ 之间存在一种直接的关系, 可以说成 $(M^*)_{ij} = $ 有向图 $G$ 中所有 $i \to j$ 的路径.</p>
<p><figure><img src="/linear-algebra/amtx-2B.svg" class="color-invert"/><figcaption>State diagram $G$ for $M \to M^*$</figcaption></figure></p>
<p>具体的说, 固定下标 $i,j$, 分量 $(M^*)_{ij}$ 的值会等于以 $M$, $M^*$ 为结点, $M_{ij}$ 为箭头的 $G$ 中所有 $i \to j$ 的路径 $\hom(i,j)$ 的正则表达式. 并且从这些路径中我们也能够写出 $\hom(i,j)$ 对应的正则表达式, 这就为计算 $(M^*)_{ij}$ 提供了可能.</p>
<p>$$\begin{aligned}
  1 \longrightarrow 1 &amp;: \quad (a+b d^*c)^* \\
  1 \longrightarrow 2 &amp;: \quad (a+b d^*c)^*b d^* \\
  2 \longrightarrow 1 &amp;: \quad d^* c(a+b d^*c)^* \\
  2 \longrightarrow 2 &amp;: \quad d^* + d^*c(a+b d^*c)^*b d^* \\
\end{aligned}$$</p>
<p>简单起见记 $\alpha = (a+b d^*c)^*$, 那么上一段的讨论就是在说</p>
<p>$$
M^* \spaces= \begin{pmatrix}
\alpha &amp; \alpha b d^* \\
d^* c \alpha &amp; \quad d^* + d^*c \alpha b d^* \tag{1.1}
\end{pmatrix}
$$</p>
<p>这里有两个不应忽视的问题. 其一, 虽然我们考虑的是 $\Mat_{n \times n}(\mathcal{Q})$ 上的 Kleene 星运算 $\square^*$, 但右侧的表达式中涉及了 $\mathcal{Q} ~ (= \R_{\ge 0}^*)$ 上的 Kleene 星运算 $\square^*$, 根据之前的内容, 我们可以自然地确定它就是 $a \mapsto \frac1{1-a}$. 这允许我们从 $M$ 的各个分量 $M_{ij}$ 计算出 $M^*$. 更加重要的是, 由于 $\Mat_{n \times n}(\mathcal{Q})$ 也能通过这样的方式构成闭半环, 这实际上允许我们将 $(1.1)$ 的适用范围拓展到任意大小的方阵 $\Mat_{n \times n}(\mathcal{Q})$, 此时的 $a,b,c,d$ 能够选取为 $M$ 的分块矩阵. 其二, $d^* + d^*c \alpha b d^*$ 在一般的星半环中不能直接替换为 $(d+ca^*b)^*$, 可替换的前提被称为 <span class="link local"><a href="/linear-algebra/conway-condition" title="闭半环的 Conway 条件 [linear-algebra/conway-condition]">Conway 条件</a></span>.</p>
</details></section>
<section class="block" data-taxon="Example"><details ><summary id="linear-algebra-amtx-3A"><header><h1><span class="taxon">Example. </span>二阶矩阵的逆 <a class="slug" href="/linear-algebra/amtx-3A">[amtx-3A]</a></h1><div class="metadata"><ul><li class="meta-item">May 9, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>作为热身运动, 我们现在来恢复一个经典的事实, 即二阶矩阵的逆. 对于二阶可逆矩阵 $M$, 其逆 $M^{-1}$ 可以由它的四个分量 $a,b,c,d$ 经由 $M \to 1-M \to (1-M)^*$ 这样的过程得到, 这里 $1$ 当然是单位矩阵.</p>
<p>$$
\begin{aligned}
M^{-1}
&amp;\spaces= (1-M)^* \\
&amp;\spaces= \begin{pmatrix}1 - a &amp; -b \\ -c &amp; 1 - d\end{pmatrix}^* \\
&amp;\spaces= \begin{pmatrix}
  (1 - a + b(1-d)^*c)^* &amp; \quad \cdots \quad \\ 
  \quad \cdots \quad &amp; \quad \cdots \quad
  \end{pmatrix} \\
&amp;\spaces= \frac{1}{a d - b c} \begin{pmatrix}d &amp; -b \\ -c &amp; a\end{pmatrix}
\end{aligned}
$$</p>
</details></section>
<section class="block" data-taxon="Example"><details ><summary id="linear-algebra-amtx-3B"><header><h1><span class="taxon">Example. </span>分块矩阵的逆 <a class="slug" href="/linear-algebra/amtx-3B">[amtx-3B]</a></h1><div class="metadata"><ul><li class="meta-item">May 10, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>我们下面来处理 $n \times n$ 矩阵 ($n \ge 3$) 的逆, 将其分块并假定后续要取逆的矩阵都是非奇异的</p>
<p>$$
M \spaces= \begin{pmatrix} A &amp; B \\ C &amp; D \end{pmatrix}, \quad 1-M \spaces= \begin{pmatrix} 1-A &amp; -B \\ -C &amp; 1-D \end{pmatrix}
$$</p>
<p>我们还是直接计算 $(1-M)^*$, 实际上这非常容易. 回顾 $M^*$</p>
<p>$$
M^* \spaces= \begin{pmatrix}
(A+BD^*C)^* &amp; (A+BD^*C)^*BD^* \\ 
D^*C(A+BD^*C)^* &amp; D^* + D^*C(A+BD^*C)^*BD^* 
\end{pmatrix}
$$</p>
<p>类似的记 $\alpha_\square$ 为方阵 $\square$ 分为 $4$ 块后的左上角第 $1$ 部分. $\alpha_{M^*} = (A+BD^*C)^*$, $\alpha_{M^{-1}} = \alpha_{(1-M)^*}$, 则</p>
<p>$$
\begin{aligned}
\alpha_{M^{-1}}
&amp;\spaces= (1 - A + B(1-D)^*C)^* \\
&amp;\spaces= (1 - A + BD^{-1}C)^* \\
&amp;\spaces= (1 - (A - BD^{-1}C))^* \\
&amp;\spaces= (A - BD^{-1}C)^{-1}
\end{aligned}
$$</p>
<p>同样, 考虑分块的其他部分</p>
<p>$$
\begin{CD}
M @&gt;&gt;&gt; 1-M \\
@VVV  @VVV \\
M^* @&gt;&gt;&gt; (1-M)^*
\end{CD}
$$</p>
<p>在 $M \to 1-M$ 这个箭头下, $M$ 当中所有的 $D$ 会被替换为 $1-D$, 因此 $M^*$ 当中所有的 $D^*$ 可以直接替换为 $D^{-1}$. 而 $B, C$ 在 $M \to 1-M$ 下替换为 $-\square$, 于是现在立刻有</p>
<p>$$
\begin{aligned}
M^{-1}
&amp;\spaces= \begin{pmatrix} \alpha_{M^{-1}} &amp; -\alpha_{M^{-1}} BD^{-1} \\ -D^{-1}C \alpha_{M^{-1}} &amp; D^{-1} + D^{-1}C \alpha_{M^{-1}} BD^{-1} \end{pmatrix} \\
&amp;\spaces= \begin{pmatrix} (A - BD^{-1}C)^{-1} &amp; -(A - BD^{-1}C)^{-1} BD^{-1} \\ -D^{-1}C (A - BD^{-1}C)^{-1} &amp; D^{-1} + D^{-1}C (A - BD^{-1}C)^{-1} BD^{-1} \end{pmatrix} \\
\end{aligned}
$$</p>
<p>在这里, 我们得到了一个相当经典且重要的结果, 即分块求逆.</p>
</details></section></p>
</details></section></p>
</details></section>
<section class="block" data-taxon=""><details ><summary id="daily-surf-index"><header><h1><span class="taxon"></span>Daily Surf <a class="slug" href="/daily-surf/index">[daily-surf]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p><section class="block" data-taxon=""><details ><summary id="daily-surf-bevy"><header><h1><span class="taxon"></span><span class="link external"><a href="https://github.com/bevyengine/bevy" title="Bevy [https://github.com/bevyengine/bevy]">Bevy</a></span> 备注 <a class="slug" href="/daily-surf/bevy">[bevy]</a></h1><div class="metadata"><ul><li class="meta-item">August 29, 2025</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<h4>E0786</h4>
<pre><code class="language-sh">error[E0786]: found invalid metadata files for crate `serde`                               
  --&gt; C:\Users\...\.cargo\registry\src\...\bevy_math-0.16.1\src\ray.rs:60:42
   |
60 | #[cfg_attr(feature = "serialize", derive(serde::Serialize, serde::Deserialize))]      
   |                                          ^^^^^^^^^^^^^^^^
   |
   = note: failed to mmap rmeta metadata: '\\?\D:\...\target\release\deps\libserde-f884fbba2cdca77e.rmeta'
   = note: this error originates in the derive macro `serde::Serialize` (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>如果在 Windows 设备上 <code>cargo build --release</code> 时遇到这个错误, 那很可能是 Windows 的路径长度限制所致 <sup class="footnote-reference" id="daily-surf_bevy_path-length-back"><a href="#daily-surf_bevy_path-length">1</a></sup>. 管理员身份运行如下 Powershell 命令即可启用长路径支持.</p>
<pre><code class="language-sh">New-ItemProperty -Path "HKLM:SYSTEM\CurrentControlSet\Control\FileSystem" -Name "LongPathsEnabled" -Value 1 -PropertyType DWORD -Force
</code></pre>
<p>另见 <span class="link external"><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=powershell#registry-setting-to-enable-long-paths" title="Registry setting to enable long paths - Microsoft Learn [https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=powershell#registry-setting-to-enable-long-paths]">Registry setting to enable long paths - Microsoft Learn</a></span>.</p>
<div class="footnote-definition" id="daily-surf_bevy_path-length">
  <sup class="footnote-definition-label"><a href="#daily-surf_bevy_path-length-back">1</a></sup>
<p>In the Windows API (with some exceptions discussed in the following paragraphs), the maximum length for a path is MAX_PATH, which is defined as 260 characters.</p>
</div>
</details></section>
<section class="block" data-taxon="Poetry"><details ><summary id="daily-surf-adams"><header><h1><span class="taxon">Poetry. </span>Adams 谱序列 <a class="slug" href="/daily-surf/adams">[adams]</a></h1><div class="metadata"><ul><li class="meta-item">August 21, 2025</li><li class="meta-item"><span class="link local"><a href="/person/yuni" title="Yuniversal Y. Creeper 🥐 [person/yuni]">Yuniversal Y. Creeper 🥐</a></span></li></ul></div></header></summary>
<link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC&display=swap" rel="stylesheet">
<style>
.kaiti {
  font-family: "LXGW WenKai TC", serif;
  font-style: normal;
}
</style>
<blockquote class="kaiti">
<p>每个人都是独一无二的笨蛋</p>
<p>看到独一无二的宿命, 向另一个笨蛋提枪冲锋</p>
<p>死去, 照耀着独一无二的光荣</p>
</blockquote>
</details></section>
<section class="block" data-taxon=""><details ><summary id="daily-surf-sublime-text-config"><header><h1><span class="taxon"></span>Sublime Text 4 高分屏设置 <a class="slug" href="/daily-surf/sublime-text-config">[sublime-text-config]</a></h1><div class="metadata"><ul><li class="meta-item">February 21, 2025</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>装好 <span class="link external"><a href="https://github.com/SublimeText/PackageDev" title="<code>PackageDev</code> [https://github.com/SublimeText/PackageDev]"><code>PackageDev</code></a></span> <sup class="footnote-reference" id="daily-surf_sublime-text-config_package-resource-viewer-back"><a href="#daily-surf_sublime-text-config_package-resource-viewer">1</a></sup> 包后, 修改主题文件如 <code>Default.sublime-theme</code> 即可.</p>
<p>侧边栏字体大小</p>
<pre><code class="language-json">"class": "sidebar_label",
"fg": "var(sidebar_label)",
"font.face": "var(font_face)",
"font.size": "var(font_size)"  // line 264
</code></pre>
<p>侧边栏文件树条目 <code>padding</code></p>
<pre><code class="language-json">"class": "sidebar_tree",
"platforms": ["windows"],
"row_padding": [6, 5, 4, 5],  // line 226
</code></pre>
<p>文件 Tab 字体大小</p>
<pre><code class="language-json">"class": "tab_label",
"font.face": "var(font_face)",
"font.size": "var(font_size_lg)",  // line 938
</code></pre>
<div class="footnote-definition" id="daily-surf_sublime-text-config_package-resource-viewer">
  <sup class="footnote-definition-label"><a href="#daily-surf_sublime-text-config_package-resource-viewer-back">1</a></sup>
<p><span class="link external"><a href="https://packagecontrol.io/packages/PackageResourceViewer" title="<code>PackageResourceViewer</code> [https://packagecontrol.io/packages/PackageResourceViewer]"><code>PackageResourceViewer</code></a></span> 这个包也能用, 不过相对而言太旧了.</p>
</div>
</details></section>
<section class="block" data-taxon=""><details ><summary id="daily-surf-sagemath-theme"><header><h1><span class="taxon"></span>Sagemath Jupyter 主题设置 <a class="slug" href="/daily-surf/sagemath-theme">[sagemath-theme]</a></h1><div class="metadata"><ul><li class="meta-item">February 17, 2025</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>如果你是一个没有定制化需求的 <span class="link external"><a href="https://www.sagemath.org" title="Sagemath [https://www.sagemath.org]">Sagemath</a></span> 用户或者单纯地使用 Jupyter Notebook 连接一些与 <span class="link external"><a href="https://www.sagemath.org" title="Sagemath [https://www.sagemath.org]">Sagemath</a></span> 无关的服务, 你遇到本文所关心问题的可能性是很低的, 这个主要有以下两个原因.</p>
<ol>
<li>
<p>Sagemath Jupyter Notebook 在 <span class="link external"><a href="https://code.visualstudio.com" title="Visual Studio Code [https://code.visualstudio.com]">Visual Studio Code</a></span> 上几乎不能使用. 这是因为, 所有由 <span class="link external"><a href="https://www.mathjax.org" title="MathJax [https://www.mathjax.org]">MathJax</a></span> 提供渲染的公式都无法呈现, 甚至连 Cell 也不出现. 于是最稳妥的做法就变成了使用浏览器访问 Jupyter Notebook.</p>
</li>
<li>
<p>Jupyter Notebook 的主题设计非常混乱, 常用主题位于 <span class="link external"><a href="https://github.com/dunovank/jupyter-themes" title="jupyterthemes [https://github.com/dunovank/jupyter-themes]">jupyterthemes</a></span> 包, 但是这个包的文档和使用示例并不适用于 <span class="link external"><a href="https://www.sagemath.org" title="Sagemath [https://www.sagemath.org]">Sagemath</a></span>.</p>
</li>
</ol>
<p>这两点使得问题看上去不太容易. 因为一般的, 如果用户使用 <span class="link external"><a href="https://code.visualstudio.com" title="Visual Studio Code [https://code.visualstudio.com]">Visual Studio Code</a></span> 访问 Jupyter Notebook 就完全不需要担心主题问题, 于是相应的可能在互联网上存在的解决方案就会变少. 关于第二点, 如果尝试在 Jupyter Notebook 当中执行下面这样的程序</p>
<pre><code class="language-python">from jupyterthemes import get_themes, jtplot
import jupyterthemes as jt
from jupyterthemes.stylefx import set_nb_theme

set_nb_theme('monokai')
</code></pre>
<p>确实能够切换到 <code>monokai</code> 主题, 同时你还会发现当前使用的 Jupyter Notebook 的 <code>Header</code> 和 <code>Toolbar</code> 消失了 <sup class="footnote-reference" id="daily-surf_sagemath-theme_toolbar-display-none-back"><a href="#daily-surf_sagemath-theme_toolbar-display-none">1</a></sup>. 如果你尝试检索相关信息, 你会在 <span class="link external"><a href="https://github.com/dunovank/jupyter-themes" title="jupyterthemes [https://github.com/dunovank/jupyter-themes]">jupyterthemes</a></span> 的文档中找到像是</p>
<pre><code class="language-sh">jt -t monokai -T -N
</code></pre>
<p>这样的做法, 这里的 <code>-T</code> 是 Toolbar Visible, <code>-N</code> 是 Name &amp; Logo Visible. 然后遗憾地发现这不会对 Sagemath 的 Jupyter Notebook 造成任何作用. 同时, 这样的设置也是临时的, 如果希望将某个特定的主题作为默认主题, 就得另谋他法.</p>
<p>最直接的方法是, 找到像下面这样的编译后的样式文件</p>
<pre><code>sagemath/runtime/opt/sagemath-9.3/local/lib/python3.7/site-packages/jupyterthemes/styles/compiled/monokai.css
</code></pre>
<p>然后覆盖到</p>
<pre><code>&lt;SAGE_HOME&gt;/.sage/jupyter-4.1/custom/custom.css
</code></pre>
<p>这样你就得到了一个永久生效的样式设置. 随后可以通过修改 <code>div#maintoolbar</code> 和 <code>#header-container</code> 的 <code>display</code> 为 <code>block</code> 重新显示这两个组件. 修改 <code>.MathJax</code> 的 <code>font-size</code> 为 <code>120%</code> 或者更大则能够增大渲染后公式的字号.</p>
<p>$\textbf{Remark.}$ 一个无关正文的冷知识: 如果你需要带完整头文件的 C / C++ 编译器, 但还没安装 GCC 或者 Clang, 那 <code>sagemath/runtime/bin</code> 目录下就有一个, 头文件位于 <code>sagemath/runtime/usr/include</code>.</p>
<div class="footnote-definition" id="daily-surf_sagemath-theme_toolbar-display-none">
  <sup class="footnote-definition-label"><a href="#daily-surf_sagemath-theme_toolbar-display-none-back">1</a></sup>
<p>从编译后的样式文件中我们可以看到, <code>div#maintoolbar</code> 和 <code>#header-container</code> 确实被设置为了 <code>display: none</code>.</p>
</div>
</details></section>
<section class="block" data-taxon=""><details ><summary id="daily-surf-git-filter-branch"><header><h1><span class="taxon"></span>Git 过滤分支 <a class="slug" href="/daily-surf/git-filter-branch">[git-filter-branch]</a></h1><div class="metadata"><ul><li class="meta-item">February 15, 2025</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>一个常见的需求是对已经存在的 <span class="link external"><a href="https://git-scm.com/docs/git-commit" title="git commit [https://git-scm.com/docs/git-commit]">git commit</a></span> 历史作出修改. 如果目标 commits 都存在于本地分支, 那么一组 <span class="link external"><a href="https://git-scm.com/docs/git-rebase" title="<code>rebase</code> [https://git-scm.com/docs/git-rebase]"><code>rebase</code></a></span> 就能解决问题. 但若是要修改已经推送至远程仓库或托管平台 <sup class="footnote-reference" id="daily-surf_git-filter-branch_host-platform-back"><a href="#daily-surf_git-filter-branch_host-platform">1</a></sup> 则没有一步到位的操作, 且对于真实的多人协作仓库来说, 这么做的潜在危害远高于 <span class="link local"><a href="/daily-surf/git-filter-branch" title="Git 过滤分支 [daily-surf/git-filter-branch]">修改 commits 历史</a></span> 所得到的短期好处 <sup class="footnote-reference" id="daily-surf_git-filter-branch_alternative-approach-back"><a href="#daily-surf_git-filter-branch_alternative-approach">2</a></sup>. 因此, 接下来的讨论都是以接受 “潜在危害” 这一点作为前提而进行的.</p>
<p>这里只说方法. 即便对于已经提交的 <span class="link external"><a href="https://git-scm.com/docs/git-commit" title="commit [https://git-scm.com/docs/git-commit]">commit</a></span>, 其修改仍然可用 <span class="link external"><a href="https://git-scm.com/docs/git-rebase" title="<code>rebase</code> [https://git-scm.com/docs/git-rebase]"><code>rebase</code></a></span>. 但此时不能直接推送, 我们需要额外做一步 <span class="link external"><a href="https://git-scm.com/docs/git-filter-branch" title="<code>filter-branch</code> [https://git-scm.com/docs/git-filter-branch]"><code>filter-branch</code></a></span>.</p>
<pre><code>git filter-branch --force     
</code></pre>
<p><span class="link external"><a href="https://git-scm.com/docs/git-filter-branch" title="<code>filter-branch</code> [https://git-scm.com/docs/git-filter-branch]"><code>filter-branch</code></a></span> 配合 <span class="link external"><a href="https://git-scm.com/docs/git-replace" title="<code>replace</code> [https://git-scm.com/docs/git-replace]"><code>replace</code></a></span> 或者 <code>&lt;GIT_DIR&gt;/info/grafts</code> 也能够用来快速清除某次 commit 之前的所有记录. <code>grafts</code> 文件内是 commit 的 hash 值, 可以通过 <code>git log</code> 查询.</p>
<p>注意, <code>grafts</code> 目前已经被标记为 deprecated, 不过依旧可用.</p>
<pre><code>hint: Support for &lt;GIT_DIR&gt;/info/grafts is deprecated
hint: and will be removed in a future Git version.
hint:
hint: Please use "git replace --convert-graft-file"
hint: to convert the grafts into replace refs.
hint:
hint: Turn this message off by running
hint: "git config advice.graftFileDeprecated false"
</code></pre>
<div class="footnote-definition" id="daily-surf_git-filter-branch_host-platform">
  <sup class="footnote-definition-label"><a href="#daily-surf_git-filter-branch_host-platform-back">1</a></sup>
<p>如 <span class="link external"><a href="https://github.com" title="Github [https://github.com]">Github</a></span>, <span class="link external"><a href="https://about.gitlab.com" title="GitLab [https://about.gitlab.com]">GitLab</a></span>, <span class="link external"><a href="https://sourcehut.org" title="SourceHut [https://sourcehut.org]">SourceHut</a></span>, <span class="link external"><a href="https://codeberg.org" title="Codeberg [https://codeberg.org]">Codeberg</a></span> 等.</p>
</div>
<div class="footnote-definition" id="daily-surf_git-filter-branch_alternative-approach">
  <sup class="footnote-definition-label"><a href="#daily-surf_git-filter-branch_alternative-approach-back">2</a></sup>
<p>这就是为何你应该对每个任务都开新的 <span class="link external"><a href="https://git-scm.com/docs/git-branch" title="分支 [https://git-scm.com/docs/git-branch]">分支</a></span>, 同时在每次正式 <span class="link external"><a href="https://git-scm.com/docs/git-push" title="推送 [https://git-scm.com/docs/git-push]">推送</a></span> 之前都 <span class="link external"><a href="https://git-scm.com/docs/git-rebase" title="<code>rebase</code> [https://git-scm.com/docs/git-rebase]"><code>rebase</code></a></span>, 来避免污染主分支的 commit 树.</p>
</div>
</details></section>
<section class="block" data-taxon="Exegesis"><details ><summary id="daily-surf-baby-viewpoint"><header><h1><span class="taxon">Exegesis. </span>日经观点 <a class="slug" href="/daily-surf/baby-viewpoint">[baby-viewpoint]</a></h1><div class="metadata"><ul><li class="meta-item">February 11, 2025</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\Mat{\operatorname{Mat}}$
$\gdef\vol{\operatorname{vol}}$
$\gdef\diag{\operatorname{diag}}$
$\gdef\d{\operatorname{d}}$
$\gdef\R{\mathbf{R}}$
$\gdef\Q{\mathbf{Q}}$</p>
<ol>
<li>
<p>一个矩阵 $A \in \Mat_{n \times n}(\R)$ 所确定的线性映射 $\alpha: \R^n \to \R^n$ 作用在 $X \in \R^n$ 上, 此映射对 $X$ 的 (有向) 体积 $\vol(X)$ 的缩放量为 $\det A$. 即 $\vol(\alpha X) = \det A \cdot \vol(X)$. 特别地取 $A = \diag(a,b)$, 然后乘单位圆 $u^2+v^2=1$ 上一点构成的向量 $(u,v)$, 得到满足椭圆方程 $\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$ 的 $(x,y)$, 这样便能看出椭圆的面积 $S = \det A \cdot \pi$.</p>
</li>
<li>
<p>设 $\omega$ 是一个 $k$-形式, 它的两次微分 $\d(\d \omega) = 0$. 另一方面, 考虑一个有向流形 $\Omega$ 和它的边缘 $\partial \Omega$, 我们知道 $\partial(\partial M) = \varnothing$. 这两件事相互对偶.</p>
</li>
<li>
<p>考虑数域 $K=\Q(\alpha_1, \cdots, \alpha_i)$ 的一个存在于上的历史原因是, 在适当的 $K$ 中考虑能够使原本在 $\Q$ 上无法分解的 Diophantus 方程因式分解.  如 $\Q(\sqrt{-7})$ 能使 Ramanujan–Nagell 方程 $x^2=2^n-7$ 改写为 $(x+\sqrt{-7})(x-\sqrt{-7})=2^n$. Fermat 方程 $x^n+y^n=z^n$ 能够在 $\Q(\zeta_n)$ 上分解成 $x^n=(z-y)(z-\zeta_n y) \cdots (z-\zeta_n^{n-1} y)$, 这是 <span class="link local"><a href="/person/ernst-kummer" title="Ernst Eduard Kummer [person/ernst-kummer]">Kummer</a></span> 提出理想数概念的一个原因.</p>
</li>
</ol>
</details></section>
<section class="block" data-taxon=""><details ><summary id="daily-surf-fibonacci-flip"><header><h1><span class="taxon"></span>Fibonacci 抛硬币 <a class="slug" href="/daily-surf/fibonacci-flip">[fibonacci-flip]</a></h1><div class="metadata"><ul><li class="meta-item">January 24, 2025</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>抛一枚硬币 $n \ge 2$ 次且从不连续出现正面, 这样的可能共有 $F_{n+2}$ 种, 这里的 $F_{n+2}$ 是从零开始的 Fibonacci 数列. 我们把抛 $n$ 次不连续出现正面的可能数记为 $S_n$, 考虑相邻的两次抛硬币, 假设第 $i$ 次掷硬币为正面, 则第 $i+1$ 次掷硬币只能是反面, 这个时候的所有可能为 $S_{n-2}$. 假设第 $i$ 次掷硬币为反面, 则第 $i+1$ 次掷硬币的结果可任意. 因此 $S_n = S_{n-1} + S_{n-2}$, 再利用初值 $S_1$, $S_2$ 就能解出 $S_n$.</p>
</details></section>
<section class="block" data-taxon=""><details ><summary id="daily-surf-nvidia-fps-gpu-cpu"><header><h1><span class="taxon"></span>屏幕右上角的 “FPS GPU CPU 延时” <a class="slug" href="/daily-surf/nvidia-fps-gpu-cpu">[nvidia-fps-gpu-cpu]</a></h1><div class="metadata"><ul><li class="meta-item">January 9, 2025</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>根据 <span class="link external"><a href="https://www.reddit.com/r/techsupport/comments/1b37zko/fps_gpu_cpu_and_lat_appearing_top_right_of_screen" title="这个 Reddit 问题 [https://www.reddit.com/r/techsupport/comments/1b37zko/fps_gpu_cpu_and_lat_appearing_top_right_of_screen]">这个 Reddit 问题</a></span>.</p>
<p>首先这项功能来自 <span class="link external"><a href="https://www.nvidia.com/en-us/geforce/guides/gfecnt/geforce-experience-shadowplay-is-now-share" title="Nvidia Overlay [https://www.nvidia.com/en-us/geforce/guides/gfecnt/geforce-experience-shadowplay-is-now-share]">Nvidia Overlay</a></span>, Intel 用户可以通过 <code>Alt+R</code> 开启这个 “PC 统计数据”<sup class="footnote-reference" id="daily-surf_nvidia-fps-gpu-cpu_concept-name-back"><a href="#daily-surf_nvidia-fps-gpu-cpu_concept-name">1</a></sup>
AMD 则是 <code>Ctrl + Shift + O</code>. 目前看来这个信息会出现在安装了 Nvidia APP (Beta) 或者 GeForce Experience 程序的设备上.</p>
<div class="footnote-definition" id="daily-surf_nvidia-fps-gpu-cpu_concept-name">
  <sup class="footnote-definition-label"><a href="#daily-surf_nvidia-fps-gpu-cpu_concept-name-back">1</a></sup>
<p>我们姑且按照该 Reddit 问题的某个回答这么称呼此信息.</p>
</div>
</details></section>
<section class="block" data-taxon=""><details ><summary id="daily-surf-wolfram-engine"><header><h1><span class="taxon"></span>Wolfram 引擎与 WLJS <a class="slug" href="/daily-surf/wolfram-engine">[wolfram-engine]</a></h1><div class="metadata"><ul><li class="meta-item">July 29, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>Wolfram 把 Mathematica 的内核 <span class="link external"><a href="https://www.wolfram.com/engine" title="Wolfram Engine [https://www.wolfram.com/engine]">Wolfram Engine</a></span> 单独拆出来并作为免费软件 <sup class="footnote-reference" id="daily-surf_wolfram-engine_wolfram-engine-size-back"><a href="#daily-surf_wolfram-engine_wolfram-engine-size">1</a></sup> 提供已不是什么新鲜事. 如不考虑实际的交互体验, 至少对于开发者而言, 为最新版 Mathematica 付费这件事基本就意味着只购买了个带官方服务支持的 <span class="link external"><a href="https://www.wolfram.com/notebooks" title="Wolfram Notebook [https://www.wolfram.com/notebooks]">Wolfram Notebook</a></span>.</p>
<p>Wolfram 引擎能直接使用 Homebrew 或 winget 等包管理器安装, 命令行功能由引擎自带的 <span class="link external"><a href="https://www.wolfram.com/wolframscript" title="Wolfram Script [https://www.wolfram.com/wolframscript]">Wolfram Script</a></span> 提供. 虽然能用, 但可想而知体验不会太好. 最早的一个方案是用 <span class="link external"><a href="https://code.visualstudio.com" title="Visual Studio Code [https://code.visualstudio.com]">Visual Studio Code</a></span> 和相关 Notebook 插件连接到 Wolfram 引擎, 这样一来比起纯命令行能好上不少, 但是对于习惯了 Mathematica 官方笔记本的用户来说还差点意思.</p>
<p>要是用户不在乎多装一个浏览器以此换来更好的 Notebook 体验, 那么开源的 WLJS 会是一个可供考虑的选择. Augsburg 大学的物理学家 Kirill Vasin 在 2023 年 11 月 16 日发布了 <span class="link external"><a href="https://github.com/JerryI/wolfram-js-frontend" title="WLJS [https://github.com/JerryI/wolfram-js-frontend]">WLJS</a></span> 的第一个长期版本 <sup class="footnote-reference" id="daily-surf_wolfram-engine_immortal-edition-back"><a href="#daily-surf_wolfram-engine_immortal-edition">2</a></sup>. WLJS 这几个字母是 Wolfram JS Frontend 的缩写, 从技术上说, 它是一个 <span class="link external"><a href="https://www.electronjs.org" title="Electron [https://www.electronjs.org]">Electron</a></span> APP, 如果用户的目的是对于 Mathematica 功能有高度依赖的科研用途, 那么多装一个浏览器的代价自然算不了什么. 另外 WLJS 的引导部分做的很不错, 也有不少很有意思但是 Wolfram Notebook 不具备的功能.</p>
<div class="footnote-definition" id="daily-surf_wolfram-engine_wolfram-engine-size">
  <sup class="footnote-definition-label"><a href="#daily-surf_wolfram-engine_wolfram-engine-size-back">1</a></sup>
<p>Windows 上的 Wolfram Engine 安装完成之后能占用大约 6.5GB 的磁盘空间. 比起 <span class="link external"><a href="https://www.sagemath.org" title="Sagemath [https://www.sagemath.org]">Sagemath</a></span> 还是大了不少.</p>
</div>
<div class="footnote-definition" id="daily-surf_wolfram-engine_immortal-edition">
  <sup class="footnote-definition-label"><a href="#daily-surf_wolfram-engine_immortal-edition-back">2</a></sup>
<p><span class="link external"><a href="https://github.com/JerryI/wolfram-js-frontend/releases/tag/1.0.1" title="The immortal edition [https://github.com/JerryI/wolfram-js-frontend/releases/tag/1.0.1]">The immortal edition</a></span>.</p>
</div>
</details></section>
<section class="block" data-taxon=""><details ><summary id="daily-surf-file-transfer"><header><h1><span class="taxon"></span>文件互传 <a class="slug" href="/daily-surf/file-transfer">[file-transfer]</a></h1><div class="metadata"><ul><li class="meta-item">May 18, 2022</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>因为各种读者可以想象的原因, 基于网络的面对面文件互传其实是一件经常会遇到的事. 笔者先后尝试过依赖于特定品牌的互传功能, 但时不时会遇到因未知原因导致的传输无法开始的问题. 索性另求他法.</p>
<p>我们假设有设备 $A$, $B$, 且 $A$ 将要发送文件 $F$ 给 $B$, 另可设文件 $F$ 充分大 (如 $\geqslant 1 \text{GB}$). 方案如下.</p>
<p>$B$ 联网且开热点, $A$ 连接热点. 随后 $A$ 通过 <span class="link external"><a href="https://termux.dev" title="Termux [https://termux.dev]">Termux</a></span> + <span class="link external"><a href="https://github.com/svenstaro/miniserve" title="miniserve [https://github.com/svenstaro/miniserve]">miniserve</a></span> 或其他等效软件在文件 $F$ 所在目录开启本地 <span class="link external"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" title="HTTP [https://developer.mozilla.org/zh-CN/docs/Web/HTTP]">HTTP</a></span> 服务器, 记下 IP. $B$ 使用浏览器访问 IP, 下载文件即可, 此时下载速率依赖于 $B$ 连接到的网络.</p>
</details></section></p>
</details></section>
<section class="block" data-taxon=""><details ><summary id="smaragdina-index"><header><h1><span class="taxon"></span>翠玉录 <a class="slug" href="/smaragdina/index">[smaragdina]</a></h1><div class="metadata"><ul></ul></div></header></summary>
<p><section class="block" data-taxon=""><details ><summary id="smaragdina-lynch-movie"><header><h1><span class="taxon"></span>Lynch 对于人们说 “你的电影没有意义” 的回应 <a class="slug" href="/smaragdina/lynch-movie">[lynch-movie]</a></h1><div class="metadata"><ul><li class="meta-item">February 21, 2025</li><li class="meta-item">David Lynch</li><li class="meta-item"><span class="link external"><a href="https://www.youtube.com/watch?v=YtlrDGRCAb8" title="Youtube [https://www.youtube.com/watch?v=YtlrDGRCAb8]">Youtube</a></span></li></ul></div></header></summary>
<style>
hint {
  color: gray;  
}
light {
  color: rgb(178, 113, 236);
}
</style>
<blockquote>
<p>I think I love ideas. I like a story that’s got some concrete <hint>you know</hint> structure but also holds abstractions. Life is filled with abstractions and the way we make heads tails of it is through intuition. And so people get used to film that pretty much explains itself a hundred percent. And they kind of turn off that you know beautiful thing of intuition when they’re looking at a film that has some abstractions. And some people on the other hand love these abstractions. <light>And it gives them room to dream.</light></p>
</blockquote>
<blockquote>
<p>A abstractions to me is a thing that cinema can say. And it’ so beautiful for me anyway to think about these pictures and some sounds flowing along together in the time in a sequence making a thing that can only really be said in cinema. It’s not words. It’s not just music. It’s the whole bunch of things coming together and making a thing that didn’t exist before. And that’s what i really love about it.</p>
</blockquote>
<blockquote>
<p>And then to answer your question a little further. It’s up to the people <hint>you know</hint> to <hint>you know</hint> find their own <hint>your know</hint> interpretation. It’s doesn’t really matter what I think. It’s all every screening no matter what even if all the frames of the film are exactly the same. But there no two screenings that are exactly the same. <light>It’s the viwer and the picture and the sound and it makes a circle and it just goes like that.</light> And so you just feel it and think it. That’s kind of intuition emotion and thinking together and come up make it have a sense to you.</p>
</blockquote>
<hr />
<p>译: 我想我钟爱的是理念本身. 我喜欢那种既有具象结构又蕴含抽象思维的故事. 生活本就充满抽象, 而我们理解它的方式就是通过直觉. 人们已经习惯了那些将一切解释得明明白白的电影, 当看到带有抽象元素的影片时, 他们往往会关闭那种美妙的直觉感知. 而另一些人却恰恰痴迷这种抽象, <light>因为这给了他们造梦的空间. </light></p>
<p>对我而言, 抽象正是电影独有的表达方式. 当画面与声音在流动的时间中交织, 形成唯有电影才能言说的意境 $—$ 这不是文字能描述的, 也不仅是音乐能呈现的, 而是所有元素共同创造出前所未有的存在 $—$ 这种构想本身就已美得令人心醉.</p>
<p>进一步回答你的问题: 观众完全可以根据自己的理解来诠释作品. 我的想法其实无关紧要. 每一次放映都是独特的相遇, 即便胶片帧数分毫不差, 但银幕光影与观者感受却不可重现. <light>这种循环生生不息, </light> 你只需去感受, 去思考, 让直觉情感与理性交融, 最终形成属于你自己的体验.</p>
</details></section>
<section class="block" data-taxon=""><details ><summary id="smaragdina-celtic-myths"><header><h1><span class="taxon"></span>The Celtic Myths 摘录 <a class="slug" href="/smaragdina/celtic-myths">[celtic-myths]</a></h1><div class="metadata"><ul><li class="meta-item">February 21, 2025</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link external"><a href="https://book.douban.com/subject/31093378" title="豆瓣 [https://book.douban.com/subject/31093378]">豆瓣</a></span></li></ul></div></header></summary>
<style>
wavy {
  text-decoration-line: underline;
  text-decoration-style: wavy;
}
quote {
  color: gray;
  font-style: italic;
}
pp { color: var(--slug-color) }
pp:before { content: '(p. ' }
pp:after { content: ')' }
</style>
<div style="margin: 0.5em;">中译版很烂, 所以引的是原文. </div>
<p>The preface to the 1957 edition of Jorge Luis Borges’ collection of essays <span class="link external"><a href="https://book.douban.com/subject/1461159" title="The Book of Imaginary Beings [https://book.douban.com/subject/1461159]">The Book of Imaginary Beings</a></span> (幻兽辞典) contains the comment that <quote>monsters will always stalk mythic stories because real animals are a deeply important part of human experience and because monstrous beings are combinations of the real and the imagined, the stuff of nightmares and dreams</quote>.
The Classical mythic centaur, which melds the forms of man and horse, has its Celtic counterpart in the Welsh horse-woman, <span class="link external"><a href="https://en.wikipedia.org/wiki/Rhiannon" title="Rhiannon [https://en.wikipedia.org/wiki/Rhiannon]">Rhiannon</a></span>. The Cretan <span class="link external"><a href="https://en.wikipedia.org/wiki/Minotaur" title="Minotaur [https://en.wikipedia.org/wiki/Minotaur]">Minotaur</a></span> (米诺陶洛斯), a hideous blend of bull and human, can perhaps be seen transmuted in Irish mythology to become the great fighting bulls of Ulster and Connacht, which had human speech and understanding, or, in Wales, the enchanted boar <span class="link external"><a href="https://en.wikipedia.org/wiki/Twrch_Trwyth" title="Twrch Trwyth [https://en.wikipedia.org/wiki/Twrch_Trwyth]">Twrch Trwyth</a></span> (图鲁夫图鲁维斯).
Borges even goes so far as to argue that monsters are ‘necessary’ for human society. In our own day, fascinated by space and the possibility of worlds beyond, we conjure up fantastic images of galactic monsters, nowhere more clearly presented than in the Star Wars <span class="link external"><a href="https://starwars.fandom.com/wiki/Cantina/Legends" title="cantina [https://starwars.fandom.com/wiki/Cantina/Legends]">cantina</a></span>, in which Skywalker and Solo encounter a collection of weird and wonderful beings from all over the Universe. Such are our modern mythic creations.
<pp>26</pp></p>
<p>A persistent feature of both Irish and Welsh mythology is the theme of the magical cauldron, a vessel capable of raising the dead and of providing ever-replenishing supplies of food. The Irish god <span class="link external"><a href="https://en.wikipedia.org/wiki/The_Dagda" title="Daghdha [https://en.wikipedia.org/wiki/The_Dagda]">Daghdha</a></span>, (‘the Good God’), possessed a huge inexhaustible cauldron. The central focus of the Irish Otherworld feast was the cauldron, which never ran out of food. One Irish cauldron-myth was associated with sacral kingship, where the new king of Ulster had to bathe in one, while consuming the meat and broth of a white mare he had ritually ‘married’. <pp>29</pp></p>
<p>$\S$ Ceridwen’s Cauldron: A Welsh mythic tale, preserved in a 13th-century text, <span class="link external"><a href="https://en.wikipedia.org/wiki/Book_of_Taliesin" title="The Book of Taliesin [https://en.wikipedia.org/wiki/Book_of_Taliesin]">The Book of Taliesin</a></span> (塔列辛之书), contains a rich story of an enchanted cauldron, whose contents endowed those who ate or drank from it with knowledge and inspiration. The cauldron’s keeper was Ceridwen. She bore two children, Crearwy (‘the light or beautiful one’) and Afagddu (‘black’ or ‘ugly’). Wanting to compensate her son for his ill-favoured appearance, his mother mixed a special brew in the cauldron, designed to give him absolute wisdom. Because the potion needed to boil for a year, Ceridwen appointed a young boy, Gwion, to watch over it. As he was tending the cauldron, three drops of scalding liquid splashed onto his hand and, without thinking, he licked his fingers, thus inadvertently acquiring the wisdom intended for Afagddu. Gwion’s flight and pursuit by the angry Ceridwen eventually caused Gwion’s rebirth as the great visionary poet Taliesin. <pp>30</pp></p>
<p><wavy>Words are powerful things</wavy>, the more so if they are spoken aloud, so that sound and meaning blend into a single powerful message that can be shared simultaneously by many people. Keepers of oral tradition had to have prodigiously long and accurate memories and the ability to learn long tales by heart, while adding embellishments along the way. Listeners, too, would remember stories they had heard all their lives, and would not have hesitated to point out errors or inconsistencies. <pp>43</pp></p>
</details></section>
<section class="block" data-taxon=""><details ><summary id="smaragdina-mourn-lawvere"><header><h1><span class="taxon"></span>为民主提供现代定义 — 悼念 F. William Lawvere <a class="slug" href="/smaragdina/mourn-lawvere">[mourn-lawvere]</a></h1><div class="metadata"><ul><li class="meta-item">October 28, 2024 — November 2, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC&display=swap" rel="stylesheet">
<style>
.kaiti {
  font-family: "LXGW WenKai TC", serif;
  font-style: normal;
}

em {
  font-family: "Inria Sans", serif;
  font-style: italic;
}
</style>
<p>
  <div style="text-align: center; display: block;">
    <div>
      <p>Central Committee, CPC<br></p>
      <p>译者: Kokic Hydrangea</p>
    </div>
  </div>
  <p><br></p>
  <div style="padding: 0 46px;">
    <div><strong>原文:</strong> Central Committee, Communist Party of Canada (Marxist-Leninist), <strong>Providing Democracy with a Modern Definition</strong>. TML MONTHLY, Newspaper of the Communist Party of Canada (Marxist-Leninist). Volume 53 Number 1 - January 2023. <a href="https://cpcml.ca/Tmlm2023/Articles/M530010.HTM"><span style="color: #ed008c;">https://cpcml.ca/Tmlm2023/Articles/M530010.HTM</span></a>.</div>
  </div>
  <p><br></p>
  <p>我们怀着深深的悲痛通知您, 著名数学家威廉·劳维尔 (William Lawvere) 博士于 2023 年 1 月 23 日去世. 劳维尔教授是加拿大共产党 (马列主义) 的好友, 他总在文明大道上前进, 致力于对抗并改变社会上的陈旧道德观念, 消除进步启蒙道路上的障碍.</p>
  <p>从 1970 年代初开始, 他与 CPC (M-L) <span style="color: #aaaaaa;">[</span><span style="color: #aaaaaa;">译注</span><span style="color: #aaaaaa;">:</span> <span style="color: #aaaaaa;">即</span> <em><span style="color: #aaaaaa;">Communist Party of Canada</span> <span style="color: #aaaaaa;">(Marxist-Leninist)</span></em><span style="color: #aaaaaa;">, 加拿大共产党</span> <span style="color: #aaaaaa;">(马列主义)</span><span style="color: #aaaaaa;">]</span> 的创始人和领导人哈迪尔·贝恩斯 (Hardial Bains) 一起从事了几个与变革的必要性和辩证法相关的哲学和其他项目, 哈迪尔·贝恩斯本身就是一位科学家和哲学家. 从 1969 年到 1971 年, 他是哈利法克斯达尔豪斯大学 <span style="color: #aaaaaa;">[</span><em><span style="color: #aaaaaa;">Halifax, Dalhousie University</span></em><span style="color: #aaaaaa;">]</span> 的 Killam 学者, 是一个著名的国际数学家团队的负责人, 他们来那里与他一起学习. 但在 1971 年, 当劳维尔教授抗议<span class="kaiti">《战争措施法》</span><span style="color: #aaaaaa;">[</span><em><span style="color: #aaaaaa;">War Measures Act</span></em><span style="color: #aaaaaa;">]</span> 和皮埃尔·特鲁多政府因暂停公民自由而犯下的罪行时, 达尔豪斯拒绝续签合同, 尽管他自己的数学家团队提出了抗议. 1,000 多名学生在 Dal Student Union 大楼的大厅集会, 反对任意解雇劳维尔教授.</p>
  <p>在许多场合, 劳维尔教授在加拿大与我们一起讨论重要话题, 并贡献了他对这些话题的全面而广泛的了解. 1996 年 2 月, 他在温莎大学举行的主题为 “<span class="kaiti">意识起源和社会变革</span>” <span style="color: #aaaaaa;">[</span><em><span style="color: #aaaaaa;">The Origin of Consciousness and Social Change</span></em><span style="color: #aaaaaa;">]</span> 的跨学科会议上发表了演讲. 在那个场合发表的论文提出了对独立于我们而存在的意识、冷战史学、现代民主人格的出现等的重要见解. 劳维尔教授发表了一篇题为<span class="kaiti">《数学改革的历史和哲学》</span><span style="color: #aaaaaa;">[</span><em><span style="color: #aaaaaa;">The History and Philosophy of Mathematic Reform</span></em><span style="color: #aaaaaa;">]</span> 的论文, 该论文研究了限制数学科学知识的教育学趋势的各个方面, 展示了这如何为促进神秘主义和盲目接受权威提供了有效的基础.</p>
  <p>1997 年, 他与来自世界各地的学者一起参加了贝恩斯同志的葬礼. 他还参加了 1998 年的 CPC (M-L) 第七次代表大会, 在那里他对哈迪尔·贝恩斯的工作表示赞赏, 并为正在讨论的论文做出了贡献. 2005 年, 他参加了党的 35 周年庆典, 再次表达了对党在理论和现代定义方面的工作的赞赏. 他后来写道, 35 周年纪念日 “是一个非常有意义的时刻. […] 特别是, 这一场合使我的工作取得了进一步的进展, 特别是为纪念列宁哲学著作一百周年的项目, 详细介绍了它们如何从自然科学的角度以及从为启蒙而进行的阶级斗争的角度, 成为研究 19 世纪和 20 世纪哲学发展的有用指南. 自从 35 年前哈迪尔指出这些书的重要性以来, 它们一直是我的伴侣. […]”</p>
  <p>听说劳维尔教授去世的消息后, 他的长期伙伴埃里克·霍夫曼 (Eric Hoffman) 在感谢哈迪尔·贝恩斯和比尔·劳维尔 (Bill Lawvere) <span style="color: #aaaaaa;">[</span><span style="color: #aaaaaa;">译注</span><span style="color: #aaaaaa;">:</span> <span style="color: #aaaaaa;">即 William Lawvere</span><span style="color: #aaaaaa;">]</span> 对他自己的生活和工作产生的深远影响时说:</p>
  <p>“从他们在 1960 年代独立完成的最早的开创性工作发展起来, 出现了一种新的、令人惊讶的联系的最有力证据. 这种联系构成了人类与自然之间关系的一部分, 并嵌入其中. 比尔指出, 这种复合体的客观性迫使人们坚持不懈地坚持空间和数量研究的需要.</p>
  <p>“在他博客上的一次采访中, 比尔说, ‘数学理论的核心是空间中数量的变化以及其中质量的出现.’ 无论考虑的是几何学、范畴、逻辑、政治形式的过渡、亲属关系还是任何其他因素, 比尔都证实了对立面的统一和同一性, 即辩证法, 是存在的.</p>
  <p>“比尔的工作将作为扩大启蒙空间的贡献而经久不衰.”</p>
  <p>在 CPC (M-L) 中央第一书记发给劳维尔教授家人的哀悼信中, 她写道:</p>
  <p>“比尔在他的一生中做出了如此多的贡献, 我们非常感激. 他对发现新事物的热情和奉献精神总是令人鼓舞. 他的方法总是充满活力、专注、在许多方面都很新鲜. 他作为教师的耐心、他的论点的智慧和连贯性、他对年轻一代和教化他们的热情, 以及他对文明崇高道路的勇敢坚持, 都非常出色.</p>
  <p>“与比尔会面总是非常高兴. 我们将永远珍惜他的友谊、慷慨的精神和对我们共同事业的奉献精神, 他为此毫不畏惧地大声疾呼. 这表明他是由特殊的东西组成的.</p>
  <p>为了说明他作为数学教育家的工作质量, 他解释手头问题并与那些对他的工作表现出兴趣的人讨论的直截了当的方法, 我们举了他对提供 “为什么范畴论可能如此有用的广泛理由” 的请求的回答的例子. 以下是比尔不得不说的话:</p>
  <blockquote><span class="kaiti">人类的日常活动, 如在溪流旁的山上建造房屋、铺设电话管道网络、在太阳系中航行, 都需要可行的计划. 规划任何此类工作都需要发展对空间的思考. 每个发展都涉及许多思考步骤和许多相关的空间几何结构. 由于思考空间的必要多步骤性质, 必须采取独特的数学措施来使其可靠. 只有明确的思维原则</span> <span class="kaiti">(逻辑) 和明确的空间原则</span> <span class="kaiti">(几何) 才能保证可靠性. 艾伦伯格和麦克莱恩 60 年前发明的理论所取得的巨大进步使逻辑和几何学的原则变得明确; 这是通过发现逻辑和几何学的常见形式来实现的, 因此两者之间关系的原则也是明确的. 他们解决了亚里士多德在 2300 年前提出的一个问题, 当时亚里士多德最初在明确概念范畴方面取得了进展. 在 21 世纪, 他们的解决方案不仅适用于平面几何和中世纪三段论, 还适用于无穷维变换空间、数据</span> <span class="kaiti">“空间” 以及每天应用数千次的其他概念工具. 逻辑和几何原理的形式都是由分类论者发现的, 它建立在空间之间转换和内部转换的</span> <span class="kaiti">“自然性” 之上.</span></blockquote>
  <p>以下是 Lawvere 教授去世时发布的讣告. 我们添加了 1971 年 1 月 22 日<span class="kaiti">《达尔豪斯公报》</span><span style="color: #aaaaaa;">[</span><em><span style="color: #aaaaaa;">Dalhousie Gazette</span></em><span style="color: #aaaaaa;">]</span> 上关于他被达尔豪斯大学开除的文章的传真件. 我们还提供了 Lawvere 博士在 1996 年 2 月 9 日至 11 日在温莎大学举行的关于意识起源和社会变革的跨学科会议上发表的题为 “<span class="kaiti">数学改革的历史和哲学</span>” <span style="color: #aaaaaa;">[</span><em><span style="color: #aaaaaa;">The History and Philosophy of Mathematic Reform</span></em><span style="color: #aaaaaa;">]</span> 的论文. 最后, 我们提供了对 Lawvere 博士的采访, 他用自己的话解释了他的工作.</p>
  <p>我们向比尔的终身伴侣和合作者、他的子女、孙子、兄弟姐妹以及许许多多的朋友和同事表示最深切的哀悼. 愿他们都在共同创造的回忆中找到慰藉.</p>
</p>
</details></section></p>
</details></section></p>
</details></section><section class="block" data-taxon=""><details ><summary id="mille-plateaux-bubble-compose"><header><h1><span class="taxon"></span>冒泡排序合成置换分解 <a class="slug" href="/mille-plateaux/bubble-compose">[bubble-compose]</a></h1><div class="metadata"><ul><li class="meta-item">December 26, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link local"><a href="/pearls" title="Pearls [pearls]">Pearls</a></span></li></ul></div></header></summary>
<p>任意置换 $\sigma$ 都可被写成若干个对换之积. 这里, 集合 $X$ 上的置换是指 $X$ 到 $X$ 的双射. 而对换 $(i ~ j)$ 则是交换元素 $i,j$ 位置的映射.</p>
<p><section class="block" data-taxon="Proof"><details ><summary id="mille-plateaux-bubble-compose-pf"><header><h1><span class="taxon">Proof. </span> (笔者) <a class="slug" href="/mille-plateaux/bubble-compose-pf">[bubble-compose-pf]</a></h1><div class="metadata"><ul><li class="meta-item">December 27, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>冒泡排序使用若干次对换将 $X$, $Y$ 打到有序列表 $Z$, 把这些对换之积复合出的两个映射记为 $\sigma_X, \sigma_Y$. 现在观察下图, 写出 $\sigma_Y^{-1}\sigma_X$, 这当然就是 $\sigma$.</p>
<p><figure><img src="/mille-plateaux/bubble-compose.svg" class="color-invert"/></figure></p>
</details></section></p>
</details></section><section class="block" data-taxon="Problem"><details ><summary id="mille-plateaux-canterbury-2A"><header><h1><span class="taxon">Problem. </span>古代物理学博士问题 <a class="slug" href="/mille-plateaux/canterbury-2A">[canterbury-2A]</a></h1><div class="metadata"><ul><li class="meta-item">December 26, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link local"><a href="/pearls" title="Pearls [pearls]">Pearls</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>有两个正方体, 一个边长为 $1$, 另一个边长为 $2$. 请找到另外两个边长为有理数的正方体使它们的体积总和相同. 换言之, 求下述方程的一组 (正) 有理解.</p>
<p>$$ x^3 + y^3 \spaces= 9 \quad \color{gray}{(= ~ 1^3+2^3)} $$</p>
<p><section class="block" data-taxon="Solution"><details ><summary id="mille-plateaux-canterbury-2B"><header><h1><span class="taxon">Solution. </span> <a class="slug" href="/mille-plateaux/canterbury-2B">[canterbury-2B]</a></h1><div class="metadata"><ul><li class="meta-item">December 26, 2024</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li></ul></div></header></summary>
<p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>我们先画出 $x^3 + y^3 = 9$. 然后由已知的 $P=(1,2)$ 出发做切线得到 $2P$, $4P$, $8P$. 这种几乎全凭借运气的操作是 <span class="link external"><a href="https://en.wikipedia.org/wiki/Pierre_de_Fermat" title="Fermat [https://en.wikipedia.org/wiki/Pierre_de_Fermat]">Fermat</a></span> 及 <span class="link external"><a href="https://en.wikipedia.org/wiki/Fran%C3%A7ois_Vi%C3%A8te" title="Viète [https://en.wikipedia.org/wiki/Fran%C3%A7ois_Vi%C3%A8te]">Viète</a></span> 研究此类问题的方式.</p>
<p><figure><img src="/mille-plateaux/8P.svg" class="color-invert"/></figure></p>
<p>如图, 随后注意到 $8P$ 恰好位于 $x &gt; 0,y &gt; 0$ 的区域, 现在写出其坐标.</p>
<p>$$ 8P \spaces= \left(\frac{1243617733990094836481}{609623835676137297449}, \frac{487267171714352336560}{609623835676137297449}\right) $$</p>
</details></section></p>
</details></section><section class="block" data-taxon=""><details ><summary id="pftb-P005"><header><h1><span class="taxon"></span>素数无限多与 Furstenberg 拓扑 <a class="slug" href="/pftb-P005">[pftb-P005]</a></h1><div class="metadata"><ul><li class="meta-item">August 31, 2025</li><li class="meta-item"><span class="link local"><a href="/kokic" title="Kokic Liu [kokic]">kokic</a></span></li><li class="meta-item"><span class="link local"><a href="/bib/pftb" title="Proofs from THE BOOK [bib/pftb]">Proofs from THE BOOK, p. 5</a></span></li><li class="meta-item"><span class="link local"><a href="/pearls" title="Pearls [pearls]">Pearls</a></span></li></ul></div></header></summary>
<link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC&display=swap" rel="stylesheet">
<style>
.kaiti {
  font-family: "LXGW WenKai TC", serif;
  font-style: normal;
}
</style>
<p>$\gdef\Z{\mathbf{Z}}$
$\gdef\PP{\mathbf{P}}$</p>
<p>此证明由 <span class="link external"><a href="https://en.wikipedia.org/wiki/Hillel_Furstenberg" title="Hillel Furstenberg [https://en.wikipedia.org/wiki/Hillel_Furstenberg]">Hillel Furstenberg</a></span> 于 1955 年提出 <sup class="footnote-reference" id="pftb-P005_furstenberg-back"><a href="#pftb-P005_furstenberg">1</a></sup>. 这一页配图的说明文字也很有意思, 其写道</p>
<blockquote>
<p>Pitching flat rocks, infinitely. $\quad$ <span class="kaiti">(掷扁石, 至无穷远.) </span></p>
</blockquote>
<p>对 $a,b \in \Z, b &gt; 0$, 令 $N_{a,b} = \{ a + nb : n \in \Z \}$. 每个集合 $N_{a,b}$ 都是正负无界的算术级数. 如果集合 $O \subseteq \Z$ 满足以下条件之一:</p>
<ol>
<li>$O$ 是空集.</li>
<li>对任意的 $a \in O$ 存在 $b &gt; 0$ 使得 $N_{a,b} \subseteq O$.</li>
</ol>
<p>则称 $O$ 是开集. 这些条件保证 $O$ 在 $a$ 点附近 “稠密”. 显然, 开集的并总是开集. 另外, 如果 $O_1$ 和 $O_2$ 开, 则对任意的 $a \in O_1 \cap O_2$, $N_{a,b_1} \subseteq O_1$ 及 $N_{a,b_2} \subseteq O_2$, 都有 $a \in N_{a,b_1b_2} \subseteq O_1 \cap O_2$. 所以开集的有限交也开. 从而此处定义的开集族的确导出了 $\Z$ 上的一个拓扑. 随后, 我们注意:</p>
<p>   $(\text{A})$ 每个非空的开集都是无界的, 显然. <br />
   $(\text{B})$ 每个 $N_{a,b}$ 都是既开又闭的. 因为 $N_{a,b} = \mathbb{Z} \setminus \bigcup_{i=1}^{b-1} N_{a+i,b}$, 这说明 $N_{a,b}$ 是开集的补, 因而闭.</p>
<p>现在我们引出素数. 对于每个整数 $n \neq 1,-1$ 都有某个素因子 $p$ 使得 $n \in N_{0,p}$ 以及 $\Z \setminus \{\pm1\} = \bigcup_{p \in \PP} N_{0,p}$. 如果 $\PP$ 是有限的, 那么根据 $(\text B)$, $\bigcup_{p \in \PP} N_{0,p}$ 将是有限个闭集的并, 所以是闭的. 进而可以导出 $\{\pm1\}$ 是一个开集, 这与 $(\text A)$ 矛盾, 证毕.</p>
<p>我们回顾证明, 不难发现核心是用拓扑解释 “每个整数都有素因子” 这件事, 进而 $\bigcup_{p \in \PP} N_{0,p} = \Z \setminus \{\pm1\}$ 在 $\Z$ 上稠密, 于是 $\PP$ 绝不可能有限. 此方法实质利用了算术级数的性质, 而非拓扑内涵. 所以也可以翻译成不使用拓扑的版本, 见 Idris D. Mercer 写的 
<span class="link external"><a href="http://www.idmercer.com/monthly355-356-mercer.pdf" title="On Furstenberg’s Proof of theInfinitude of Primes [http://www.idmercer.com/monthly355-356-mercer.pdf]">On Furstenberg’s Proof of theInfinitude of Primes</a></span>.</p>
<div class="footnote-definition" id="pftb-P005_furstenberg">
  <sup class="footnote-definition-label"><a href="#pftb-P005_furstenberg-back">1</a></sup>
<p>Furstenberg 当时是 Yeshiva 大学的本科生, 其在美国数学月刊上发表了 <span class="link external"><a href="https://en.wikipedia.org/wiki/Furstenberg%27s_proof_of_the_infinitude_of_primes" title="“On the infinitude of primes” [https://en.wikipedia.org/wiki/Furstenberg%27s_proof_of_the_infinitude_of_primes]">“On the infinitude of primes”</a></span>, 这才有了 <span class="link local"><a href="/bib/pftb" title="Proofs from THE BOOK [bib/pftb]">Proofs from THE BOOK</a></span> 对此证明的收录.</p>
</div>
</details></section></details></section></footer></article></div></body></html>